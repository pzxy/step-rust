use std::cmp::Ordering;
// é»˜è®¤ä¼šå°† prelude å¯¼å…¥åˆ°æ¯ä¸ªåŒ…é‡Œé¢ã€‚å¦‚æœè¦ä½¿ç”¨ä»¥å¤–çš„åº“ä¸­å†…å®¹ï¼Œå°±éœ€è¦ä½¿ç”¨ useå°†åŒ…å¯¼å…¥è¿›æ¥ã€‚
use std::io;
use rand::Rng;// trait ç›¸å½“äºæ¥å£ï¼Œé‡Œé¢å®šä¹‰äº†ä¸€äº›æ–¹æ³•ã€‚

fn main() {
    // å¸¦äº†ä¸€ä¸ªï¼ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå®ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ã€‚
    println!("Hello, world!");
    // 1ï½101ä¹Ÿæ˜¯åŒ…å¤´ä¸åŒ…å°¾
    let secret_number = rand::thread_rng().gen_range(1, 101);
    println!("ç¥ç§˜æ•°å­—: {}", secret_number);
    loop {
        println!("çŒœä¸€ä¸ªæ•°");
        // å¦‚æœä¸åŠ mutï¼Œåˆ™è¿™ä¸ªå˜é‡ä¸èƒ½è¢«äºŒæ¬¡èµ‹å€¼ã€‚
        // :: è¡¨ç¤ºnewæ˜¯Stringä¸­çš„ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œç±»ä¼¼javaä¸­é™æ€æ–¹æ³•ã€‚
        let mut guess = String::new();
        // è¿™é‡Œä¹Ÿå¯ä»¥å–æ¶ˆä¸Šé¢çš„useï¼Œç„¶åè¿™æ ·è°ƒç”¨ï¼š
        // std::io::stdin().read_line ç­‰ç­‰;
        // &è¡¨ç¤ºå¼•ç”¨ï¼Œå¼•ç”¨åœ¨rustä¸­ä¹Ÿæ˜¯ä¸å¯å˜çš„ï¼Œæ‰€ä»¥è¦åŠ ä¸Šmut
        // read_line()è¿”å›ç±»å‹io::Resultï¼Œè¿™ç›¸å½“äºä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œ
        // è¿™ä¸ªç±»å‹æœ‰ä¸¤ä¸ªå­—æ®µ OK,Err,expectæ˜¯å¯¹ç»“æœè¿›è¡Œå¤„ç†ï¼Œå¦‚æœè¿”å›æ˜¯Erråˆ™ä¸­æ–­ç¨‹åºå¹¶é€€å‡º
        io::stdin().read_line(&mut guess).expect("æ— æ³•è¯»å–");
        // åœ¨è¿™é‡Œé‡æ–° ä½¿ç”¨guessï¼Œæ˜¯ä¸€ä¸ª shadowçš„æ¦‚å¿µ
        //  let guess: u32 è¿™æ ·çš„å†™æ³•ï¼Œæ˜¾ç¤ºæŒ‡å®šå˜é‡ç±»å‹ã€‚
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("ä½ çŒœæµ‹çš„æ•°æ˜¯:{}", guess);
        // ç±»ä¼¼switchï¼Œ
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small"),// è¿™ç§å†™æ³•ï¼Œæ˜¯armæ¦‚å¿µã€‚
            Ordering::Greater => println!("Too big"),//arm
            Ordering::Equal => {
                println!("You win");//arm
                break;
            }
        }
    }
}


fn r_type() {
    // boolç±»å‹å°±æ˜¯ bool
    // æ•´å‹ i32 u32 isize usizeç­‰
    // æµ®ç‚¹å‹ f32 f64
    // å­—ç¬¦ç±»å‹æ¯”è¾ƒç‰¹æ®Šï¼Œæ˜¯Unicodeç±»å‹ï¼Œæ”¯æŒemojiï¼Œæ¯”è¾ƒç‰¹æ®Šã€‚èŒƒå›´ U+0000~U+D7FF , U+E000~U+10FFFF ã€‚
    let a = '2';
    let b = '$';
    let c = 'ğŸ¤”';
}

// tuple å…ƒç»„
fn r_tuple() {
    // å¯ä»¥å°†ä¸åŒç±»å‹æ•°æ®æ”¾åˆ°ä¸€èµ·
    let s: (i32, f64, u8) = (500, 6.4, 1);
    // è·å–tupå…ƒç´ ï¼Œè®¿é—®tupå…ƒç´ 
    let (x, y, z) = s;
    println!("{} ,{} ,{}", x, y, z);
    // é€šè¿‡.indexè·å–
    println!("{} ,{} ,{}", s.0, s.1, s.2);
}

// æ•°ç»„ï¼Œå°†æ•°æ®æ”¾åœ¨æ ˆä¸Šï¼Œè€Œä¸æ˜¯å †ä¸Š
fn r_array() {
    // è‡ªåŠ¨åˆ¤æ–­ç±»å‹
    let a = ["1", "2", "3"];
    // å£°æ˜ç±»å‹
    let b: [i32; 5] = [1, 2, 3, 4, 5];
    // [3,3,3,3,3]
    let c = [3; 5];
    // è®¿é—®è¶Šç•Œï¼Œè¦æ³¨æ„
    println!(b[12])
}

// è¯­å¥å’Œè¡¨è¾¾å¼ï¼Œè¯­å¥åŒ…æ‹¬è¡¨è¾¾å¼ï¼Œè¯­å¥è¿”å›å€¼æ˜¯ç©ºçš„ï¼Œè¡¨è¾¾å¼æœ‰è¿”å›å€¼{},
// ;æ˜¯å‘Šè¯‰ä¸€ä¸ªè¯­å¥çš„ç»“æŸã€‚
fn r_fn() {
    let condition = true;
    // ifå’Œelseéƒ½æ˜¯è¡¨è¾¾å¼ï¼Œè¡¨è¾¾å¼æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œæ‰€ä»¥å¯ä»¥æ”¾åœ¨ç­‰å·çš„å³è¾¹ã€‚
    // è¡¨è¾¾å¼çš„æœ€åä¸€ä¸ªå€¼å°±æ˜¯è¡¨è¾¾å¼çš„è¿”å›å€¼ï¼Œè¿™é‡Œifè¡¨è¾¾å¼è¿”å›çš„æ˜¯1ã€‚
    let number = if condition { 1 } else { 2 };
    println!("number:{}", number)
}

fn r_for_while_loop() {
    // loop ç›¸å½“äºgoé‡Œé¢çš„for {}
    // while å°±æ˜¯ä¼ ç»Ÿçš„é‚£ç§
    let a = [10, 20, 30, 40];
    for e in a.iter() {
        println!("value:{}", e);
    }
    // åŒ…å¤´ä¸åŒ…å°¾
    for number in (1..4).rev() {
        // è¾“å‡º 3 2 1
        print!(number)
    }
}