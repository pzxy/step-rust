/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBCPP_ABI_VERSION: u32 = 1;
pub const _LIBCPP_HARDENING_MODE_DEFAULT: u32 = 2;
pub const _LIBCPP_VERSION: u32 = 180100;
pub const _LIBCPP_STD_VER: u32 = 11;
pub const _LIBCPP_OBJECT_FORMAT_MACHO: u32 = 1;
pub const _LIBCPP_HARDENING_MODE_NONE: u32 = 2;
pub const _LIBCPP_HARDENING_MODE_FAST: u32 = 4;
pub const _LIBCPP_HARDENING_MODE_EXTENSIVE: u32 = 16;
pub const _LIBCPP_HARDENING_MODE_DEBUG: u32 = 8;
pub const _LIBCPP_HARDENING_MODE: u32 = 2;
pub const _LIBCPP_LOCALE__L_EXTENSIONS: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150200;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const USE_CLANG_STDARG: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const DJI_ERROR_MODULE_INDEX_OFFSET: u32 = 32;
pub const DJI_ERROR_MODULE_INDEX_MASK: u64 = 1095216660480;
pub const DJI_ERROR_RAW_CODE_OFFSET: u32 = 0;
pub const DJI_ERROR_RAW_CODE_MASK: u32 = 4294967295;
pub const DJI_PI: f64 = 3.141592653589793;
pub const DJI_FILE_NAME_SIZE_MAX: u32 = 256;
pub const DJI_FILE_PATH_SIZE_MAX: u32 = 512;
pub const DJI_IP_ADDR_STR_SIZE_MAX: u32 = 15;
pub const DJI_MD5_BUFFER_LEN: u32 = 16;
pub const DJI_SUBSCRIPTION_MODULE_INDEX_OFFSET: u32 = 24;
pub const DJI_SUBSCRIPTION_MODULE_INDEX_MASK: u32 = 4278190080;
pub const DJI_SUBSCRIPTION_TOPIC_CODE_OFFSET: u32 = 0;
pub const DJI_SUBSCRIPTION_TOPIC_CODE_MASK: u32 = 16777215;
pub const EMERGENCY_STOP_MOTOR_MSG_MAX_LENGTH: u32 = 10;
pub const IMAGE_MAX_DIRECTION_NUM: u32 = 6;
pub const DJI_PERCEPTION_INTRINSICS_PARAM_ARRAY_NUM: u32 = 9;
pub const DJI_PERCEPTION_ROTATION_PARAM_ARRAY_NUM: u32 = 9;
pub const DJI_PERCEPTION_TRANSLATION_PARAM_ARRAY_NUM: u32 = 3;
pub const DJI_VERSION_MAJOR: u32 = 3;
pub const DJI_VERSION_MINOR: u32 = 9;
pub const DJI_VERSION_MODIFY: u32 = 2;
pub const DJI_VERSION_BETA: u32 = 0;
pub const DJI_VERSION_BUILD: u32 = 2125;
pub const DJI_WIDGET_FLOATING_WINDOW_MSG_MAX_LEN: u32 = 255;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const ::std::os::raw::c_char, __n: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: usize,
    ) -> usize;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: usize,
    ) -> usize;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_exception_state64_v2 {
    pub __far: __uint64_t,
    pub __esr: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
impl Default for __darwin_arm_vfp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
impl Default for __darwin_mcontext32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
impl Default for __darwin_sigaltstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
impl Default for __darwin_ucontext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
impl Default for __siginfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
impl Default for __sigaction_u {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
impl Default for __sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_neural_footprint: u64,
    pub ri_lifetime_max_neural_footprint: u64,
    pub ri_interval_max_neural_footprint: u64,
    pub ri_reserved: [u64; 9usize],
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for wait {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut u32, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const u32, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char, arg2: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char, arg1: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub const E_DjiErrorModule_DJI_ERROR_MODULE_SYSTEM: E_DjiErrorModule = 0;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_PLATFORM: E_DjiErrorModule = 1;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_LOGGER: E_DjiErrorModule = 2;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_TIME_SYNC: E_DjiErrorModule = 3;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_COMMAND: E_DjiErrorModule = 4;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_CAMERA: E_DjiErrorModule = 5;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_GIMBAL: E_DjiErrorModule = 6;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_XPORT: E_DjiErrorModule = 7;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_PAYLOAD_COLLABORATION: E_DjiErrorModule = 8;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_WIDGET: E_DjiErrorModule = 9;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_CORE: E_DjiErrorModule = 10;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_IDENTITY: E_DjiErrorModule = 11;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_TRANSMISSION: E_DjiErrorModule = 12;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_DATA_CHANNEL: E_DjiErrorModule = 13;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_SUBSCRIPTION: E_DjiErrorModule = 14;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_MOP_CHANNEL: E_DjiErrorModule = 15;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_POSITIONING: E_DjiErrorModule = 16;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_POWER_MANAGEMENT: E_DjiErrorModule = 17;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_AIRCRAFTINFO: E_DjiErrorModule = 18;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_PRODUCTINFO: E_DjiErrorModule = 19;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FLOWCONTROLLER: E_DjiErrorModule = 20;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_DOWNLOADER: E_DjiErrorModule = 21;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_PARAMETER: E_DjiErrorModule = 22;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_UTIL: E_DjiErrorModule = 23;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_USER: E_DjiErrorModule = 24;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_NEGOTIATE: E_DjiErrorModule = 25;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_UPGRADE: E_DjiErrorModule = 26;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FC_BASIC: E_DjiErrorModule = 27;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FC_JOYSTICK: E_DjiErrorModule = 28;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FC_ACTION: E_DjiErrorModule = 29;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FC_ARREST_FLYING: E_DjiErrorModule = 30;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FC_HOME_LOCATION: E_DjiErrorModule = 31;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_FC_EMERGENCY_STOP_MOTOR: E_DjiErrorModule = 32;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_CAMERA_MANAGER: E_DjiErrorModule = 33;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_GIMBAL_MANAGER: E_DjiErrorModule = 34;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_WAYPOINT_V2: E_DjiErrorModule = 35;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_WAYPOINT_V3: E_DjiErrorModule = 36;
pub const E_DjiErrorModule_DJI_ERROR_MODULE_ERROR: E_DjiErrorModule = 37;
#[doc = " @brief DJI module enum for defining error code."]
pub type E_DjiErrorModule = ::std::os::raw::c_uint;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_SUCCESS:
    E_DjiErrorSystemModuleRawCode = 0;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_INVALID_REQUEST_PARAMETER : E_DjiErrorSystemModuleRawCode = 212 ;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_EXECUTING_HIGHER_PRIORITY_TASK : E_DjiErrorSystemModuleRawCode = 215 ;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_NONSUPPORT:
    E_DjiErrorSystemModuleRawCode = 224;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_TIMEOUT:
    E_DjiErrorSystemModuleRawCode = 225;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_MEMORY_ALLOC_FAILED:
    E_DjiErrorSystemModuleRawCode = 226;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_INVALID_PARAMETER:
    E_DjiErrorSystemModuleRawCode = 227;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_NONSUPPORT_IN_CURRENT_STATE : E_DjiErrorSystemModuleRawCode = 228 ;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_SYSTEM_ERROR:
    E_DjiErrorSystemModuleRawCode = 236;
#[doc = "< Module is too not activated yet"]
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_MODULE_INACTIVATED:
    E_DjiErrorSystemModuleRawCode = 238;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_HARDWARE_ERR:
    E_DjiErrorSystemModuleRawCode = 250;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_INSUFFICIENT_ELECTRICITY : E_DjiErrorSystemModuleRawCode = 251 ;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_UNKNOWN:
    E_DjiErrorSystemModuleRawCode = 255;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_NOT_FOUND:
    E_DjiErrorSystemModuleRawCode = 256;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_OUT_OF_RANGE:
    E_DjiErrorSystemModuleRawCode = 257;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_BUSY:
    E_DjiErrorSystemModuleRawCode = 258;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_DUPLICATE:
    E_DjiErrorSystemModuleRawCode = 259;
pub const E_DjiErrorSystemModuleRawCode_DJI_ERROR_SYSTEM_MODULE_RAW_CODE_ADAPTER_NOT_MATCH:
    E_DjiErrorSystemModuleRawCode = 260;
#[doc = " @brief Raw error code of system module."]
pub type E_DjiErrorSystemModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_PARAMETER_ERROR : E_DjiErrorIdentityModuleActivationRawCode = 1 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_ENCODE_ERROR : E_DjiErrorIdentityModuleActivationRawCode = 2 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_NEW_DEVICE_ERROR : E_DjiErrorIdentityModuleActivationRawCode = 3 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_SOFTWARE_NOT_CONNECTED : E_DjiErrorIdentityModuleActivationRawCode = 4 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_NETWORK_ERROR : E_DjiErrorIdentityModuleActivationRawCode = 5 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_SERVER_ACCESS_REFUSED : E_DjiErrorIdentityModuleActivationRawCode = 6 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_ACCESS_LEVEL_ERROR : E_DjiErrorIdentityModuleActivationRawCode = 7 ;
pub const E_DjiErrorIdentityModuleActivationRawCode_DJI_ERROR_IDENTITY_MODULE_RAW_CODE_ACTIVATE_OSDK_VERSION_ERROR : E_DjiErrorIdentityModuleActivationRawCode = 8 ;
#[doc = " @brief Raw error code of activation of identity module."]
pub type E_DjiErrorIdentityModuleActivationRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_PITCH_REACH_POSITIVE_LIMIT : E_DjiErrorGimbalModuleRawCode = 0 ;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_PITCH_REACH_NEGATIVE_LIMIT : E_DjiErrorGimbalModuleRawCode = 1 ;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_ROLL_REACH_POSITIVE_LIMIT : E_DjiErrorGimbalModuleRawCode = 2 ;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_ROLL_REACH_NEGATIVE_LIMIT : E_DjiErrorGimbalModuleRawCode = 3 ;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_YAW_REACH_POSITIVE_LIMIT : E_DjiErrorGimbalModuleRawCode = 4 ;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_YAW_REACH_NEGATIVE_LIMIT : E_DjiErrorGimbalModuleRawCode = 5 ;
pub const E_DjiErrorGimbalModuleRawCode_DJI_ERROR_GIMBAL_MODULE_RAW_CODE_NON_CONTROL_AUTHORITY:
    E_DjiErrorGimbalModuleRawCode = 6;
#[doc = " @brief Raw error code of gimbal module."]
pub type E_DjiErrorGimbalModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorPayloadCollaborationModuleRawCode_DJI_ERROR_PAYLOAD_COLLABORATION_MODULE_RAW_CODE_POSITION_NOT_MATCH : E_DjiErrorPayloadCollaborationModuleRawCode = 0 ;
#[doc = " @brief Raw error code of payload collaboration module."]
pub type E_DjiErrorPayloadCollaborationModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorSubscriptionModuleRawCode_DJI_ERROR_SUBSCRIPTION_MODULE_RAW_CODE_INVALID_TOPIC_FREQ : E_DjiErrorSubscriptionModuleRawCode = 0 ;
pub const E_DjiErrorSubscriptionModuleRawCode_DJI_ERROR_SUBSCRIPTION_MODULE_RAW_CODE_TOPIC_DUPLICATE : E_DjiErrorSubscriptionModuleRawCode = 1 ;
pub const E_DjiErrorSubscriptionModuleRawCode_DJI_ERROR_SUBSCRIPTION_MODULE_RAW_CODE_TOPIC_NOT_SUBSCRIBED : E_DjiErrorSubscriptionModuleRawCode = 2 ;
pub const E_DjiErrorSubscriptionModuleRawCode_DJI_ERROR_SUBSCRIPTION_MODULE_RAW_CODE_TIMESTAMP_NOT_ENABLE : E_DjiErrorSubscriptionModuleRawCode = 3 ;
pub const E_DjiErrorSubscriptionModuleRawCode_DJI_ERROR_SUBSCRIPTION_MODULE_RAW_CODE_TOPIC_NOT_SUPPORTED : E_DjiErrorSubscriptionModuleRawCode = 4 ;
#[doc = " @brief Raw error code of subscription module."]
pub type E_DjiErrorSubscriptionModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorMopChannelModuleRawCode_DJI_ERROR_MOP_CHANNEL_MODULE_RAW_CODE_CONNECTION_CLOSE : E_DjiErrorMopChannelModuleRawCode = 11 ;
#[doc = " @brief Raw error code of mop channel module."]
pub type E_DjiErrorMopChannelModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_RC_MODE_ERROR:
    E_DjiErrorFCModuleRawCode = 0;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_RELEASE_CONTROL_SUCCESS:
    E_DjiErrorFCModuleRawCode = 1;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_OBTAIN_CONTROL_SUCCESS:
    E_DjiErrorFCModuleRawCode = 2;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_OBTAIN_CONTROL_IN_PROGRESS:
    E_DjiErrorFCModuleRawCode = 3;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_RELEASE_CONTROL_IN_PROGRESS:
    E_DjiErrorFCModuleRawCode = 4;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_RC_NEED_MODE_P:
    E_DjiErrorFCModuleRawCode = 5;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_RC_NEED_MODE_F:
    E_DjiErrorFCModuleRawCode = 6;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_PARAM_READ_WRITE_INVALID_PARAM:
    E_DjiErrorFCModuleRawCode = 7;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_IOC_OBTAIN_CONTROL_ERROR:
    E_DjiErrorFCModuleRawCode = 201;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_KEY_ERROR:
    E_DjiErrorFCModuleRawCode = 65280;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_NO_AUTHORIZATION_ERROR:
    E_DjiErrorFCModuleRawCode = 65281;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_NO_RIGHTS_ERROR:
    E_DjiErrorFCModuleRawCode = 65282;
pub const E_DjiErrorFCModuleRawCode_DJI_ERROR_FC_MODULE_RAW_CODE_SYSTEM_ERROR:
    E_DjiErrorFCModuleRawCode = 65283;
#[doc = " @brief Raw error code of flight controller module."]
pub type E_DjiErrorFCModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_SUCCESS:
    E_DjiErrorFCJoystickModuleRawCode = 0;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_DEVICE_NOT_ALLOW : E_DjiErrorFCJoystickModuleRawCode = 1 ;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_ENGINE_STARTING : E_DjiErrorFCJoystickModuleRawCode = 2 ;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_TAKING_OFF:
    E_DjiErrorFCJoystickModuleRawCode = 3;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_LANDING:
    E_DjiErrorFCJoystickModuleRawCode = 4;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_CMD_INVALID:
    E_DjiErrorFCJoystickModuleRawCode = 5;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_RC_NOT_P_MODE:
    E_DjiErrorFCJoystickModuleRawCode = 6;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_CMD_LENGTH_ERROR : E_DjiErrorFCJoystickModuleRawCode = 7 ;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_HAS_NO_JOYSTICK_AUTHORITY : E_DjiErrorFCJoystickModuleRawCode = 8 ;
pub const E_DjiErrorFCJoystickModuleRawCode_DJI_ERROR_FC_JOYSTICK_MODULE_RAW_CODE_IN_RC_LOST_ACTION : E_DjiErrorFCJoystickModuleRawCode = 9 ;
#[doc = " @brief Raw error code of flight controller joystick module."]
pub type E_DjiErrorFCJoystickModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_MOTOR_ON : E_DjiErrorFCActionModuleRawCode = 1 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_MOTOR_OFF : E_DjiErrorFCActionModuleRawCode = 2 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_IN_AIR : E_DjiErrorFCActionModuleRawCode = 3 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_NOT_IN_AIR : E_DjiErrorFCActionModuleRawCode = 4 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_HOME_POINT_NOT_SET : E_DjiErrorFCActionModuleRawCode = 5 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_BAD_GPS : E_DjiErrorFCActionModuleRawCode = 6 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_IN_SIMULATION : E_DjiErrorFCActionModuleRawCode = 7 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_CANNOT_START_MOTOR : E_DjiErrorFCActionModuleRawCode = 17 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_LOW_VOLTAGE : E_DjiErrorFCActionModuleRawCode = 18 ;
pub const E_DjiErrorFCActionModuleRawCode_DJI_ERROR_FC_ACTION_MODULE_RAW_CODE_TRIGGER_ERROR_SPEED_TOO_LARGE : E_DjiErrorFCActionModuleRawCode = 20 ;
#[doc = " @brief Raw error code of flight controller action module."]
pub type E_DjiErrorFCActionModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_REGISTER_LOGOUT_SET_SUCCESS : E_DjiErrorFCArrestFlyingModuleRawCode = 0 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_REGISTER_LOGOUT_NULL_POINTER : E_DjiErrorFCArrestFlyingModuleRawCode = 1 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_HMS_CODE_HAS_REGISTED : E_DjiErrorFCArrestFlyingModuleRawCode = 2 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_HMS_CODE_NOT_FIND : E_DjiErrorFCArrestFlyingModuleRawCode = 3 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_ADD_ITEM_NO_DECRIPTION : E_DjiErrorFCArrestFlyingModuleRawCode = 4 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_REGISTER_ID_INVALID : E_DjiErrorFCArrestFlyingModuleRawCode = 5 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_STOP_IN_AIR_HMSCODE_NOT_IN_WHITE_TABLE : E_DjiErrorFCArrestFlyingModuleRawCode = 6 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_INVALID_FORMAT_HMSCODE : E_DjiErrorFCArrestFlyingModuleRawCode = 7 ;
pub const E_DjiErrorFCArrestFlyingModuleRawCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_RAW_CODE_HMSCODE_NOT_IN_WHITE_TABLE : E_DjiErrorFCArrestFlyingModuleRawCode = 8 ;
#[doc = " @brief Raw error code of flight controller arrest flying module."]
pub type E_DjiErrorFCArrestFlyingModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorFCHomeLocationModuleRawCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_RAW_CODE_UNKNOWN_FAILED_REASON : E_DjiErrorFCHomeLocationModuleRawCode = 1 ;
pub const E_DjiErrorFCHomeLocationModuleRawCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_RAW_CODE_INVALID_GPS_COORDINATE : E_DjiErrorFCHomeLocationModuleRawCode = 2 ;
pub const E_DjiErrorFCHomeLocationModuleRawCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_RAW_CODE_NOT_BE_RECORD : E_DjiErrorFCHomeLocationModuleRawCode = 3 ;
pub const E_DjiErrorFCHomeLocationModuleRawCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_RAW_CODE_GPS_NOT_READY : E_DjiErrorFCHomeLocationModuleRawCode = 4 ;
pub const E_DjiErrorFCHomeLocationModuleRawCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_RAW_CODE_DIS_TOO_FAR : E_DjiErrorFCHomeLocationModuleRawCode = 5 ;
#[doc = " @brief Raw error code of flight controller home location module."]
pub type E_DjiErrorFCHomeLocationModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorFCKillSwitchModuleRawCode_DJI_ERROR_FC_EMERGENCY_STOP_MOTOR_MODULE_RAW_CODE_VERSION_NOT_MATCH : E_DjiErrorFCKillSwitchModuleRawCode = 1 ;
pub const E_DjiErrorFCKillSwitchModuleRawCode_DJI_ERROR_FC_EMERGENCY_STOP_MOTOR_MODULE_RAW_CODE_CMD_INVALID : E_DjiErrorFCKillSwitchModuleRawCode = 2 ;
#[doc = " @brief Raw error code of flight controller emergency stop motor module."]
pub type E_DjiErrorFCKillSwitchModuleRawCode = ::std::os::raw::c_uint;
#[doc = "< Do not support this command"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_UNSUPPORTED_COMMAND : E_DjiErrorCameraManagerModuleRawCode = 224 ;
#[doc = "< Execution timeout"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_TIMEOUT:
    E_DjiErrorCameraManagerModuleRawCode = 225;
#[doc = "< Memory alloc failed"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_RAM_ALLOCATION_FAILED : E_DjiErrorCameraManagerModuleRawCode = 226 ;
#[doc = "< Invalid parameter for the command"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_INVALID_COMMAND_PARAMETER : E_DjiErrorCameraManagerModuleRawCode = 227 ;
#[doc = "< Do not support this command in the current state"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_UNSUPPORTED_COMMAND_IN_CUR_STATE : E_DjiErrorCameraManagerModuleRawCode = 228 ;
#[doc = "< Timestamp of camera is not synchronized"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_CAMERA_TIME_NOT_SYNCHRONIZED : E_DjiErrorCameraManagerModuleRawCode = 229 ;
#[doc = "< Setting parameter failed"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_PARAMETER_SET_FAILED : E_DjiErrorCameraManagerModuleRawCode = 230 ;
#[doc = "< Getting parameter failed"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_PARAMETER_GET_FAILED : E_DjiErrorCameraManagerModuleRawCode = 231 ;
#[doc = "< SD card is not installed"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_SD_CARD_MISSING : E_DjiErrorCameraManagerModuleRawCode = 232 ;
#[doc = "< SD card is full"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_SD_CARD_FULL : E_DjiErrorCameraManagerModuleRawCode = 233 ;
#[doc = "< Error accessing the SD Card"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_SD_CARD_ERROR : E_DjiErrorCameraManagerModuleRawCode = 234 ;
#[doc = "< Sensor go wrong"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_SENSOR_ERROR : E_DjiErrorCameraManagerModuleRawCode = 235 ;
#[doc = "< System error"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_SYSTEM_ERROR : E_DjiErrorCameraManagerModuleRawCode = 236 ;
#[doc = "< Length of the parameter is too long"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_PARAMETER_TOTAL_TOO_LONG : E_DjiErrorCameraManagerModuleRawCode = 237 ;
#[doc = "< Fireware data number is a discontinuous number"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_FIRMWARE_DATA_NUM_DISCONTINUOUS : E_DjiErrorCameraManagerModuleRawCode = 240 ;
#[doc = "< Error verifying fireware"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_FIRMWARE_VERIFICATION_ERROR : E_DjiErrorCameraManagerModuleRawCode = 242 ;
#[doc = "< Error writing flash"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_FLASH_WRITE_ERROR : E_DjiErrorCameraManagerModuleRawCode = 244 ;
#[doc = "< Firmware type don't match"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_FIRMWARE_TYPE_MISMATCH : E_DjiErrorCameraManagerModuleRawCode = 246 ;
#[doc = "< Not connect remote control yet"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_REMOTE_CONTROL_UNCONNECTED : E_DjiErrorCameraManagerModuleRawCode = 248 ;
#[doc = "< Hardware fault"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_HARDWARE_ERROR : E_DjiErrorCameraManagerModuleRawCode = 250 ;
#[doc = "< Aircraft is not connected yet"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_AIRCRAFT_UNCONNECTED : E_DjiErrorCameraManagerModuleRawCode = 252 ;
#[doc = "< Cannot upgrade in current status (Please reboot or contact with DJI support"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_CANNOT_UPGRADE_IN_CUR_STATE : E_DjiErrorCameraManagerModuleRawCode = 254 ;
#[doc = "< Undefined error"]
pub const E_DjiErrorCameraManagerModuleRawCode_DJI_ERROR_CAMERA_MANAGER_MODULE_RAW_CODE_UNDEFINE_ERROR : E_DjiErrorCameraManagerModuleRawCode = 255 ;
#[doc = " @brief Raw error code of camera manager"]
pub type E_DjiErrorCameraManagerModuleRawCode = ::std::os::raw::c_uint;
#[doc = "< Do not support this command"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_UNSUPPORTED_COMMAND : E_DjiErrorGimbalManagerModuleRawCode = 224 ;
#[doc = "< Execution timeout"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_TIMEOUT:
    E_DjiErrorGimbalManagerModuleRawCode = 225;
#[doc = "< Memory alloc failed"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_RAM_ALLOCATION_FAILED : E_DjiErrorGimbalManagerModuleRawCode = 226 ;
#[doc = "< Invalid parameter for the command"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_INVALID_COMMAND_PARAMETER : E_DjiErrorGimbalManagerModuleRawCode = 227 ;
#[doc = "< Do not support this command in the current state"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_UNSUPPORTED_COMMAND_IN_CUR_STATE : E_DjiErrorGimbalManagerModuleRawCode = 228 ;
#[doc = "< Timestamp of camera is not synchronized"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_CAMERA_TIME_NOT_SYNCHRONIZED : E_DjiErrorGimbalManagerModuleRawCode = 229 ;
#[doc = "< Setting parameter failed"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_PARAMETER_SET_FAILED : E_DjiErrorGimbalManagerModuleRawCode = 230 ;
#[doc = "< Getting parameter failed"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_PARAMETER_GET_FAILED : E_DjiErrorGimbalManagerModuleRawCode = 231 ;
#[doc = "< SD card is not installed"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_SD_CARD_MISSING : E_DjiErrorGimbalManagerModuleRawCode = 232 ;
#[doc = "< SD card is full"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_SD_CARD_FULL : E_DjiErrorGimbalManagerModuleRawCode = 233 ;
#[doc = "< Error accessing the SD Card"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_SD_CARD_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 234 ;
#[doc = "< Sensor go wrong"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_SENSOR_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 235 ;
#[doc = "< System error"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_SYSTEM_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 236 ;
#[doc = "< Length of the parameter is too long"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_PARAMETER_TOTAL_TOO_LONG : E_DjiErrorGimbalManagerModuleRawCode = 237 ;
#[doc = "< Fireware data number is a discontinuous number"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_FIRMWARE_DATA_NUM_DISCONTINUOUS : E_DjiErrorGimbalManagerModuleRawCode = 240 ;
#[doc = "< Error verifying fireware"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_FIRMWARE_VERIFICATION_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 242 ;
#[doc = "< Error writing flash"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_FLASH_WRITE_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 244 ;
#[doc = "< Firmware type don't match"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_FIRMWARE_TYPE_MISMATCH : E_DjiErrorGimbalManagerModuleRawCode = 246 ;
#[doc = "< Not connect remote control yet"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_REMOTE_CONTROL_UNCONNECTED : E_DjiErrorGimbalManagerModuleRawCode = 248 ;
#[doc = "< Hardware fault"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_HARDWARE_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 250 ;
#[doc = "< Aircraft is not connected yet"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_AIRCRAFT_UNCONNECTED : E_DjiErrorGimbalManagerModuleRawCode = 252 ;
#[doc = "< Cannot upgrade in current status (Please reboot or contact with DJI support"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_CANNOT_UPGRADE_IN_CUR_STATE : E_DjiErrorGimbalManagerModuleRawCode = 254 ;
#[doc = "< Undefined error"]
pub const E_DjiErrorGimbalManagerModuleRawCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_RAW_CODE_UNDEFINE_ERROR : E_DjiErrorGimbalManagerModuleRawCode = 255 ;
#[doc = " @brief Raw error code of gimbal manager"]
pub type E_DjiErrorGimbalManagerModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_COMMON_SUCCESS:
    E_DjiErrorWaypointV2ModuleRawCode = 0;
#[doc = "< the length of the data is illegal based on the protocol"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_COMMON_INVALID_DATA_LENGTH : E_DjiErrorWaypointV2ModuleRawCode = 1 ;
#[doc = "< invalid float number (NAN or INF)"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_COMMON_INVALD_FLOAT_NUM : E_DjiErrorWaypointV2ModuleRawCode = 2 ;
#[doc = "< waypoint mission version can't match with firmware"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_WP_VERSION_NO_MATCH : E_DjiErrorWaypointV2ModuleRawCode = 3 ;
#[doc = "< Fatal error! Unexpected result!"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_COMMON_UNKNOWN:
    E_DjiErrorWaypointV2ModuleRawCode = 65535;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_RESV:
    E_DjiErrorWaypointV2ModuleRawCode = 65536;
#[doc = "< min_initial_waypoint_num is large than permitted_max_waypoint_num"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_WP_NUM_TOO_MANY : E_DjiErrorWaypointV2ModuleRawCode = 65537 ;
#[doc = "< min_initial_waypoint_num is less than permitted_min_waypoint_num"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_WP_NUM_TOO_FEW : E_DjiErrorWaypointV2ModuleRawCode = 65538 ;
#[doc = "< waypoint_end_index is equal or large than total_waypoint_num"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INVALID_END_INDEX : E_DjiErrorWaypointV2ModuleRawCode = 65539 ;
#[doc = "< the start index is greater than end index of upload wps"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_START_ID_GT_END_ID : E_DjiErrorWaypointV2ModuleRawCode = 65540 ;
#[doc = "< the end index of uplod wps is greater than inited total numbers"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_END_ID_GT_TOTAL_NUM : E_DjiErrorWaypointV2ModuleRawCode = 65541 ;
#[doc = "< the index of first and end waypoint expected to download is not in range of stored in FC"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_DOWNLOAD_WPS_NOT_IN_STORED_RAGNE : E_DjiErrorWaypointV2ModuleRawCode = 65542 ;
#[doc = "< current position is far away from the first waypoint."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_CUR_POS_IS_FAR_AWAY_FROM_FIRST_WP : E_DjiErrorWaypointV2ModuleRawCode = 65544 ;
#[doc = "< it is too close from two adjacent waypoints, the value of which might be distinguish from products"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_ADJ_WPS_TOO_CLOSE : E_DjiErrorWaypointV2ModuleRawCode = 65546 ;
#[doc = "< the distance betwween two adjacent waypoints is not in[0.5m, 5000m] the value of which might be distinguish from products"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_ADJ_WPS_TOO_FAR : E_DjiErrorWaypointV2ModuleRawCode = 65547 ;
#[doc = "< the max vel of uplod wp is greater than global max vel"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_MAX_VEL_GT_GLOBAL : E_DjiErrorWaypointV2ModuleRawCode = 65548 ;
#[doc = "< the local cruise vel of upload wp is greater than local max vel"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_LOCAL_CRUISE_VEL_GT_LOCAL_MAX : E_DjiErrorWaypointV2ModuleRawCode = 65549 ;
#[doc = "< the local cruise vel of upload wp is greater than global max vel"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_LOCAL_CRUISE_VEL_GT_GLOBAL_MAX : E_DjiErrorWaypointV2ModuleRawCode = 65550 ;
#[doc = "< global_max_vel is greater than permitted_max_vel or less than permitted_min_vel"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INVALID_GLOBAL_MAX_VEL : E_DjiErrorWaypointV2ModuleRawCode = 65551 ;
#[doc = "< global_cruise_vel is greater than global_max_vel"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_GLOBAL_CRUISE_VEL_GT_MAX_VEL : E_DjiErrorWaypointV2ModuleRawCode = 65552 ;
#[doc = "< goto_first_point_mode is out of range of waypoint_goto_first_flag_t_enum"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INVALID_GOTO_FIRST_FLAG : E_DjiErrorWaypointV2ModuleRawCode = 65553 ;
#[doc = "< finished_action is out of range of wp_plan_finish_action_t_enum"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INVALID_FINISHED_ACTION : E_DjiErrorWaypointV2ModuleRawCode = 65554 ;
#[doc = "< rc_lost_action is out of range of wp_plan_rc_lost_action_t_enum"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INVALID_RC_LOST_ACTION : E_DjiErrorWaypointV2ModuleRawCode = 65555 ;
#[doc = "< the yaw mode of upload wp is invalid. reference to waypoint2_yaw_mode_t defined in math_waypoint_planner.h"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_YAW_MODE_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 65556 ;
#[doc = "< the yaw command of upload wp is not in range. the range for MR:[-180 180],unit:degree"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_YAW_CMD_NOT_IN_RANGE : E_DjiErrorWaypointV2ModuleRawCode = 65557 ;
#[doc = "< the yaw turn direction of upload wp is invalid. it should be 0:clockwise or 1:anti-clockwise"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_YAW_TURN_DIRECTION_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 65558 ;
#[doc = "< the wp type of upload wp is invalid. reference to waypoint_type_t defined in math_waypoint_planner.h"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_WP_TYPE_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 65559 ;
#[doc = "< go/stop command is invalid."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_GO_STOP_CMD_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 65560 ;
#[doc = "< the command of pause/recovery is not equal to any of the command enum"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INVALID_PAUSE_RECOVERY_CMD : E_DjiErrorWaypointV2ModuleRawCode = 65561 ;
#[doc = "< the command of break/restore is not equal to any of the command enum"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INVALID_BREAK_RESTORE_CMD : E_DjiErrorWaypointV2ModuleRawCode = 65562 ;
#[doc = "< initial reference point position coordinate exceed set range"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INVALID_REF_POINT : E_DjiErrorWaypointV2ModuleRawCode = 65563 ;
#[doc = "< the damping dis is greater than or equal the distance of adjacent point"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_DAMPING_DIS_GE_DIS_OF_ADJ_POINTS : E_DjiErrorWaypointV2ModuleRawCode = 65564 ;
#[doc = "< cann't set wp_line_exit type to wp"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_CANNT_SET_WP_LINE_EXIT_TYPE : E_DjiErrorWaypointV2ModuleRawCode = 65565 ;
#[doc = "< the init info of Ground Station is not uploaded yet"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_INFO_NOT_UPLOADED : E_DjiErrorWaypointV2ModuleRawCode = 65566 ;
#[doc = "< the wp has not uploaded yet"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_WP_HAS_NOT_UPLOADED : E_DjiErrorWaypointV2ModuleRawCode = 65567 ;
#[doc = "< min_initial_waypoint_num is not uploaded."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOADED_WP_NOT_ENOUGH : E_DjiErrorWaypointV2ModuleRawCode = 65568 ;
#[doc = "< waypoint plan has started when received go command."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_GS_HAS_STARTED : E_DjiErrorWaypointV2ModuleRawCode = 65569 ;
#[doc = "< waypoint plan not running when received stop command."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_GS_NOT_RUNNING : E_DjiErrorWaypointV2ModuleRawCode = 65570 ;
#[doc = "< ground station(GS) is not started(used by pause/recovery)"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_GS_NOT_RUNNING_FOR_PAUSE_RECOVERY : E_DjiErrorWaypointV2ModuleRawCode = 65571 ;
#[doc = "< ground station(GS) is not started(used by break/restore)"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_GS_NOT_RUNNING_FOR_BREAK_RESTORE : E_DjiErrorWaypointV2ModuleRawCode = 65572 ;
#[doc = "< not in the waypoint mission(MIS)(cannot pause/recovery or break/restore)"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_NOT_IN_WP_MIS : E_DjiErrorWaypointV2ModuleRawCode = 65573 ;
#[doc = "< the current status is paused, cannot command pause again"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_MIS_HAS_BEEN_PAUSED : E_DjiErrorWaypointV2ModuleRawCode = 65574 ;
#[doc = "< not in paused status, cannot command recovery"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_MIS_NOT_PAUSED : E_DjiErrorWaypointV2ModuleRawCode = 65575 ;
#[doc = "< the current status is broken, cannot command break again"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_MIS_HAS_BEEN_BROKEN : E_DjiErrorWaypointV2ModuleRawCode = 65576 ;
#[doc = "< not in break status, cannot command restore"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_MIS_NOT_BROKEN : E_DjiErrorWaypointV2ModuleRawCode = 65577 ;
#[doc = "< the configuration forbid using pause/recovery API"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_PAUSE_RECOVERY_NOT_SUPPORTED : E_DjiErrorWaypointV2ModuleRawCode = 65578 ;
#[doc = "< the configuration forbid using break/restore API"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_BREAK_RESTORE_NOT_SUPPORTED : E_DjiErrorWaypointV2ModuleRawCode = 65579 ;
#[doc = "< no break point is recorded for restore"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_NO_BREAK_POINT : E_DjiErrorWaypointV2ModuleRawCode = 65580 ;
#[doc = "< no current trajectory project point is recorded for restore"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_NO_CUR_TRAJ_PROJECT : E_DjiErrorWaypointV2ModuleRawCode = 65581 ;
#[doc = "< no next trajectory project point is recorded for restore"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_NO_NXT_TRAJ_PROJECT : E_DjiErrorWaypointV2ModuleRawCode = 65582 ;
#[doc = "< no next the next trajectory project point is recorded for restore"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_NO_NNT_TRAJ_PROJECT : E_DjiErrorWaypointV2ModuleRawCode = 65583 ;
#[doc = "< the index of upload wp is not continue after the store wp"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOAD_WP_ID_NOT_CONTINUE : E_DjiErrorWaypointV2ModuleRawCode = 65584 ;
#[doc = "< the WP_LINE_ENTER wp_type set to a wp which is not the init start waypoint"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_WP_LINE_ENTER_NOT_SET_TO_START_WP : E_DjiErrorWaypointV2ModuleRawCode = 65585 ;
#[doc = "< the waypoint plan has started when initializing waypoint"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_INIT_WP_WHEN_PLAN_HAS_STARTED : E_DjiErrorWaypointV2ModuleRawCode = 65586 ;
#[doc = "< waypoint damping distance exceed set range"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_DAMPING_DIS_EXCEED_RANGE : E_DjiErrorWaypointV2ModuleRawCode = 65587 ;
#[doc = "< waypoint position coordinate exceed rational range"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_WAYPOINT_COOR_EXCEED_RANGE : E_DjiErrorWaypointV2ModuleRawCode = 65588 ;
#[doc = "< first waypoint type error, it can not be WP_TURN_NO"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_FIRST_WP_TYPE_IS_WP_TURN_NO : E_DjiErrorWaypointV2ModuleRawCode = 65589 ;
#[doc = "< waypoint position exceed radius limit"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_WP_EXCEED_RADIUS_LIMIT : E_DjiErrorWaypointV2ModuleRawCode = 65592 ;
#[doc = "< waypoint position exceed height limit"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_WP_EXCEED_HEIGHT_LIMIT : E_DjiErrorWaypointV2ModuleRawCode = 65593 ;
#[doc = "< the uploaded waypoint exceed height limit"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRAJ_UPLOADED_WP_EXCEED_HEIGHT_LIMIT : E_DjiErrorWaypointV2ModuleRawCode = 65600 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_STATUS_RESV:
    E_DjiErrorWaypointV2ModuleRawCode = 131072;
#[doc = "< head_node is null or atti_not_healthy or gyro_not_healthy or horiz_vel_not healthy or horiz_abs_pos_not_healthy."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_STATUS_WP_MIS_CHECK_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 131073 ;
#[doc = "< the home point is no recorded yet, which will be executed at the first time of GPS level > 3(MR/FW)."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_STATUS_HOME_NOT_RECORDED : E_DjiErrorWaypointV2ModuleRawCode = 131074 ;
#[doc = "< current location accuracy is low for bad GPS signal."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_STATUS_LOW_LOCATION_ACCURACY : E_DjiErrorWaypointV2ModuleRawCode = 131075 ;
#[doc = "< use rtk_data, but rtk is not connected or rtk_data is invalid"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_STATUS_RTK_CONDITION_IS_NOT_READY : E_DjiErrorWaypointV2ModuleRawCode = 131077 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_SECURE_RESV:
    E_DjiErrorWaypointV2ModuleRawCode = 196608;
#[doc = "< the trajectory cross the NFZ"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_SECURE_CROSS_NFZ : E_DjiErrorWaypointV2ModuleRawCode = 196609 ;
#[doc = "< current capacity of smart battery or voltage of non-smart battery is lower than level 1 or level 2 threshold"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_SECURE_BAT_LOW:
    E_DjiErrorWaypointV2ModuleRawCode = 196610;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_RESV : E_DjiErrorWaypointV2ModuleRawCode = 4194304 ;
#[doc = "< the ID of Action is duplicated."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_ACTION_ID_DUPLICATED : E_DjiErrorWaypointV2ModuleRawCode = 4194305 ;
#[doc = "< there is no enough memory space for new Action Item"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_ACTION_ITEMS_SPACE_NOT_ENOUGH : E_DjiErrorWaypointV2ModuleRawCode = 4194306 ;
#[doc = "< the size of buffer used to get the info of Action is less than the size of Action. Normally users can not get this."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_ACTION_SIZE_GT_BUF_SIZE : E_DjiErrorWaypointV2ModuleRawCode = 4194307 ;
#[doc = "< the ID of Action is not found."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_ACTION_ID_NOT_FOUND : E_DjiErrorWaypointV2ModuleRawCode = 4194308 ;
#[doc = "< the download action start id is bigger than the action end id"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_DOWNLOAD_ACTION_ID_RANGE_ERROR : E_DjiErrorWaypointV2ModuleRawCode = 4194309 ;
#[doc = "< can not download or get min-max action ID for no action items stored in action kernel"]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTION_COMMON_NO_ACTION_ITEMS_STORED : E_DjiErrorWaypointV2ModuleRawCode = 4194310 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_RESV:
    E_DjiErrorWaypointV2ModuleRawCode = 4259840;
#[doc = "< the type ID of Trigger is invalid. It might not defined or the information is empty."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_TYPE_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 4259841 ;
#[doc = "< wp_end_index is less than wp_start_index in reach_waypoint_trigger."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_REACH_WP_END_INDEX_LT_START_INDEX : E_DjiErrorWaypointV2ModuleRawCode = 4259873 ;
#[doc = "< interval_wp_num is large than the difference of wp_start_index and wp_end_index in reach_waypoint_trigger."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_REACH_WP_INVALID_INTERVAL_WP_NUM : E_DjiErrorWaypointV2ModuleRawCode = 4259874 ;
#[doc = "< auto_terminate_wp_num is large than interval_wp_num in reach_waypoint_trigger."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_REACH_WP_INVALID_AUTO_TERMINATE_WP_NUM : E_DjiErrorWaypointV2ModuleRawCode = 4259875 ;
#[doc = "< the associate_type is greater than the maximum value."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_ASSOCIATE_INVALID_TYPE : E_DjiErrorWaypointV2ModuleRawCode = 4259905 ;
#[doc = "< the interval type is greater than the maximum value."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_TRIGGER_SIMPLE_INTERVAL_INVALID_TYPE : E_DjiErrorWaypointV2ModuleRawCode = 4259969 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_COMMON_RESV : E_DjiErrorWaypointV2ModuleRawCode = 4325376 ;
#[doc = "< the execution of Actuator is not supported, e.g., try to stop camera shooting."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_COMMON_ACTUATOR_EXEC_NON_SUPPORTED : E_DjiErrorWaypointV2ModuleRawCode = 4325377 ;
#[doc = "< the type ID of Actuator is invalid. It might not defined or the information is empty."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_COMMON_ACTUATOR_TYPE_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 4325378 ;
#[doc = "< the Function ID of Actuator is invalid. It might not defined or the information is empty."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_COMMON_ACTUATOR_FUNC_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 4325379 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_RESV : E_DjiErrorWaypointV2ModuleRawCode = 4390912 ;
#[doc = "< fail to send shot cmd to camera for no camera or camera is busy."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_SEND_SINGLE_SHOT_CMD_TO_CAMERA_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 4390913 ;
#[doc = "< fail to send video start cmd to camera for no camera or camera is busy."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_SEND_VIDEO_START_CMD_TO_CAMERA_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 4390914 ;
#[doc = "< fail to send video stop cmd to camera for no camera or camera is not busy."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_SEND_VIDEO_STOP_CMD_TO_CAMERA_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 4390915 ;
#[doc = "< camera focus param xy exceed valid range (0, 1)."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_FOCUS_PARAM_XY_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 4390916 ;
#[doc = "< fail to send focus cmd to camera for no camera or camera is busy."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_SEND_FOCUS_CMD_TO_CAMERA_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 4390917 ;
#[doc = "< fail to send focalize cmd to camera for no camera or camera is busy."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_SEND_FOCALIZE_CMD_TO_CAMERA_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 4390918 ;
#[doc = "< focal distance of camera focalize function exceed valid range."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_FOCAL_DISTANCE_INVALID : E_DjiErrorWaypointV2ModuleRawCode = 4390919 ;
#[doc = "< this err code indicate camera fail to exec coressponding cmd, and the low 8 bit\nwill be replaced by the return code from camera, for example: 0x01E0 means current cmd\nis not supported, 0x01E8 means SD card is not inserted and so on, the detailed camera\nreturn code could be found in camera protocal."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_CAMERA_EXEC_FAIL : E_DjiErrorWaypointV2ModuleRawCode = 4391168 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_GIMBAL_RESV : E_DjiErrorWaypointV2ModuleRawCode = 4456448 ;
#[doc = "< gimbal roll/pitch/yaw angle ctrl cmd param invalid, unable to exec."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_GIMBAL_INVALID_RPY_ANGLE_CTRL_CMD : E_DjiErrorWaypointV2ModuleRawCode = 4456449 ;
#[doc = "< gimbal duration param invalid, unable to exec."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_GIMBAL_INVALID_DURATION_CMD : E_DjiErrorWaypointV2ModuleRawCode = 4456450 ;
#[doc = "< gimbal fail to arrive target angle ."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_GIMBAL_FAIL_TO_ARRIVE_TGT_ANGLE : E_DjiErrorWaypointV2ModuleRawCode = 4456451 ;
#[doc = "< fail to send cmd to gimbal for gimbal is busy or no gimbal."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_GIMBAL_FAIL_TO_SEND_CMD_TO_GIMBAL : E_DjiErrorWaypointV2ModuleRawCode = 4456452 ;
#[doc = "< fail to stop gimbal uniform ctrl because index error."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_GIMBAL_THIS_INDEX_OF_GIMBAL_NOT_DOING_UNIFORM_CTRL : E_DjiErrorWaypointV2ModuleRawCode = 4456453 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_FLIGHT_RESV : E_DjiErrorWaypointV2ModuleRawCode = 4587520 ;
#[doc = "< yaw angle is lager max yaw angle."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_FLIGHT_YAW_INVALID_YAW_ANGLE : E_DjiErrorWaypointV2ModuleRawCode = 4587521 ;
#[doc = "< faile to target yaw angle, because of timeout."]
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_FLIGHT_YAW_TO_TGT_ANGLE_TIMEOUT : E_DjiErrorWaypointV2ModuleRawCode = 4587522 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_FLIGHT_ACTION_YAW_OCCUPIED : E_DjiErrorWaypointV2ModuleRawCode = 4587523 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_FLIGHT_CUR_AND_TGT_VEL_CLE_STATUE_EQUAL : E_DjiErrorWaypointV2ModuleRawCode = 4587524 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_PAYLOAD_RESV : E_DjiErrorWaypointV2ModuleRawCode = 4653056 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_PAYLOAD_FAIL_TO_SEND_CMD_TO_PAYLOAD : E_DjiErrorWaypointV2ModuleRawCode = 4653057 ;
pub const E_DjiErrorWaypointV2ModuleRawCode_DJI_ERROR_WAYPOINT_V2_MODULE_RAW_CODE_ACTUATOR_PAYLOAD_EXEC_FAILED : E_DjiErrorWaypointV2ModuleRawCode = 4653058 ;
#[doc = " @brief Waypoint v2 total error raw code."]
pub type E_DjiErrorWaypointV2ModuleRawCode = ::std::os::raw::c_uint;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_SUCCESS:
    E_DjiErrorWaypoint3ModuleRawCode = 0;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_MISSION_ID_NOT_EXIST : E_DjiErrorWaypoint3ModuleRawCode = 1 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_WAYLINE_INFO_ERROR : E_DjiErrorWaypoint3ModuleRawCode = 2 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_WPMZ_FILE_VERSION_NOT_MATCH : E_DjiErrorWaypoint3ModuleRawCode = 3 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_WPMZ_FILE_LOAD_ERROR : E_DjiErrorWaypoint3ModuleRawCode = 4 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_NO_BREAK_INFO:
    E_DjiErrorWaypoint3ModuleRawCode = 5;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CMD_INVALID:
    E_DjiErrorWaypoint3ModuleRawCode = 6;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_START_WAYLINE_WHEN_WAYLINE_RUNNING : E_DjiErrorWaypoint3ModuleRawCode = 257 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_BREAK_WAYLINE_IN_CUR_STATE : E_DjiErrorWaypoint3ModuleRawCode = 258 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_STOP_WAYLINE_WHEN_WAYLINE_NOT_RUNNING : E_DjiErrorWaypoint3ModuleRawCode = 259 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_BREAK_WAYLINE_WHEN_WAYLINE_NOT_RUNNING : E_DjiErrorWaypoint3ModuleRawCode = 260 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_REQUEST_DRONE_CONTROL : E_DjiErrorWaypoint3ModuleRawCode = 261 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_RESUME_WAYLINE_IN_CUR_STATE : E_DjiErrorWaypoint3ModuleRawCode = 262 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_HEIGHT_LIMIT:
    E_DjiErrorWaypoint3ModuleRawCode = 513;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RADIUS_LIMIT:
    E_DjiErrorWaypoint3ModuleRawCode = 514;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CROSS_FLYLIMIT_AERA : E_DjiErrorWaypoint3ModuleRawCode = 515 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_LOW_LIMIT:
    E_DjiErrorWaypoint3ModuleRawCode = 516;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_OBSTACAL_STOP:
    E_DjiErrorWaypoint3ModuleRawCode = 517;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RTK_DISCONNECT:
    E_DjiErrorWaypoint3ModuleRawCode = 518;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_BOUNDARY_LIMIT:
    E_DjiErrorWaypoint3ModuleRawCode = 519;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RC_PITCH_ROLL_BREAK : E_DjiErrorWaypoint3ModuleRawCode = 520 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_AIRPORT_HEIGHT_LIMIT : E_DjiErrorWaypoint3ModuleRawCode = 521 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_REQUEST_TAKEOFF_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 522 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_AUTOTAKEOFF_RUN_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 523 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_REQUEST_WAYLINE_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 524 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_AGRO_PLAN_FAIL:
    E_DjiErrorWaypoint3ModuleRawCode = 525;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_REQUEST_QUICK_TAKEOFF_ASSIST_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 526 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_QUICK_TAKEOFF_ASSIST_RUN_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 527 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_VFENCE_LIMIT:
    E_DjiErrorWaypoint3ModuleRawCode = 528;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_GPS_INVALID:
    E_DjiErrorWaypoint3ModuleRawCode = 769;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_START_AT_CURRENT_RC_MODE : E_DjiErrorWaypoint3ModuleRawCode = 770 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_HOME_POINT_NOT_RECORDED : E_DjiErrorWaypoint3ModuleRawCode = 771 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_LOWER_BATTERY:
    E_DjiErrorWaypoint3ModuleRawCode = 772;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RETURN_HOME:
    E_DjiErrorWaypoint3ModuleRawCode = 773;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ADSB_ERROR:
    E_DjiErrorWaypoint3ModuleRawCode = 774;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RC_LOST:
    E_DjiErrorWaypoint3ModuleRawCode = 775;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RTK_NOT_READY:
    E_DjiErrorWaypoint3ModuleRawCode = 776;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_DRONE_IS_MOVING:
    E_DjiErrorWaypoint3ModuleRawCode = 777;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_DRONE_ON_GROUND_MOTOR_ON : E_DjiErrorWaypoint3ModuleRawCode = 778 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_SURFACE_FOLLOW_CAMERA_INVALID : E_DjiErrorWaypoint3ModuleRawCode = 779 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_SURFACE_FOLLOW_HEIGHT_INVALID : E_DjiErrorWaypoint3ModuleRawCode = 780 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_SURFACE_FOLLOW_MAP_WRONG : E_DjiErrorWaypoint3ModuleRawCode = 781 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_HOMEPOINT_NOT_MATCH_RTK : E_DjiErrorWaypoint3ModuleRawCode = 782 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_STRONG_WIND_GOHOME : E_DjiErrorWaypoint3ModuleRawCode = 784 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_DRONE_CRITICAL_ERROR : E_DjiErrorWaypoint3ModuleRawCode = 1023 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_CANNOT_FIND_PAYLOAD : E_DjiErrorWaypoint3ModuleRawCode = 1025 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_EXECUTION_FAILED : E_DjiErrorWaypoint3ModuleRawCode = 1026 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_FARM_NO_PESTICIDE : E_DjiErrorWaypoint3ModuleRawCode = 1027 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_RADAR_DISCONNECT : E_DjiErrorWaypoint3ModuleRawCode = 1028 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_USER_EXIT:
    E_DjiErrorWaypoint3ModuleRawCode = 1281;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_USER_BREAK:
    E_DjiErrorWaypoint3ModuleRawCode = 1282;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_USER_SET_GOHOME:
    E_DjiErrorWaypoint3ModuleRawCode = 1283;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_USER_AGRO_PLANNER_STATE_CHANGE : E_DjiErrorWaypoint3ModuleRawCode = 1284 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_USER_SWITCH_RC_MODE : E_DjiErrorWaypoint3ModuleRawCode = 1285 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INIT_FAIL:
    E_DjiErrorWaypoint3ModuleRawCode = 1536;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_JOB_EXIT_BUT_MIS_RUNNING : E_DjiErrorWaypoint3ModuleRawCode = 1537 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_ON_GROUND_MOTOR_ON_CANNOT_GO : E_DjiErrorWaypoint3ModuleRawCode = 1538 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_START_INDEX_OR_PROG : E_DjiErrorWaypoint3ModuleRawCode = 1539 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_CSYS_MODE : E_DjiErrorWaypoint3ModuleRawCode = 1540 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_HEIGHT_MODE : E_DjiErrorWaypoint3ModuleRawCode = 1541 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_FLY_WP_MODE : E_DjiErrorWaypoint3ModuleRawCode = 1542 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_YAW_MODE : E_DjiErrorWaypoint3ModuleRawCode = 1543 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_TURN_DIR_MODE : E_DjiErrorWaypoint3ModuleRawCode = 1544 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_WP_TYPE : E_DjiErrorWaypoint3ModuleRawCode = 1545 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_FIR_LAS_WP_TYPE_ERROR : E_DjiErrorWaypoint3ModuleRawCode = 1546 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_GLOB_VEL_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1547 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_WP_NUM_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1548 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_LAT_LONG_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1549 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_DAMP_DIS_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1550 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_MAX_VEL_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1551 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_VEL_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1552 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_WP_YAW_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1553 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_YAW_MODE_IN_VERT_SEGM : E_DjiErrorWaypoint3ModuleRawCode = 1554 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_WP_BREAK_INFO_MISSION_ID_CHANGED : E_DjiErrorWaypoint3ModuleRawCode = 1555 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_WP_BREAK_INFO_PROGRESS_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1556 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_WP_BREAK_INFO_INVALID_MISSION_STATE : E_DjiErrorWaypoint3ModuleRawCode = 1557 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_WP_BREAK_INFO_WP_INDEX_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1558 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_BREAK_LAT_LONG_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1559 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_BREAK_INFO_WP_YAW_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1560 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_INVALID_BREAK_INFO_FLAG : E_DjiErrorWaypoint3ModuleRawCode = 1561 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_GET_TRAJ_INFO_FAILED : E_DjiErrorWaypoint3ModuleRawCode = 1562 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_GENERATE_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 1563 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_LIB_RUN_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 1564 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRAJ_LIB_EMERGENCY_BRAKE : E_DjiErrorWaypoint3ModuleRawCode = 1565 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_NOT_FOUND : E_DjiErrorWaypoint3ModuleRawCode = 1588 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_INDEX_REPEATED : E_DjiErrorWaypoint3ModuleRawCode = 1591 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_INFO_SIZE_TOO_LONG_OR_TOO_SHORT : E_DjiErrorWaypoint3ModuleRawCode = 1592 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_TREE_EMPTY : E_DjiErrorWaypoint3ModuleRawCode = 1593 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_TREE_LAYER_EMPTY : E_DjiErrorWaypoint3ModuleRawCode = 1594 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_ID_REPEATED : E_DjiErrorWaypoint3ModuleRawCode = 1595 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_NODE_CHILDREN_NUM_LT_2 : E_DjiErrorWaypoint3ModuleRawCode = 1596 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_INDEX_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1597 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_ID_IS_65535 : E_DjiErrorWaypoint3ModuleRawCode = 1598 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_NODE_CHILDNUM_SUM_NOT_EQ_NEXT_LAYER_SIZE : E_DjiErrorWaypoint3ModuleRawCode = 1599 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_TREE_LAYER_NUM_TOO_MORE : E_DjiErrorWaypoint3ModuleRawCode = 1600 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_TREE_LAYER_NUM_TOO_LESS : E_DjiErrorWaypoint3ModuleRawCode = 1601 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_GROUP_NUM_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1602 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_GROUP_VALID_RANGE_ERROR : E_DjiErrorWaypoint3ModuleRawCode = 1603 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_TREE_ROOT_STATUS_INVALID : E_DjiErrorWaypoint3ModuleRawCode = 1604 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_TREE_NODE_STATUS_INVALID : E_DjiErrorWaypoint3ModuleRawCode = 1605 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_BREAK_INFO_ACTION_GROUP_ID_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1606 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_STATUS_TREE_SIZE_ERROR : E_DjiErrorWaypoint3ModuleRawCode = 1607 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_BREAK_INFO_TRIGGER_RUN_RESULT_INVALID : E_DjiErrorWaypoint3ModuleRawCode = 1608 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_BREAK_INFO_ACTION_GROUP_ID_REPEATED : E_DjiErrorWaypoint3ModuleRawCode = 1609 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_BREAK_INFO_ACTION_LOCATION_REPEATED : E_DjiErrorWaypoint3ModuleRawCode = 1610 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_BREAK_INFO_ACTION_LOCATION_OUT_OF_RANGE : E_DjiErrorWaypoint3ModuleRawCode = 1611 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_RESUME_ID_NOT_IN_BREAK_INFO : E_DjiErrorWaypoint3ModuleRawCode = 1612 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_RESUME_INFO_MODIFY_ACTION_STATUS_FROM_NO_INTERRUPT_TO_INTERRUPT : E_DjiErrorWaypoint3ModuleRawCode = 1613 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTION_COMMON_ACTION_RESUME_FAIL_FOR_INVALID_RESUME_INFO : E_DjiErrorWaypoint3ModuleRawCode = 1614 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_ACTUATOR_COMMON_ACTUATOR_NOT_FOUND : E_DjiErrorWaypoint3ModuleRawCode = 1634 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRIGGER_NOT_FOUND : E_DjiErrorWaypoint3ModuleRawCode = 1649 ;
pub const E_DjiErrorWaypoint3ModuleRawCode_DJI_ERROR_WAYPOINT_V3_MODULE_RAW_CODE_TRIGGER_SINGLE_TIME_CHECK_FAIL : E_DjiErrorWaypoint3ModuleRawCode = 1650 ;
pub type E_DjiErrorWaypoint3ModuleRawCode = ::std::os::raw::c_uint;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_SUCCESS: DjiErrorCode = 0;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_INVALID_REQUEST_PARAMETER: DjiErrorCode = 212;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_EXECUTING_HIGHER_PRIORITY_TASK: DjiErrorCode =
    215;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_NONSUPPORT: DjiErrorCode = 224;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_TIMEOUT: DjiErrorCode = 225;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_MEMORY_ALLOC_FAILED: DjiErrorCode = 226;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_INVALID_PARAMETER: DjiErrorCode = 227;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_NONSUPPORT_IN_CURRENT_STATE: DjiErrorCode = 228;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_SYSTEM_ERROR: DjiErrorCode = 236;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_HARDWARE_ERR: DjiErrorCode = 250;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_INSUFFICIENT_ELECTRICITY: DjiErrorCode = 251;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_UNKNOWN: DjiErrorCode = 255;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_NOT_FOUND: DjiErrorCode = 256;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_OUT_OF_RANGE: DjiErrorCode = 257;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_BUSY: DjiErrorCode = 258;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_DUPLICATE: DjiErrorCode = 259;
pub const DjiErrorCode_DJI_ERROR_SYSTEM_MODULE_CODE_ADAPTER_NOT_MATCH: DjiErrorCode = 260;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_PITCH_REACH_POSITIVE_LIMIT: DjiErrorCode =
    25769803776;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_PITCH_REACH_NEGATIVE_LIMIT: DjiErrorCode =
    25769803777;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_ROLL_REACH_POSITIVE_LIMIT: DjiErrorCode =
    25769803778;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_ROLL_REACH_NEGATIVE_LIMIT: DjiErrorCode =
    25769803779;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_YAW_REACH_POSITIVE_LIMIT: DjiErrorCode =
    25769803780;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_YAW_REACH_NEGATIVE_LIMIT: DjiErrorCode =
    25769803781;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MODULE_CODE_NON_CONTROL_AUTHORITY: DjiErrorCode =
    25769803782;
pub const DjiErrorCode_DJI_ERROR_PAYLOAD_COLLABORATION_MODULE_CODE_POSITION_NOT_MATCH:
    DjiErrorCode = 34359738368;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_PARAMETER_ERROR: DjiErrorCode =
    47244640257;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_ENCODE_ERROR: DjiErrorCode =
    47244640258;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_NEW_DEVICE_ERROR: DjiErrorCode =
    47244640259;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_SOFTWARE_NOT_CONNECTED:
    DjiErrorCode = 47244640260;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_NETWORK_ERROR: DjiErrorCode =
    47244640261;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_SERVER_ACCESS_REFUSED: DjiErrorCode =
    47244640262;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_ACCESS_LEVEL_ERROR: DjiErrorCode =
    47244640263;
pub const DjiErrorCode_DJI_ERROR_IDENTITY_MODULE_CODE_ACTIVATE_OSDK_VERSION_ERROR: DjiErrorCode =
    47244640264;
pub const DjiErrorCode_DJI_ERROR_SUBSCRIPTION_MODULE_CODE_INVALID_TOPIC_FREQ: DjiErrorCode =
    60129542144;
pub const DjiErrorCode_DJI_ERROR_SUBSCRIPTION_MODULE_CODE_TOPIC_DUPLICATE: DjiErrorCode =
    60129542145;
pub const DjiErrorCode_DJI_ERROR_SUBSCRIPTION_MODULE_CODE_TOPIC_NOT_SUBSCRIBED: DjiErrorCode =
    60129542146;
pub const DjiErrorCode_DJI_ERROR_SUBSCRIPTION_MODULE_CODE_TIMESTAMP_NOT_ENABLE: DjiErrorCode =
    60129542147;
pub const DjiErrorCode_DJI_ERROR_SUBSCRIPTION_MODULE_CODE_TOPIC_NOT_SUPPORTED: DjiErrorCode =
    60129542148;
pub const DjiErrorCode_DJI_ERROR_MOP_CHANNEL_MODULE_CODE_CONNECTION_CLOSE: DjiErrorCode =
    64424509451;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_RC_MODE_ERROR: DjiErrorCode = 115964116992;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_RELEASE_CONTROL_SUCCESS: DjiErrorCode =
    115964116993;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_OBTAIN_CONTROL_SUCCESS: DjiErrorCode = 115964116994;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_OBTAIN_CONTROL_IN_PROGRESS: DjiErrorCode =
    115964116995;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_RELEASE_CONTROL_IN_PROGRESS: DjiErrorCode =
    115964116996;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_RC_NEED_MODE_P: DjiErrorCode = 115964116997;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_RC_NEED_MODE_F: DjiErrorCode = 115964116998;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_PARAM_READ_WRITE_INVALID_PARAM: DjiErrorCode =
    115964116999;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_IOC_OBTAIN_CONTROL_ERROR: DjiErrorCode =
    115964117193;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_KEY_ERROR: DjiErrorCode = 115964182272;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_NO_AUTHORIZATION_ERROR: DjiErrorCode = 115964182273;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_NO_RIGHTS_ERROR: DjiErrorCode = 115964182274;
pub const DjiErrorCode_DJI_ERROR_FC_MODULE_CODE_SYSTEM_ERROR: DjiErrorCode = 115964182275;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_OBTAIN_RELEASE_JOYSTICK_AUTH_SUCCESS:
    DjiErrorCode = 120259084288;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_DEVICE_NOT_ALLOW: DjiErrorCode = 120259084289;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_TAKING_OFF: DjiErrorCode = 120259084291;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_LANDING: DjiErrorCode = 120259084292;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_CMD_INVALID: DjiErrorCode = 120259084293;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_RC_NOT_P_MODE: DjiErrorCode = 120259084294;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_CMD_LENGTH_ERROR: DjiErrorCode = 120259084295;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_HAS_NO_JOYSTICK_AUTHORITY: DjiErrorCode =
    120259084296;
pub const DjiErrorCode_DJI_ERROR_FC_JOYSTICK_MODULE_IN_RC_LOST_ACTION: DjiErrorCode = 120259084297;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_MOTOR_ON: DjiErrorCode =
    124554051585;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_MOTOR_OFF: DjiErrorCode =
    124554051586;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_IN_AIR: DjiErrorCode = 124554051587;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_NOT_IN_AIR: DjiErrorCode =
    124554051588;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_HOME_POINT_NOT_SET: DjiErrorCode =
    124554051589;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_BAD_GPS: DjiErrorCode =
    124554051590;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_IN_SIMULATION: DjiErrorCode =
    124554051591;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_CANNOT_START_MOTOR: DjiErrorCode =
    124554051601;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_LOW_VOLTAGE: DjiErrorCode =
    124554051602;
pub const DjiErrorCode_DJI_ERROR_FC_ACTION_MODULE_TRIGGER_ERROR_SPEED_TOO_LARGE: DjiErrorCode =
    124554051604;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_REGISTER_LOGOUT_SET_SUCCESS: DjiErrorCode =
    128849018880;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_REGISTER_LOGOUT_NULL_POINTER:
    DjiErrorCode = 128849018881;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_HMS_CODE_HAS_REGISTED: DjiErrorCode =
    128849018882;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_HMS_CODE_NOT_FIND: DjiErrorCode =
    128849018883;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_ADD_ITEM_NO_DECRIPTION: DjiErrorCode =
    128849018884;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_REGISTER_ID_INVALID: DjiErrorCode =
    128849018885;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_STOP_IN_AIR_HMSCODE_NOT_IN_WHITE_TABLE:
    DjiErrorCode = 128849018886;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_INVALID_FORMAT_HMSCODE: DjiErrorCode =
    128849018887;
pub const DjiErrorCode_DJI_ERROR_FC_ARREST_FLYING_MODULE_HMSCODE_NOT_IN_WHITE_TABLE: DjiErrorCode =
    128849018888;
pub const DjiErrorCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_UNKNOWN_FAILED_REASON: DjiErrorCode =
    133143986177;
pub const DjiErrorCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_INVALID_GPS_COORDINATE: DjiErrorCode =
    133143986178;
pub const DjiErrorCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_NOT_BE_RECORD: DjiErrorCode = 133143986179;
pub const DjiErrorCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_GPS_NOT_READY: DjiErrorCode = 133143986180;
pub const DjiErrorCode_DJI_ERROR_FC_HOME_LOCATION_MODULE_DIS_TOO_FAR: DjiErrorCode = 133143986181;
pub const DjiErrorCode_DJI_ERROR_FC_EMERGENCY_STOP_MOTOR_MODULE_VERSION_NOT_MATCH: DjiErrorCode =
    137438953473;
pub const DjiErrorCode_DJI_ERROR_FC_EMERGENCY_STOP_MOTOR_MODULE_CMD_INVALID: DjiErrorCode =
    137438953474;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_UNSUPPORTED_COMMAND: DjiErrorCode =
    141733920992;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_TIMEOUT: DjiErrorCode = 141733920993;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_RAM_ALLOCATION_FAILED: DjiErrorCode =
    141733920994;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_INVALID_COMMAND_PARAMETER:
    DjiErrorCode = 141733920995;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_UNSUPPORTED_COMMAND_IN_CUR_STATE:
    DjiErrorCode = 141733920996;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_CAMERA_TIME_NOT_SYNCHRONIZED:
    DjiErrorCode = 141733920997;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_PARAMETER_SET_FAILED: DjiErrorCode =
    141733920998;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_PARAMETER_GET_FAILED: DjiErrorCode =
    141733920999;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_SD_CARD_MISSING: DjiErrorCode =
    141733921000;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_SD_CARD_FULL: DjiErrorCode =
    141733921001;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_SD_CARD_ERROR: DjiErrorCode =
    141733921002;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_SENSOR_ERROR: DjiErrorCode =
    141733921003;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_SYSTEM_ERROR: DjiErrorCode =
    141733921004;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_PARAMETER_TOTAL_TOO_LONG: DjiErrorCode =
    141733921005;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_MODULE_INACTIVATED: DjiErrorCode =
    141733921006;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_FIRMWARE_DATA_NUM_DISCONTINUOUS:
    DjiErrorCode = 141733921008;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_FIRMWARE_VERIFICATION_ERROR:
    DjiErrorCode = 141733921010;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_FLASH_WRITE_ERROR: DjiErrorCode =
    141733921012;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_FIRMWARE_TYPE_MISMATCH: DjiErrorCode =
    141733921014;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_REMOTE_CONTROL_UNCONNECTED:
    DjiErrorCode = 141733921016;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_HARDWARE_ERROR: DjiErrorCode =
    141733921018;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_AIRCRAFT_UNCONNECTED: DjiErrorCode =
    141733921020;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_CANNOT_UPGRADE_IN_CUR_STATE:
    DjiErrorCode = 141733921022;
pub const DjiErrorCode_DJI_ERROR_CAMERA_MANAGER_MODULE_CODE_UNDEFINE_ERROR: DjiErrorCode =
    141733921023;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_UNSUPPORTED_COMMAND: DjiErrorCode =
    146028888288;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_TIMEOUT: DjiErrorCode = 146028888289;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_RAM_ALLOCATION_FAILED: DjiErrorCode =
    146028888290;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_INVALID_COMMAND_PARAMETER:
    DjiErrorCode = 146028888291;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_UNSUPPORTED_COMMAND_IN_CUR_STATE:
    DjiErrorCode = 146028888292;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_CAMERA_TIME_NOT_SYNCHRONIZED:
    DjiErrorCode = 146028888293;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_PARAMETER_SET_FAILED: DjiErrorCode =
    146028888294;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_PARAMETER_GET_FAILED: DjiErrorCode =
    146028888295;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_SD_CARD_MISSING: DjiErrorCode =
    146028888296;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_SD_CARD_FULL: DjiErrorCode =
    146028888297;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_SD_CARD_ERROR: DjiErrorCode =
    146028888298;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_SENSOR_ERROR: DjiErrorCode =
    146028888299;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_SYSTEM_ERROR: DjiErrorCode =
    146028888300;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_PARAMETER_TOTAL_TOO_LONG: DjiErrorCode =
    146028888301;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_MODULE_INACTIVATED: DjiErrorCode =
    146028888302;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_FIRMWARE_DATA_NUM_DISCONTINUOUS:
    DjiErrorCode = 146028888304;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_FIRMWARE_VERIFICATION_ERROR:
    DjiErrorCode = 146028888306;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_FLASH_WRITE_ERROR: DjiErrorCode =
    146028888308;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_FIRMWARE_TYPE_MISMATCH: DjiErrorCode =
    146028888310;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_REMOTE_CONTROL_UNCONNECTED:
    DjiErrorCode = 146028888312;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_HARDWARE_ERROR: DjiErrorCode =
    146028888314;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_AIRCRAFT_UNCONNECTED: DjiErrorCode =
    146028888316;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_CANNOT_UPGRADE_IN_CUR_STATE:
    DjiErrorCode = 146028888318;
pub const DjiErrorCode_DJI_ERROR_GIMBAL_MANAGER_MODULE_CODE_UNDEFINE_ERROR: DjiErrorCode =
    146028888319;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_COMMON_SUCCESS: DjiErrorCode =
    150323855360;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_COMMON_INVALID_DATA_LENGTH: DjiErrorCode =
    150323855361;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_COMMON_INVALD_FLOAT_NUM: DjiErrorCode =
    150323855362;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_WP_VERSION_NO_MATCH: DjiErrorCode =
    150323855363;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_COMMON_UNKNOWN: DjiErrorCode =
    150323920895;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_RESV: DjiErrorCode = 150323920896;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_WP_NUM_TOO_MANY: DjiErrorCode =
    150323920897;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_WP_NUM_TOO_FEW: DjiErrorCode =
    150323920898;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INVALID_END_INDEX: DjiErrorCode =
    150323920899;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_START_ID_GT_END_ID:
    DjiErrorCode = 150323920900;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_END_ID_GT_TOTAL_NUM:
    DjiErrorCode = 150323920901;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_DOWNLOAD_WPS_NOT_IN_STORED_RAGNE:
    DjiErrorCode = 150323920902;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_CUR_POS_IS_FAR_AWAY_FROM_FIRST_WP:
    DjiErrorCode = 150323920904;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_ADJ_WPS_TOO_CLOSE: DjiErrorCode =
    150323920906;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_ADJ_WPS_TOO_FAR: DjiErrorCode =
    150323920907;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_MAX_VEL_GT_GLOBAL:
    DjiErrorCode = 150323920908;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_LOCAL_CRUISE_VEL_GT_LOCAL_MAX : DjiErrorCode = 150323920909 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_LOCAL_CRUISE_VEL_GT_GLOBAL_MAX : DjiErrorCode = 150323920910 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INVALID_GLOBAL_MAX_VEL:
    DjiErrorCode = 150323920911;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_GLOBAL_CRUISE_VEL_GT_MAX_VEL:
    DjiErrorCode = 150323920912;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INVALID_GOTO_FIRST_FLAG:
    DjiErrorCode = 150323920913;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INVALID_FINISHED_ACTION:
    DjiErrorCode = 150323920914;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INVALID_RC_LOST_ACTION:
    DjiErrorCode = 150323920915;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_YAW_MODE_INVALID:
    DjiErrorCode = 150323920916;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_YAW_CMD_NOT_IN_RANGE:
    DjiErrorCode = 150323920917;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_YAW_TURN_DIRECTION_INVALID:
    DjiErrorCode = 150323920918;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_WP_TYPE_INVALID: DjiErrorCode =
    150323920919;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_GO_STOP_CMD_INVALID: DjiErrorCode =
    150323920920;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INVALID_PAUSE_RECOVERY_CMD:
    DjiErrorCode = 150323920921;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INVALID_BREAK_RESTORE_CMD:
    DjiErrorCode = 150323920922;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INVALID_REF_POINT: DjiErrorCode =
    150323920923;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_DAMPING_DIS_GE_DIS_OF_ADJ_POINTS:
    DjiErrorCode = 150323920924;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_CANNT_SET_WP_LINE_EXIT_TYPE:
    DjiErrorCode = 150323920925;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_INFO_NOT_UPLOADED: DjiErrorCode =
    150323920926;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_WP_HAS_NOT_UPLOADED: DjiErrorCode =
    150323920927;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOADED_WP_NOT_ENOUGH: DjiErrorCode =
    150323920928;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_GS_HAS_STARTED: DjiErrorCode =
    150323920929;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_GS_NOT_RUNNING: DjiErrorCode =
    150323920930;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_GS_NOT_RUNNING_FOR_PAUSE_RECOVERY:
    DjiErrorCode = 150323920931;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_GS_NOT_RUNNING_FOR_BREAK_RESTORE:
    DjiErrorCode = 150323920932;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_NOT_IN_WP_MIS: DjiErrorCode =
    150323920933;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_MIS_HAS_BEEN_PAUSED: DjiErrorCode =
    150323920934;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_MIS_NOT_PAUSED: DjiErrorCode =
    150323920935;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_MIS_HAS_BEEN_BROKEN: DjiErrorCode =
    150323920936;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_MIS_NOT_BROKEN: DjiErrorCode =
    150323920937;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_PAUSE_RECOVERY_NOT_SUPPORTED:
    DjiErrorCode = 150323920938;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_BREAK_RESTORE_NOT_SUPPORTED:
    DjiErrorCode = 150323920939;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_NO_BREAK_POINT: DjiErrorCode =
    150323920940;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_NO_CUR_TRAJ_PROJECT: DjiErrorCode =
    150323920941;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_NO_NXT_TRAJ_PROJECT: DjiErrorCode =
    150323920942;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_NO_NNT_TRAJ_PROJECT: DjiErrorCode =
    150323920943;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_UPLOAD_WP_ID_NOT_CONTINUE:
    DjiErrorCode = 150323920944;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_WP_LINE_ENTER_NOT_SET_TO_START_WP:
    DjiErrorCode = 150323920945;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_INIT_WP_WHEN_PLAN_HAS_STARTED:
    DjiErrorCode = 150323920946;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_DAMPING_DIS_EXCEED_RANGE:
    DjiErrorCode = 150323920947;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_WAYPOINT_COOR_EXCEED_RANGE:
    DjiErrorCode = 150323920948;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_FIRST_WP_TYPE_IS_WP_TURN_NO:
    DjiErrorCode = 150323920949;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_WP_EXCEED_RADIUS_LIMIT: DjiErrorCode =
    150323920952;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRAJ_WP_EXCEED_HEIGHT_LIMIT: DjiErrorCode =
    150323920953;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_STATUS_RESV: DjiErrorCode = 150323986432;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_STATUS_WP_MIS_CHECK_FAIL: DjiErrorCode =
    150323986433;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_STATUS_HOME_NOT_RECORDED: DjiErrorCode =
    150323986434;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_STATUS_LOW_LOCATION_ACCURACY:
    DjiErrorCode = 150323986435;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_STATUS_RTK_CONDITION_IS_NOT_READY:
    DjiErrorCode = 150323986437;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_SECURE_RESV: DjiErrorCode = 150324051968;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_SECURE_CROSS_NFZ: DjiErrorCode =
    150324051969;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_SECURE_BAT_LOW: DjiErrorCode =
    150324051970;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_RESV: DjiErrorCode =
    150328049664;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_ACTION_ID_DUPLICATED:
    DjiErrorCode = 150328049665;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_ACTION_ITEMS_SPACE_NOT_ENOUGH : DjiErrorCode = 150328049666 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_ACTION_SIZE_GT_BUF_SIZE:
    DjiErrorCode = 150328049667;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_ACTION_ID_NOT_FOUND:
    DjiErrorCode = 150328049668;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_DOWNLOAD_ACTION_ID_RANGE_ERROR : DjiErrorCode = 150328049669 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTION_COMMON_NO_ACTION_ITEMS_STORED:
    DjiErrorCode = 150328049670;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_RESV: DjiErrorCode = 150328115200;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_TYPE_INVALID: DjiErrorCode =
    150328115201;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_REACH_WP_END_INDEX_LT_START_INDEX : DjiErrorCode = 150328115233 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_REACH_WP_INVALID_INTERVAL_WP_NUM : DjiErrorCode = 150328115234 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_REACH_WP_INVALID_AUTO_TERMINATE_WP_NUM : DjiErrorCode = 150328115235 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_ASSOCIATE_INVALID_TYPE:
    DjiErrorCode = 150328115265;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_TRIGGER_SIMPLE_INTERVAL_INVALID_TYPE:
    DjiErrorCode = 150328115329;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_COMMON_RESV: DjiErrorCode =
    150328180736;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_COMMON_ACTUATOR_EXEC_NON_SUPPORTED : DjiErrorCode = 150328180737 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_COMMON_ACTUATOR_TYPE_INVALID:
    DjiErrorCode = 150328180738;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_COMMON_ACTUATOR_FUNC_INVALID:
    DjiErrorCode = 150328180739;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_RESV: DjiErrorCode =
    150328246272;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_SEND_SINGLE_SHOT_CMD_TO_CAMERA_FAIL : DjiErrorCode = 150328246273 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_SEND_VIDEO_START_CMD_TO_CAMERA_FAIL : DjiErrorCode = 150328246274 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_SEND_VIDEO_STOP_CMD_TO_CAMERA_FAIL : DjiErrorCode = 150328246275 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_FOCUS_PARAM_XY_INVALID:
    DjiErrorCode = 150328246276;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_SEND_FOCUS_CMD_TO_CAMERA_FAIL : DjiErrorCode = 150328246277 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_SEND_FOCALIZE_CMD_TO_CAMERA_FAIL : DjiErrorCode = 150328246278 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_FOCAL_DISTANCE_INVALID:
    DjiErrorCode = 150328246279;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_CAMERA_EXEC_FAIL: DjiErrorCode =
    150328246528;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_GIMBAL_RESV: DjiErrorCode =
    150328311808;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_GIMBAL_INVALID_RPY_ANGLE_CTRL_CMD : DjiErrorCode = 150328311809 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_GIMBAL_INVALID_DURATION_CMD:
    DjiErrorCode = 150328311810;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_GIMBAL_FAIL_TO_ARRIVE_TGT_ANGLE : DjiErrorCode = 150328311811 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_GIMBAL_FAIL_TO_SEND_CMD_TO_GIMBAL : DjiErrorCode = 150328311812 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_GIMBAL_THIS_INDEX_OF_GIMBAL_NOT_DOING_UNIFORM_CTRL : DjiErrorCode = 150328311813 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_FLIGHT_RESV: DjiErrorCode =
    150328442880;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_FLIGHT_YAW_INVALID_YAW_ANGLE:
    DjiErrorCode = 150328442881;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_FLIGHT_YAW_TO_TGT_ANGLE_TIMEOUT : DjiErrorCode = 150328442882 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_FLIGHT_ACTION_YAW_OCCUPIED:
    DjiErrorCode = 150328442883;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_FLIGHT_CUR_AND_TGT_VEL_CLE_STATUE_EQUAL : DjiErrorCode = 150328442884 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_PAYLOAD_RESV: DjiErrorCode =
    150328508416;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_PAYLOAD_FAIL_TO_SEND_CMD_TO_PAYLOAD : DjiErrorCode = 150328508417 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V2_MODULE_CODE_ACTUATOR_PAYLOAD_EXEC_FAILED:
    DjiErrorCode = 150328508418;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_COMMON_SUCCESS: DjiErrorCode =
    154618822656;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_MISSION_ID_NOT_EXIST: DjiErrorCode =
    154618822657;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_WAYLINE_INFO_ERROR: DjiErrorCode =
    154618822658;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_WPMZ_FILE_VERSION_NOT_MATCH: DjiErrorCode =
    154618822659;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_WPMZ_FILE_LOAD_ERROR: DjiErrorCode =
    154618822660;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_NO_BREAK_INFO: DjiErrorCode = 154618822661;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CMD_INVALID: DjiErrorCode = 154618822662;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_START_WAYLINE_WHEN_WAYLINE_RUNNING : DjiErrorCode = 154618822913 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_BREAK_WAYLINE_IN_CUR_STATE:
    DjiErrorCode = 154618822914;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_STOP_WAYLINE_WHEN_WAYLINE_NOT_RUNNING : DjiErrorCode = 154618822915 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_BREAK_WAYLINE_WHEN_WAYLINE_NOT_RUNNING : DjiErrorCode = 154618822916 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_REQUEST_DRONE_CONTROL:
    DjiErrorCode = 154618822917;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_RESUME_WAYLINE_IN_CUR_STATE:
    DjiErrorCode = 154618822918;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_HEIGHT_LIMIT: DjiErrorCode = 154618823169;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RADIUS_LIMIT: DjiErrorCode = 154618823170;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CROSS_FLYLIMIT_AERA: DjiErrorCode =
    154618823171;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_LOW_LIMIT: DjiErrorCode = 154618823172;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_OBSTACAL_STOP: DjiErrorCode = 154618823173;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RTK_DISCONNECT: DjiErrorCode =
    154618823174;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_BOUNDARY_LIMIT: DjiErrorCode =
    154618823175;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RC_PITCH_ROLL_BREAK: DjiErrorCode =
    154618823176;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_AIRPORT_HEIGHT_LIMIT: DjiErrorCode =
    154618823177;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_REQUEST_TAKEOFF_FAIL: DjiErrorCode =
    154618823178;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_AUTOTAKEOFF_RUN_FAIL: DjiErrorCode =
    154618823179;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_REQUEST_WAYLINE_FAIL: DjiErrorCode =
    154618823180;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_AGRO_PLAN_FAIL: DjiErrorCode =
    154618823181;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_REQUEST_QUICK_TAKEOFF_ASSIST_FAIL:
    DjiErrorCode = 154618823182;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_QUICK_TAKEOFF_ASSIST_RUN_FAIL:
    DjiErrorCode = 154618823183;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_VFENCE_LIMIT: DjiErrorCode = 154618823184;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_GPS_INVALID: DjiErrorCode = 154618823425;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_START_AT_CURRENT_RC_MODE:
    DjiErrorCode = 154618823426;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_HOME_POINT_NOT_RECORDED: DjiErrorCode =
    154618823427;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_LOWER_BATTERY: DjiErrorCode = 154618823428;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RETURN_HOME: DjiErrorCode = 154618823429;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ADSB_ERROR: DjiErrorCode = 154618823430;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RC_LOST: DjiErrorCode = 154618823431;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RTK_NOT_READY: DjiErrorCode = 154618823432;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_DRONE_IS_MOVING: DjiErrorCode =
    154618823433;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_DRONE_ON_GROUND_MOTOR_ON: DjiErrorCode =
    154618823434;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_SURFACE_FOLLOW_CAMERA_INVALID:
    DjiErrorCode = 154618823435;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_SURFACE_FOLLOW_HEIGHT_INVALID:
    DjiErrorCode = 154618823436;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_SURFACE_FOLLOW_MAP_WRONG: DjiErrorCode =
    154618823437;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_HOMEPOINT_NOT_MATCH_RTK: DjiErrorCode =
    154618823438;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_STRONG_WIND_GOHOME: DjiErrorCode =
    154618823440;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_DRONE_CRITICAL_ERROR: DjiErrorCode =
    154618823679;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_CANNOT_FIND_PAYLOAD: DjiErrorCode =
    154618823681;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_EXECUTION_FAILED: DjiErrorCode =
    154618823682;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_FARM_NO_PESTICIDE: DjiErrorCode =
    154618823683;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_RADAR_DISCONNECT: DjiErrorCode =
    154618823684;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_USER_EXIT: DjiErrorCode = 154618823937;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_USER_BREAK: DjiErrorCode = 154618823938;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_USER_SET_GOHOME: DjiErrorCode =
    154618823939;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_USER_AGRO_PLANNER_STATE_CHANGE:
    DjiErrorCode = 154618823940;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_USER_SWITCH_RC_MODE: DjiErrorCode =
    154618823941;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INIT_FAIL: DjiErrorCode =
    154618824192;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_JOB_EXIT_BUT_MIS_RUNNING:
    DjiErrorCode = 154618824193;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_ON_GROUND_MOTOR_ON_CANNOT_GO:
    DjiErrorCode = 154618824194;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_START_INDEX_OR_PROG:
    DjiErrorCode = 154618824195;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_CSYS_MODE: DjiErrorCode =
    154618824196;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_HEIGHT_MODE: DjiErrorCode =
    154618824197;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_FLY_WP_MODE: DjiErrorCode =
    154618824198;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_YAW_MODE: DjiErrorCode =
    154618824199;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_TURN_DIR_MODE: DjiErrorCode =
    154618824200;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_WP_TYPE: DjiErrorCode =
    154618824201;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_FIR_LAS_WP_TYPE_ERROR: DjiErrorCode =
    154618824202;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_GLOB_VEL_OUT_OF_RANGE: DjiErrorCode =
    154618824203;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_WP_NUM_OUT_OF_RANGE: DjiErrorCode =
    154618824204;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_LAT_LONG_OUT_OF_RANGE: DjiErrorCode =
    154618824205;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_DAMP_DIS_OUT_OF_RANGE: DjiErrorCode =
    154618824206;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_MAX_VEL_OUT_OF_RANGE: DjiErrorCode =
    154618824207;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_VEL_OUT_OF_RANGE: DjiErrorCode =
    154618824208;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_WP_YAW_OUT_OF_RANGE: DjiErrorCode =
    154618824209;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_YAW_MODE_IN_VERT_SEGM:
    DjiErrorCode = 154618824210;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_WP_BREAK_INFO_MISSION_ID_CHANGED:
    DjiErrorCode = 154618824211;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_WP_BREAK_INFO_PROGRESS_OUT_OF_RANGE : DjiErrorCode = 154618824212 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_WP_BREAK_INFO_INVALID_MISSION_STATE : DjiErrorCode = 154618824213 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_WP_BREAK_INFO_WP_INDEX_OUT_OF_RANGE : DjiErrorCode = 154618824214 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_BREAK_LAT_LONG_OUT_OF_RANGE:
    DjiErrorCode = 154618824215;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_BREAK_INFO_WP_YAW_OUT_OF_RANGE:
    DjiErrorCode = 154618824216;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_INVALID_BREAK_INFO_FLAG:
    DjiErrorCode = 154618824217;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_GET_TRAJ_INFO_FAILED: DjiErrorCode =
    154618824218;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_GENERATE_FAIL: DjiErrorCode =
    154618824219;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_LIB_RUN_FAIL: DjiErrorCode =
    154618824220;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRAJ_LIB_EMERGENCY_BRAKE: DjiErrorCode =
    154618824221;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_NOT_FOUND:
    DjiErrorCode = 154618824244;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_INDEX_REPEATED:
    DjiErrorCode = 154618824247;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_INFO_SIZE_TOO_LONG_OR_TOO_SHORT : DjiErrorCode = 154618824248 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_TREE_EMPTY:
    DjiErrorCode = 154618824249;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_TREE_LAYER_EMPTY:
    DjiErrorCode = 154618824250;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_ID_REPEATED:
    DjiErrorCode = 154618824251;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_NODE_CHILDREN_NUM_LT_2 : DjiErrorCode = 154618824252 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_INDEX_OUT_OF_RANGE:
    DjiErrorCode = 154618824253;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_ID_IS_65535:
    DjiErrorCode = 154618824254;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_NODE_CHILDNUM_SUM_NOT_EQ_NEXT_LAYER_SIZE : DjiErrorCode = 154618824255 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_TREE_LAYER_NUM_TOO_MORE : DjiErrorCode = 154618824256 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_TREE_LAYER_NUM_TOO_LESS : DjiErrorCode = 154618824257 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_GROUP_NUM_OUT_OF_RANGE : DjiErrorCode = 154618824258 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_GROUP_VALID_RANGE_ERROR : DjiErrorCode = 154618824259 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_TREE_ROOT_STATUS_INVALID : DjiErrorCode = 154618824260 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_TREE_NODE_STATUS_INVALID : DjiErrorCode = 154618824261 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_BREAK_INFO_ACTION_GROUP_ID_OUT_OF_RANGE : DjiErrorCode = 154618824262 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_STATUS_TREE_SIZE_ERROR : DjiErrorCode = 154618824263 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_BREAK_INFO_TRIGGER_RUN_RESULT_INVALID : DjiErrorCode = 154618824264 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_BREAK_INFO_ACTION_GROUP_ID_REPEATED : DjiErrorCode = 154618824265 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_BREAK_INFO_ACTION_LOCATION_REPEATED : DjiErrorCode = 154618824266 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_BREAK_INFO_ACTION_LOCATION_OUT_OF_RANGE : DjiErrorCode = 154618824267 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_RESUME_ID_NOT_IN_BREAK_INFO : DjiErrorCode = 154618824268 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_RESUME_INFO_MODIFY_ACTION_STATUS_FROM_NO_INTERRUPT_TO_INTERRUPT : DjiErrorCode = 154618824269 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTION_COMMON_ACTION_RESUME_FAIL_FOR_INVALID_RESUME_INFO : DjiErrorCode = 154618824270 ;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_ACTUATOR_COMMON_ACTUATOR_NOT_FOUND:
    DjiErrorCode = 154618824290;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRIGGER_NOT_FOUND: DjiErrorCode =
    154618824305;
pub const DjiErrorCode_DJI_ERROR_WAYPOINT_V3_MODULE_CODE_TRIGGER_SINGLE_TIME_CHECK_FAIL:
    DjiErrorCode = 154618824306;
#[doc = " @brief DJI error code complete works. Users can search all error messages here.\n @details Please get error description, error reason and error recovery suggestion of every error code from\n ::DJI_ERROR_OBJECTS macro."]
pub type DjiErrorCode = ::std::os::raw::c_ulong;
#[doc = " @brief Type define double as dji_f64_t."]
pub type dji_f64_t = f64;
#[doc = " @brief Type define float as dji_f32_t."]
pub type dji_f32_t = f32;
#[doc = " @brief Type define uint64 as T_DjiReturnCode.\n @details The type can be any value of ::DjiErrorCode."]
pub type T_DjiReturnCode = u64;
pub const E_DjiMountPositionType_DJI_MOUNT_POSITION_TYPE_UNKNOWN: E_DjiMountPositionType = 0;
pub const E_DjiMountPositionType_DJI_MOUNT_POSITION_TYPE_PAYLOAD_PORT: E_DjiMountPositionType = 1;
pub const E_DjiMountPositionType_DJI_MOUNT_POSITION_TYPE_EXTENSION_PORT: E_DjiMountPositionType = 2;
pub const E_DjiMountPositionType_DJI_MOUNT_POSITION_TYPE_EXTENSION_LITE_PORT:
    E_DjiMountPositionType = 3;
pub type E_DjiMountPositionType = ::std::os::raw::c_uint;
pub const E_DjiMountPosition_DJI_MOUNT_POSITION_UNKNOWN: E_DjiMountPosition = 0;
pub const E_DjiMountPosition_DJI_MOUNT_POSITION_PAYLOAD_PORT_NO1: E_DjiMountPosition = 1;
pub const E_DjiMountPosition_DJI_MOUNT_POSITION_PAYLOAD_PORT_NO2: E_DjiMountPosition = 2;
pub const E_DjiMountPosition_DJI_MOUNT_POSITION_PAYLOAD_PORT_NO3: E_DjiMountPosition = 3;
pub const E_DjiMountPosition_DJI_MOUNT_POSITION_EXTENSION_PORT: E_DjiMountPosition = 4;
pub const E_DjiMountPosition_DJI_MOUNT_POSITION_EXTENSION_LITE_PORT: E_DjiMountPosition = 5;
pub type E_DjiMountPosition = ::std::os::raw::c_uint;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_UNKNOWN: E_DjiAircraftSeries = 0;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_M200_V2: E_DjiAircraftSeries = 1;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_M300: E_DjiAircraftSeries = 2;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_M30: E_DjiAircraftSeries = 3;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_M3: E_DjiAircraftSeries = 4;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_M350: E_DjiAircraftSeries = 5;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_M3D: E_DjiAircraftSeries = 6;
pub const E_DjiAircraftSeries_DJI_AIRCRAFT_SERIES_FC30: E_DjiAircraftSeries = 7;
pub type E_DjiAircraftSeries = ::std::os::raw::c_uint;
#[doc = "< Aircraft type is unknown."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_UNKNOWN: E_DjiAircraftType = 0;
#[doc = "< Aircraft type is Matrice 200 V2."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M200_V2: E_DjiAircraftType = 44;
#[doc = "< Aircraft type is Matrice 220 V2."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M210_V2: E_DjiAircraftType = 45;
#[doc = "< Aircraft type is Matrice 210 RTK V2."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M210RTK_V2: E_DjiAircraftType = 46;
#[doc = "< Aircraft type is Matrice 300 RTK."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M300_RTK: E_DjiAircraftType = 60;
#[doc = "< Aircraft type is Matrice 30."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M30: E_DjiAircraftType = 67;
#[doc = "< Aircraft type is Matrice 30T."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M30T: E_DjiAircraftType = 68;
#[doc = "< Aircraft type is Mavic 3E."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M3E: E_DjiAircraftType = 77;
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_FC30: E_DjiAircraftType = 78;
#[doc = "< Aircraft type is Mavic 3T."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M3T: E_DjiAircraftType = 79;
#[doc = "< Aircraft type is Matrice 350 RTK."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M350_RTK: E_DjiAircraftType = 89;
#[doc = "< Aircraft type is Matrice 3D."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M3D: E_DjiAircraftType = 91;
#[doc = "< Aircraft type is Matrice 3TD."]
pub const E_DjiAircraftType_DJI_AIRCRAFT_TYPE_M3TD: E_DjiAircraftType = 93;
pub type E_DjiAircraftType = ::std::os::raw::c_uint;
#[doc = "< Camera type is unknown."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_UNKNOWN: E_DjiCameraType = 0;
#[doc = "< Camera type is Z30."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_Z30: E_DjiCameraType = 20;
#[doc = "< Camera type is XT2."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_XT2: E_DjiCameraType = 26;
#[doc = "< Camera type is third party camera based on Payload SDK."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_PSDK: E_DjiCameraType = 31;
#[doc = "< Camera type is XT S."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_XTS: E_DjiCameraType = 41;
#[doc = "< Camera type is H20."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_H20: E_DjiCameraType = 42;
#[doc = "< Camera type is H20T."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_H20T: E_DjiCameraType = 43;
#[doc = "< Camera type is H20N."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_H20N: E_DjiCameraType = 61;
#[doc = "< Camera type is P1."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_P1: E_DjiCameraType = 50;
#[doc = "< Camera type is L1."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_L1: E_DjiCameraType = 51;
#[doc = "< Camera type is L2."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_L2: E_DjiCameraType = 84;
#[doc = "< Camera type is M30."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_M30: E_DjiCameraType = 52;
#[doc = "< Camera type is M30T."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_M30T: E_DjiCameraType = 53;
#[doc = "< Camera type is M3E."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_M3E: E_DjiCameraType = 66;
#[doc = "< Camera type is M3T."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_M3T: E_DjiCameraType = 67;
#[doc = "< Camera type is Matrice 3D."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_M3D: E_DjiCameraType = 80;
#[doc = "< Camera type is Matrice 3TD."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_M3TD: E_DjiCameraType = 81;
#[doc = "< Camera type is H30."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_H30: E_DjiCameraType = 82;
#[doc = "< Camera type is H30T."]
pub const E_DjiCameraType_DJI_CAMERA_TYPE_H30T: E_DjiCameraType = 83;
#[doc = " @brief Camera type."]
pub type E_DjiCameraType = ::std::os::raw::c_uint;
#[doc = "< Media sub file origin data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_ORG: E_DjiCameraMediaFileSubType = 0;
#[doc = "< Media sub file cloud point raw data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_LDR: E_DjiCameraMediaFileSubType = 21;
#[doc = "< Media sub file point cloud signature type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_SIG: E_DjiCameraMediaFileSubType = 22;
#[doc = "< Media sub file point cloud real-time kinematic type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_RTK: E_DjiCameraMediaFileSubType = 23;
#[doc = "< Media sub file radar-camera external reference type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_CLC: E_DjiCameraMediaFileSubType = 25;
#[doc = "< Media sub file radar-IMU external reference type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_CLI: E_DjiCameraMediaFileSubType = 26;
#[doc = "< Media sub file IMU data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_IMU: E_DjiCameraMediaFileSubType = 27;
#[doc = "< Media sub file RTK boom data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_RTL: E_DjiCameraMediaFileSubType = 28;
#[doc = "< Media sub file RTK base station data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_RTB: E_DjiCameraMediaFileSubType = 29;
#[doc = "< Media sub file RTK secondary antenna data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_RTS: E_DjiCameraMediaFileSubType = 30;
#[doc = "< Media sub file real-time fusion of attitude and position data type."]
pub const E_DjiCameraMediaFileSubType_DJI_DOWNLOAD_FILE_RPOS: E_DjiCameraMediaFileSubType = 31;
#[doc = " @brief Camera supported media file subtype."]
pub type E_DjiCameraMediaFileSubType = ::std::os::raw::c_uint;
#[doc = "< Media file JPEG type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_JPEG: E_DjiCameraMediaFileType = 0;
#[doc = "< Media file DNG type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_DNG: E_DjiCameraMediaFileType = 1;
#[doc = "< Media file MOV type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_MOV: E_DjiCameraMediaFileType = 2;
#[doc = "< Media file MP4 type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_MP4: E_DjiCameraMediaFileType = 3;
#[doc = "< Media file TIFF type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_TIFF: E_DjiCameraMediaFileType = 5;
#[doc = "< Media file LDRT type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_LDRT: E_DjiCameraMediaFileType = 24;
#[doc = "< Media file RPT type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_RPT: E_DjiCameraMediaFileType = 25;
#[doc = "< Media file unknown type."]
pub const E_DjiCameraMediaFileType_DJI_CAMERA_FILE_TYPE_UNKNOWN: E_DjiCameraMediaFileType = 255;
#[doc = " @brief Camera supported media file type."]
pub type E_DjiCameraMediaFileType = ::std::os::raw::c_uint;
#[doc = " @brief Camera optical zoom specifies."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraOpticalZoomSpec {
    #[doc = "< The maximum focal length of the lens, unit: 0.1mm."]
    pub maxFocalLength: u16,
    #[doc = "< The minimum focal length of the lens, unit: 0.1mm."]
    pub minFocalLength: u16,
    #[doc = "< The minimum interval of focal length change, unit: 0.1mm."]
    pub focalLengthStep: u16,
}
#[doc = "< Free mode, fix gimbal attitude in the ground coordinate, ignoring movement of aircraft."]
pub const E_DjiGimbalMode_DJI_GIMBAL_MODE_FREE: E_DjiGimbalMode = 0;
#[doc = "< FPV (First Person View) mode, only control roll and yaw angle of gimbal in the ground coordinate to follow aircraft."]
pub const E_DjiGimbalMode_DJI_GIMBAL_MODE_FPV: E_DjiGimbalMode = 1;
#[doc = "< Yaw follow mode, only control yaw angle of gimbal in the ground coordinate to follow aircraft."]
pub const E_DjiGimbalMode_DJI_GIMBAL_MODE_YAW_FOLLOW: E_DjiGimbalMode = 2;
#[doc = " @brief Gimbal work mode, specifies how gimbal follow aircraft movement."]
pub type E_DjiGimbalMode = ::std::os::raw::c_uint;
#[doc = "< Relative angle rotation mode, represents rotating gimbal specified angles based on current angles."]
pub const E_DjiGimbalRotationMode_DJI_GIMBAL_ROTATION_MODE_RELATIVE_ANGLE: E_DjiGimbalRotationMode =
    0;
#[doc = "< Absolute angle rotation mode, represents rotating gimbal to specified angles in the ground coordinate."]
pub const E_DjiGimbalRotationMode_DJI_GIMBAL_ROTATION_MODE_ABSOLUTE_ANGLE: E_DjiGimbalRotationMode =
    1;
#[doc = "< Speed rotation mode, specifies rotation speed of gimbal in the ground coordinate."]
pub const E_DjiGimbalRotationMode_DJI_GIMBAL_ROTATION_MODE_SPEED: E_DjiGimbalRotationMode = 2;
#[doc = " @brief Gimbal rotation mode, specifies control style."]
pub type E_DjiGimbalRotationMode = ::std::os::raw::c_uint;
#[doc = "< The system language of the mobile app is unknown"]
pub const E_DjiMobileAppLanguage_DJI_MOBILE_APP_LANGUAGE_UNKNOWN: E_DjiMobileAppLanguage = 255;
#[doc = "< The system language of the mobile app is English"]
pub const E_DjiMobileAppLanguage_DJI_MOBILE_APP_LANGUAGE_ENGLISH: E_DjiMobileAppLanguage = 0;
#[doc = "< The system language of the mobile app is Chinese"]
pub const E_DjiMobileAppLanguage_DJI_MOBILE_APP_LANGUAGE_CHINESE: E_DjiMobileAppLanguage = 1;
#[doc = "< The system language of the mobile app is Japanese"]
pub const E_DjiMobileAppLanguage_DJI_MOBILE_APP_LANGUAGE_JAPANESE: E_DjiMobileAppLanguage = 2;
#[doc = "< The system language of the mobile app is French"]
pub const E_DjiMobileAppLanguage_DJI_MOBILE_APP_LANGUAGE_FRENCH: E_DjiMobileAppLanguage = 3;
#[doc = " @brief Mobile APP system language."]
pub type E_DjiMobileAppLanguage = ::std::os::raw::c_uint;
#[doc = "< Mobile APP screen type is unknown."]
pub const E_DjiMobileAppScreenType_DJI_MOBILE_APP_SCREEN_TYPE_UNKNOWN: E_DjiMobileAppScreenType =
    255;
#[doc = "< Screen size is 6 inches or larger."]
pub const E_DjiMobileAppScreenType_DJI_MOBILE_APP_SCREEN_TYPE_BIG_SCREEN: E_DjiMobileAppScreenType =
    0;
#[doc = "< Screen size is less than 6 inches."]
pub const E_DjiMobileAppScreenType_DJI_MOBILE_APP_SCREEN_TYPE_LITTLE_SCREEN:
    E_DjiMobileAppScreenType = 1;
#[doc = " @brief Mobile APP screen size type."]
pub type E_DjiMobileAppScreenType = ::std::os::raw::c_uint;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_1_HZ:
    E_DjiDataSubscriptionTopicFreq = 1;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_5_HZ:
    E_DjiDataSubscriptionTopicFreq = 5;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_10_HZ:
    E_DjiDataSubscriptionTopicFreq = 10;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_50_HZ:
    E_DjiDataSubscriptionTopicFreq = 50;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_100_HZ:
    E_DjiDataSubscriptionTopicFreq = 100;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_200_HZ:
    E_DjiDataSubscriptionTopicFreq = 200;
pub const E_DjiDataSubscriptionTopicFreq_DJI_DATA_SUBSCRIPTION_TOPIC_400_HZ:
    E_DjiDataSubscriptionTopicFreq = 400;
#[doc = " @brief Subscription frequency type."]
pub type E_DjiDataSubscriptionTopicFreq = ::std::os::raw::c_uint;
pub const E_DjiDataSubscriptionModule_DJI_DATA_SUBSCRIPTION_MODULE_FC: E_DjiDataSubscriptionModule =
    0;
pub const E_DjiDataSubscriptionModule_DJI_DATA_SUBSCRIPTION_MODULE_CAMERA:
    E_DjiDataSubscriptionModule = 1;
pub const E_DjiDataSubscriptionModule_DJI_DATA_SUBSCRIPTION_MODULE_ERROR:
    E_DjiDataSubscriptionModule = 2;
#[doc = " @brief DJI module enum for defining data subscription module."]
pub type E_DjiDataSubscriptionModule = ::std::os::raw::c_uint;
#[doc = "< SDK adapter type is unknown."]
pub const E_DjiSdkAdapterType_DJI_SDK_ADAPTER_TYPE_UNKNOWN: E_DjiSdkAdapterType = 0;
#[doc = "< SDK adapter type is Skyport V2."]
pub const E_DjiSdkAdapterType_DJI_SDK_ADAPTER_TYPE_SKYPORT_V2: E_DjiSdkAdapterType = 1;
#[doc = "< SDK adapter type is X-Port."]
pub const E_DjiSdkAdapterType_DJI_SDK_ADAPTER_TYPE_XPORT: E_DjiSdkAdapterType = 2;
#[doc = "< No external adapter is connected."]
pub const E_DjiSdkAdapterType_DJI_SDK_ADAPTER_TYPE_NONE: E_DjiSdkAdapterType = 3;
#[doc = " @brief SDK adapter type."]
pub type E_DjiSdkAdapterType = ::std::os::raw::c_uint;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_UNKNOWN: E_DjiChannelAddress = 0;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_PAYLOAD_PORT_NO1: E_DjiChannelAddress = 1;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_PAYLOAD_PORT_NO2: E_DjiChannelAddress = 2;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_PAYLOAD_PORT_NO3: E_DjiChannelAddress = 3;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_EXTENSION_PORT: E_DjiChannelAddress = 4;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_MASTER_RC_APP: E_DjiChannelAddress = 5;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_SLAVE_RC_APP: E_DjiChannelAddress = 6;
pub const E_DjiChannelAddress_DJI_CHANNEL_ADDRESS_CLOUD_API: E_DjiChannelAddress = 7;
pub type E_DjiChannelAddress = ::std::os::raw::c_uint;
#[doc = " @brief Camera focus target point when in focus mode."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraPointInScreen {
    #[doc = "< Specifies the horizontal coordinate within the zone. Range: 0 to 1.\nThe point [0.0, 0.0] represents the top-left corner of the screen."]
    pub focusX: dji_f32_t,
    #[doc = "< Specifies vertical zone coordinate. Range: 0 to 1."]
    pub focusY: dji_f32_t,
}
#[doc = " @brief Camera time interval settings for interval shoot-photo mode."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraPhotoTimeIntervalSettings {
    #[doc = "< Specifies the total capture count of interval settings.\n                             0: reserved, 1-254: specific number, 255: continuous capture until stopped."]
    pub captureCount: u8,
    #[doc = "< Specifies the interval time between two captures, unit: s"]
    pub timeIntervalSeconds: u16,
}
#[doc = "< Slowest zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_SLOWEST: E_DjiCameraZoomSpeed = 72;
#[doc = "< Slow zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_SLOW: E_DjiCameraZoomSpeed = 73;
#[doc = "< Slightly slower than normal zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_MODERATELY_SLOW: E_DjiCameraZoomSpeed = 74;
#[doc = "< Normal zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_NORMAL: E_DjiCameraZoomSpeed = 75;
#[doc = "< Slightly faster than normal zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_MODERATELY_FAST: E_DjiCameraZoomSpeed = 76;
#[doc = "< Fast zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_FAST: E_DjiCameraZoomSpeed = 77;
#[doc = "< Fastest zoom speed."]
pub const E_DjiCameraZoomSpeed_DJI_CAMERA_ZOOM_SPEED_FASTEST: E_DjiCameraZoomSpeed = 78;
#[doc = " @brief Camera zoom speeds."]
pub type E_DjiCameraZoomSpeed = ::std::os::raw::c_uint;
#[doc = " The burst mode can capture 2 pictures per trigger."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_2: E_DjiCameraBurstCount = 2;
#[doc = " The burst mode can capture 3 pictures per trigger."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_3: E_DjiCameraBurstCount = 3;
#[doc = " The burst mode can capture 5 pictures per trigger."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_5: E_DjiCameraBurstCount = 5;
#[doc = " The burst mode can capture 7 pictures per trigger."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_7: E_DjiCameraBurstCount = 7;
#[doc = " Supports capturing 10 pictures per trigger, only supported by X4S, X5S cameras, and Phantom 4 Pro."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_10: E_DjiCameraBurstCount = 10;
#[doc = " Supports capturing 14 pictures per trigger, only supported by X4S, X5S cameras, and Phantom 4 Pro."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_14: E_DjiCameraBurstCount = 14;
#[doc = " Unknown burst count."]
pub const E_DjiCameraBurstCount_DJI_CAMERA_BURST_COUNT_KNOWN: E_DjiCameraBurstCount = 255;
pub type E_DjiCameraBurstCount = ::std::os::raw::c_uint;
#[doc = "< Zooms out, reducing the zoom factor."]
pub const E_DjiCameraZoomDirection_DJI_CAMERA_ZOOM_DIRECTION_OUT: E_DjiCameraZoomDirection = 0;
#[doc = "< Zooms in, increasing the zoom factor."]
pub const E_DjiCameraZoomDirection_DJI_CAMERA_ZOOM_DIRECTION_IN: E_DjiCameraZoomDirection = 1;
#[doc = " @brief Camera zoom direction."]
pub type E_DjiCameraZoomDirection = ::std::os::raw::c_uint;
#[doc = " @brief Data channel state."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiDataChannelState {
    #[doc = " Realtime bandwidth limitation, varying with link status of aircraft system for some channels, such as data\n stream, video stream and download stream. Must ensure actual bandwidth of data transmission is less than\n realtime bandwidth limitation, unit: byte/s."]
    pub realtimeBandwidthLimit: i32,
    #[doc = " Realtime actual transmission bandwidth of data transmission channel calculated before flow controller, unit: byte/s."]
    pub realtimeBandwidthBeforeFlowController: i32,
    #[doc = " Realtime actual transmission bandwidth of data transmission channel calculated after flow controller, unit:\n byte/s. If specified channel without flow controller. the value is equal to\n ::realtimeBandwidthBeforeFlowController."]
    pub realtimeBandwidthAfterFlowController: i32,
    #[doc = " State specified whether the channel is busy or not. When data can not be sent to the endpoint directly, instead be\n sent to buffer of flow controller or discarded, the busy state will be set. At this time, the user should stop\n transmitting data or decrease the amount of data to be transmitted via this channel. When data bandwidth restore to\n normal, this state will be clear again."]
    pub busyState: bool,
}
#[doc = " @brief Represents a vector using int32 coordinates."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Vector3d {
    #[doc = "< X-coordinate of the vector."]
    pub x: i32,
    #[doc = "< Y-coordinate of the vector."]
    pub y: i32,
    #[doc = "< Z-coordinate of the vector."]
    pub z: i32,
}
#[doc = " @brief Represents a vector using int32 coordinates."]
pub type T_DjiVector3d = Vector3d;
#[doc = " @brief Represents a vector using floating-point coordinates."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct Vector3f {
    #[doc = "< X-coordinate of the vector."]
    pub x: dji_f32_t,
    #[doc = "< Y-coordinate of the vector."]
    pub y: dji_f32_t,
    #[doc = "< Z-coordinate of the vector."]
    pub z: dji_f32_t,
}
#[doc = " @brief Represents a vector using floating-point coordinates."]
pub type T_DjiVector3f = Vector3f;
#[doc = " @brief Represents an attitude using int32 values for pitch, roll, and yaw."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiAttitude3d {
    #[doc = "< Pitch angle in degrees."]
    pub pitch: i32,
    #[doc = "< Roll angle in degrees."]
    pub roll: i32,
    #[doc = "< Yaw angle in degrees."]
    pub yaw: i32,
}
#[doc = " @brief Represents an attitude using floating-point values for pitch, roll, and yaw."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiAttitude3f {
    #[doc = "< Pitch angle in degrees."]
    pub pitch: dji_f32_t,
    #[doc = "< Roll angle in degrees."]
    pub roll: dji_f32_t,
    #[doc = "< Yaw angle in degrees."]
    pub yaw: dji_f32_t,
}
#[doc = " @brief Represents a quaternion, when converted to a rotation matrix or Euler angles."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiQuaternion4f {
    #[doc = "< Quaternion component w."]
    pub q0: dji_f32_t,
    #[doc = "< Quaternion component x."]
    pub q1: dji_f32_t,
    #[doc = "< Quaternion component y."]
    pub q2: dji_f32_t,
    #[doc = "< Quaternion component z."]
    pub q3: dji_f32_t,
}
#[doc = " @brief Timestamp data structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiDataTimestamp {
    pub millisecond: u32,
    pub microsecond: u32,
}
#[doc = " @brief The firmware version of payload.\n @note The firmware version is displayed as AA.BB.CC.DD where AA is majorVersion,\n BB is minorVersion, CC is modifyVersion, and DD is debugVersion."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFirmwareVersion {
    #[doc = "< Major version number, ranging from 0 to 99."]
    pub majorVersion: u8,
    #[doc = "< Minor version number, ranging from 0 to 99."]
    pub minorVersion: u8,
    #[doc = "< Modification version number, ranging from 0 to 99."]
    pub modifyVersion: u8,
    #[doc = "< Debug version number, ranging from 0 to 99."]
    pub debugVersion: u8,
}
#[doc = " @brief Prototype of callback function used to receive data of topic.\n @warning User can not execute blocking style operations or functions in the callback function, because that will block PSDK\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param data: pointer to data of the topic, user need transfer type of this pointer to the corresponding data structure\n pointer for getting every item of the topic conveniently.\n @param dataSize: the size of memory space pointed by data argument, equal to data structure size corresponding to the topic.\n @param timestamp: pointer to timestamp corresponding this data. Use flight controller power-on timestamp on M300 RTK.\n Use payload local timestamp on M30/M30T.\n @return Execution result."]
pub type DjiReceiveDataOfTopicCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const u8,
        dataSize: u16,
        timestamp: *const T_DjiDataTimestamp,
    ) -> T_DjiReturnCode,
>;
#[doc = " @brief Information related to mobile APP."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiMobileAppInfo {
    #[doc = "< Mobile APP system language"]
    pub appLanguage: E_DjiMobileAppLanguage,
    #[doc = "< Mobile APP screen size type."]
    pub appScreenType: E_DjiMobileAppScreenType,
}
impl Default for T_DjiMobileAppInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Basic information about the aircraft system, mainly including some constant parameters information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiAircraftInfoBaseInfo {
    #[doc = "< Aircraft series."]
    pub aircraftSeries: E_DjiAircraftSeries,
    #[doc = "< Mount position type."]
    pub mountPositionType: E_DjiMountPositionType,
    #[doc = "< Aircraft type."]
    pub aircraftType: E_DjiAircraftType,
    #[doc = "< DJI adapter type."]
    pub djiAdapterType: E_DjiSdkAdapterType,
    #[doc = "< Payload mount position."]
    pub mountPosition: E_DjiMountPosition,
}
impl Default for T_DjiAircraftInfoBaseInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Aircraft version information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiAircraftVersion {
    pub debugVersion: u8,
    pub modifyVersion: u8,
    pub minorVersion: u8,
    pub majorVersion: u8,
}
extern "C" {
    #[doc = " @brief Basic information about the aircraft system, including aircraft type and DJI adapter type.\n @param baseInfo: Pointer to a memory space where the aircraft's basic information will be stored.\n @return Execution result."]
    pub fn DjiAircraftInfo_GetBaseInfo(baseInfo: *mut T_DjiAircraftInfoBaseInfo)
        -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get information related to mobile app.\n @note Returns unknown for app language and screen type if the RC or app is not connected to the aircraft system.\n @param mobileAppInfo: Pointer to a memory space where the mobile app information will be stored.\n @return Execution result."]
    pub fn DjiAircraftInfo_GetMobileAppInfo(
        mobileAppInfo: *mut T_DjiMobileAppInfo,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get connection status between the payload and the aircraft.\n @note Update period: 1Hz\n @param isConnected: Pointer to connection status.\n @return Execution result."]
    pub fn DjiAircraftInfo_GetConnectionStatus(isConnected: *mut bool) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get version of the aircraft.\n @param aircraftVersion: Pointer to aircraft version.\n @return Execution result."]
    pub fn DjiAircraftInfo_GetAircraftVersion(
        aircraftVersion: *mut T_DjiAircraftVersion,
    ) -> T_DjiReturnCode;
}
#[doc = "- Capture mode. In this mode, the user can capture pictures."]
pub const E_DjiCameraManagerWorkMode_DJI_CAMERA_MANAGER_WORK_MODE_SHOOT_PHOTO:
    E_DjiCameraManagerWorkMode = 0;
#[doc = "- Record mode. In this mode, the user can record videos."]
pub const E_DjiCameraManagerWorkMode_DJI_CAMERA_MANAGER_WORK_MODE_RECORD_VIDEO:
    E_DjiCameraManagerWorkMode = 1;
#[doc = "- Playback mode. In this mode, the user can preview photos and videos, and\ncan delete files. It is supported by Phantom 3 Professional camera, X3, X5\nand X5R cameras on aircraft and Phantom 4 camera. Playback mode is not\nsupported by Z30, X5S, X4S, Phantom 4 Pro, Mavic Pro, Phantom 3 Standard,\nPhantom 3 Advanced, Phantom 3 4K and Osmo series."]
pub const E_DjiCameraManagerWorkMode_DJI_CAMERA_MANAGER_WORK_MODE_PLAYBACK:
    E_DjiCameraManagerWorkMode = 2;
#[doc = "- In this mode, the user can download media to the Mobile Device. Not\nsupported by X5 camera nor X5R camera while mounted on aircraft."]
pub const E_DjiCameraManagerWorkMode_DJI_CAMERA_MANAGER_WORK_MODE_MEDIA_DOWNLOAD:
    E_DjiCameraManagerWorkMode = 3;
#[doc = "- In this mode, live stream resolution and frame rate will be 1080i50 (PAL)\nor 720p60 (NTSC). In this mode videos can be recorded. Still photos can\nalso be taken only when video is recording. The only way to exit broadcast\nmode is to change modes to RECORD_VIDEO. Only supported by Inspire 2."]
pub const E_DjiCameraManagerWorkMode_DJI_CAMERA_MANAGER_WORK_MODE_BROADCAST:
    E_DjiCameraManagerWorkMode = 4;
#[doc = " The camera work mode is unknown."]
pub const E_DjiCameraManagerWorkMode_DJI_CAMERA_MANAGER_WORK_MODE_WORK_MODE_UNKNOWN:
    E_DjiCameraManagerWorkMode = 255;
#[doc = " @brief CameraModule work modes."]
pub type E_DjiCameraManagerWorkMode = ::std::os::raw::c_uint;
#[doc = "- Sets the camera to take a single photo."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_SINGLE:
    E_DjiCameraManagerShootPhotoMode = 1;
#[doc = "- Sets the camera to take an HDR photo. X5 camera, X5R camera, XT camera,\nZ30 camera, Phantom 4 Pro camera, X4S camera and X5S camera do not support\nHDR mode."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_HDR:
    E_DjiCameraManagerShootPhotoMode = 2;
#[doc = "- Set the camera to take multiple photos at once. XT camera does not\nsupport Burst mode."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_BURST:
    E_DjiCameraManagerShootPhotoMode = 4;
#[doc = "- Automatic Exposure Bracketing (AEB) capture. In this mode you can quickly\ntake multiple shots (the default is 3) at different exposures without\nhaving to manually change any settings between frames. XT camera and Z30\ncamera does not support AEB mode."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_AEB:
    E_DjiCameraManagerShootPhotoMode = 5;
#[doc = "- Sets the camera to take a picture (or multiple pictures) continuously at\na set time interval. The minimum interval for JPEG format of any quality is\n2s. For all cameras except X4S, X5S and Phantom 4 Pro camera: The minimum\ninterval for RAW or RAW+JPEG format is 10s. For the X4S, X5S and Phantom 4\nPro cameras the minimum interval for RAW or RAW+JPEG dformat is 5s."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_INTERVAL:
    E_DjiCameraManagerShootPhotoMode = 6;
#[doc = "- Sets the camera to take a burst of RAW photos. Use getRAWPhotoBurstCount\nto check how many photos have been shot. Only supported by X5S."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_RAW_BURST:
    E_DjiCameraManagerShootPhotoMode = 9;
#[doc = "- \tSets the camera to take an regional photos. It is supported by H20/H20T."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_REGIONAL_SR:
    E_DjiCameraManagerShootPhotoMode = 22;
#[doc = "- The shoot photo mode is unknown."]
pub const E_DjiCameraManagerShootPhotoMode_DJI_CAMERA_MANAGER_SHOOT_PHOTO_MODE_UNKNOWN:
    E_DjiCameraManagerShootPhotoMode = 255;
#[doc = " @brief The ShootPhoto mode itself can have several modes. The default\n value is SINGLE."]
pub type E_DjiCameraManagerShootPhotoMode = ::std::os::raw::c_uint;
#[doc = "< Program mode"]
pub const E_DjiCameraManagerExposureMode_DJI_CAMERA_MANAGER_EXPOSURE_MODE_PROGRAM_AUTO:
    E_DjiCameraManagerExposureMode = 1;
#[doc = "< Shutter priority mode"]
pub const E_DjiCameraManagerExposureMode_DJI_CAMERA_MANAGER_EXPOSURE_MODE_SHUTTER_PRIORITY:
    E_DjiCameraManagerExposureMode = 2;
#[doc = "< Aperture priority mode"]
pub const E_DjiCameraManagerExposureMode_DJI_CAMERA_MANAGER_EXPOSURE_MODE_APERTURE_PRIORITY:
    E_DjiCameraManagerExposureMode = 3;
#[doc = "< Manual mode"]
pub const E_DjiCameraManagerExposureMode_DJI_CAMERA_MANAGER_EXPOSURE_MODE_EXPOSURE_MANUAL:
    E_DjiCameraManagerExposureMode = 4;
#[doc = "< The camera exposure mode is unknown."]
pub const E_DjiCameraManagerExposureMode_DJI_CAMERA_MANAGER_EXPOSURE_MODE_EXPOSURE_UNKNOWN:
    E_DjiCameraManagerExposureMode = 255;
#[doc = " @brief the photo action of INTERVAL shooting photo mode"]
pub type E_DjiCameraManagerExposureMode = ::std::os::raw::c_uint;
#[doc = "- The camera's focus mode is set to manual. In this mode, user sets the\nfocus ring value to adjust the focal distance."]
pub const E_DjiCameraManagerFocusMode_DJI_CAMERA_MANAGER_FOCUS_MODE_MANUAL:
    E_DjiCameraManagerFocusMode = 0;
#[doc = "- The camera's focus mode is set to auto. For the Z30 camera, the focus is\ncalculated completely automatically. For all other cameras, a focus target\ncan be set by the user, which is used to calculate focus automatically."]
pub const E_DjiCameraManagerFocusMode_DJI_CAMERA_MANAGER_FOCUS_MODE_AUTO:
    E_DjiCameraManagerFocusMode = 1;
#[doc = "- The camera's focus mode is set to Continuous AF. It is only supported by\nMavic Pro with firmware version V01.03.0000 or above, X4S camera, Mavic 2\nZoom camera and Mavic 2 Pro camera."]
pub const E_DjiCameraManagerFocusMode_DJI_CAMERA_MANAGER_FOCUS_MODE_AFC:
    E_DjiCameraManagerFocusMode = 2;
#[doc = "- The camera's focus mode is unknown."]
pub const E_DjiCameraManagerFocusMode_DJI_CAMERA_MANAGER_FOCUS_MODE_UNKNOWN:
    E_DjiCameraManagerFocusMode = 255;
#[doc = " @brief CameraModule focus mode. If the physical AF switch on the camera is\n set to auto."]
pub type E_DjiCameraManagerFocusMode = ::std::os::raw::c_uint;
#[doc = " The shutter mode of camera is automatical"]
pub const E_DjiCameraManagerShutterMode_DJI_CAMERA_MANAGER_SHUTTER_AUTO_MODE:
    E_DjiCameraManagerShutterMode = 0;
#[doc = " The shutter mode of camera is manual, the shutter speed setting is\nvalid."]
pub const E_DjiCameraManagerShutterMode_DJI_CAMERA_MANAGER_SHUTTER_MANUAL_MODE:
    E_DjiCameraManagerShutterMode = 1;
#[doc = " @brief CameraModule shutter mode."]
pub type E_DjiCameraManagerShutterMode = ::std::os::raw::c_uint;
#[doc = "< 1/8000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_8000:
    E_DjiCameraManagerShutterSpeed = 0;
#[doc = "< 1/6400 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_6400:
    E_DjiCameraManagerShutterSpeed = 1;
#[doc = "< 1/6000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_6000:
    E_DjiCameraManagerShutterSpeed = 2;
#[doc = "< 1/5000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_5000:
    E_DjiCameraManagerShutterSpeed = 3;
#[doc = "< 1/4000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_4000:
    E_DjiCameraManagerShutterSpeed = 4;
#[doc = "< 1/3200 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_3200:
    E_DjiCameraManagerShutterSpeed = 5;
#[doc = "< 1/3000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_3000:
    E_DjiCameraManagerShutterSpeed = 6;
#[doc = "< 1/2500 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_2500:
    E_DjiCameraManagerShutterSpeed = 7;
#[doc = "< 1/2000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_2000:
    E_DjiCameraManagerShutterSpeed = 8;
#[doc = "< 1/1600 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_1600:
    E_DjiCameraManagerShutterSpeed = 9;
#[doc = "< 1/1500 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_1500:
    E_DjiCameraManagerShutterSpeed = 10;
#[doc = "< 1/1250 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_1250:
    E_DjiCameraManagerShutterSpeed = 11;
#[doc = "< 1/1000 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_1000:
    E_DjiCameraManagerShutterSpeed = 12;
#[doc = "< 1/800 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_800:
    E_DjiCameraManagerShutterSpeed = 13;
#[doc = "< 1/725 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_725:
    E_DjiCameraManagerShutterSpeed = 14;
#[doc = "< 1/640 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_640:
    E_DjiCameraManagerShutterSpeed = 15;
#[doc = "< 1/500 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_500:
    E_DjiCameraManagerShutterSpeed = 16;
#[doc = "< 1/400 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_400:
    E_DjiCameraManagerShutterSpeed = 17;
#[doc = "< 1/350 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_350:
    E_DjiCameraManagerShutterSpeed = 18;
#[doc = "< 1/320 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_320:
    E_DjiCameraManagerShutterSpeed = 19;
#[doc = "< 1/250 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_250:
    E_DjiCameraManagerShutterSpeed = 20;
#[doc = "< 1/240 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_240:
    E_DjiCameraManagerShutterSpeed = 21;
#[doc = "< 1/200 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_200:
    E_DjiCameraManagerShutterSpeed = 22;
#[doc = "< 1/180 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_180:
    E_DjiCameraManagerShutterSpeed = 23;
#[doc = "< 1/160 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_160:
    E_DjiCameraManagerShutterSpeed = 24;
#[doc = "< 1/125 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_125:
    E_DjiCameraManagerShutterSpeed = 25;
#[doc = "< 1/120 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_120:
    E_DjiCameraManagerShutterSpeed = 26;
#[doc = "< 1/100 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_100:
    E_DjiCameraManagerShutterSpeed = 27;
#[doc = "< 1/90 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_90:
    E_DjiCameraManagerShutterSpeed = 28;
#[doc = "< 1/80 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_80:
    E_DjiCameraManagerShutterSpeed = 29;
#[doc = "< 1/60 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_60:
    E_DjiCameraManagerShutterSpeed = 30;
#[doc = "< 1/50 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_50:
    E_DjiCameraManagerShutterSpeed = 31;
#[doc = "< 1/40 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_40:
    E_DjiCameraManagerShutterSpeed = 32;
#[doc = "< 1/30 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_30:
    E_DjiCameraManagerShutterSpeed = 33;
#[doc = "< 1/25 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_25:
    E_DjiCameraManagerShutterSpeed = 34;
#[doc = "< 1/20 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_20:
    E_DjiCameraManagerShutterSpeed = 35;
#[doc = "< 1/15 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_15:
    E_DjiCameraManagerShutterSpeed = 36;
#[doc = "< 1/12.5 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_12DOT5:
    E_DjiCameraManagerShutterSpeed = 37;
#[doc = "< 1/10 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_10:
    E_DjiCameraManagerShutterSpeed = 38;
#[doc = "< 1/8 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_8:
    E_DjiCameraManagerShutterSpeed = 39;
#[doc = "< 1/6.25 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_6DOT25:
    E_DjiCameraManagerShutterSpeed = 40;
#[doc = "< 1/5 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_5:
    E_DjiCameraManagerShutterSpeed = 41;
#[doc = "< 1/4 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_4:
    E_DjiCameraManagerShutterSpeed = 42;
#[doc = "< 1/3 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_3:
    E_DjiCameraManagerShutterSpeed = 43;
#[doc = "< 1/2.5 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_2DOT5:
    E_DjiCameraManagerShutterSpeed = 44;
#[doc = "< 1/2 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_2:
    E_DjiCameraManagerShutterSpeed = 45;
#[doc = "< 1/1.67 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_1DOT67:
    E_DjiCameraManagerShutterSpeed = 46;
#[doc = "< 1/1.25 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1_1DOT25:
    E_DjiCameraManagerShutterSpeed = 47;
#[doc = "< 1.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1:
    E_DjiCameraManagerShutterSpeed = 48;
#[doc = "< 1.3 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1DOT3:
    E_DjiCameraManagerShutterSpeed = 49;
#[doc = "< 1.6 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_1DOT6:
    E_DjiCameraManagerShutterSpeed = 50;
#[doc = "< 2.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_2:
    E_DjiCameraManagerShutterSpeed = 51;
#[doc = "< 2.5 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_2DOT5:
    E_DjiCameraManagerShutterSpeed = 52;
#[doc = "< 3.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_3:
    E_DjiCameraManagerShutterSpeed = 53;
#[doc = "< 3.2 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_3DOT2:
    E_DjiCameraManagerShutterSpeed = 54;
#[doc = "< 4.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_4:
    E_DjiCameraManagerShutterSpeed = 55;
#[doc = "< 5.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_5:
    E_DjiCameraManagerShutterSpeed = 56;
#[doc = "< 6.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_6:
    E_DjiCameraManagerShutterSpeed = 57;
#[doc = "< 7.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_7:
    E_DjiCameraManagerShutterSpeed = 58;
#[doc = "< 8.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_8:
    E_DjiCameraManagerShutterSpeed = 59;
#[doc = "< 9.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_9:
    E_DjiCameraManagerShutterSpeed = 60;
#[doc = "< 10.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_10:
    E_DjiCameraManagerShutterSpeed = 61;
#[doc = "< 13.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_13:
    E_DjiCameraManagerShutterSpeed = 62;
#[doc = "< 15.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_15:
    E_DjiCameraManagerShutterSpeed = 63;
#[doc = "< 20.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_20:
    E_DjiCameraManagerShutterSpeed = 64;
#[doc = "< 25.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_25:
    E_DjiCameraManagerShutterSpeed = 65;
#[doc = "< 30.0 s"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_30:
    E_DjiCameraManagerShutterSpeed = 66;
#[doc = "< Unknown"]
pub const E_DjiCameraManagerShutterSpeed_DJI_CAMERA_MANAGER_SHUTTER_SPEED_UNKNOWN:
    E_DjiCameraManagerShutterSpeed = 255;
#[doc = " @brief CameraModule shutter speed values."]
pub type E_DjiCameraManagerShutterSpeed = ::std::os::raw::c_uint;
#[doc = " The ISO value is automatically set. This cannot be used for all cameras\nwhen in Manual mode."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_AUTO: E_DjiCameraManagerISO = 0;
#[doc = "  The ISO value is set to 100."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_100: E_DjiCameraManagerISO = 3;
#[doc = " The ISO value is set to 200."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_200: E_DjiCameraManagerISO = 4;
#[doc = " The ISO value is set to 400."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_400: E_DjiCameraManagerISO = 5;
#[doc = " The ISO value is set to 800."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_800: E_DjiCameraManagerISO = 6;
#[doc = " The ISO value is set to 1600."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_1600: E_DjiCameraManagerISO = 7;
#[doc = " The ISO value is set to 3200."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_3200: E_DjiCameraManagerISO = 8;
#[doc = " The ISO value is set to 6400."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_6400: E_DjiCameraManagerISO = 9;
#[doc = " The ISO value is set to 12800."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_12800: E_DjiCameraManagerISO = 10;
#[doc = " The ISO value is set to 25600."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_25600: E_DjiCameraManagerISO = 11;
#[doc = " ISO value is fixed by the camera firmware. When the camera color is set\nto D_LOG, camera will fix the ISO to a specific value in order to optimize\nthe performance."]
pub const E_DjiCameraManagerISO_DJI_CAMERA_MANAGER_ISO_FIXED: E_DjiCameraManagerISO = 255;
#[doc = " @brief CameraModule ISO values."]
pub type E_DjiCameraManagerISO = ::std::os::raw::c_uint;
#[doc = " The camera's exposure compensation is -5.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_5_0:
    E_DjiCameraManagerExposureCompensation = 1;
#[doc = " The camera's exposure compensation is -4.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_4_7:
    E_DjiCameraManagerExposureCompensation = 2;
#[doc = " The camera's exposure compensation is -4.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_4_3:
    E_DjiCameraManagerExposureCompensation = 3;
#[doc = " The camera's exposure compensation is -4.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_4_0:
    E_DjiCameraManagerExposureCompensation = 4;
#[doc = " The camera's exposure compensation is -3.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_3_7:
    E_DjiCameraManagerExposureCompensation = 5;
#[doc = " The camera's exposure compensation is -3.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_3_3:
    E_DjiCameraManagerExposureCompensation = 6;
#[doc = " The camera's exposure compensation is -3.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_3_0:
    E_DjiCameraManagerExposureCompensation = 7;
#[doc = " The camera's exposure compensation is -2.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_2_7:
    E_DjiCameraManagerExposureCompensation = 8;
#[doc = " The camera's exposure compensation is -2.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_2_3:
    E_DjiCameraManagerExposureCompensation = 9;
#[doc = " The camera's exposure compensation is -2.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_2_0:
    E_DjiCameraManagerExposureCompensation = 10;
#[doc = " The camera's exposure compensation is -1.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_1_7:
    E_DjiCameraManagerExposureCompensation = 11;
#[doc = " The camera's exposure compensation is -1.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_1_3:
    E_DjiCameraManagerExposureCompensation = 12;
#[doc = " The camera's exposure compensation is -1.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_1_0:
    E_DjiCameraManagerExposureCompensation = 13;
#[doc = " The camera's exposure compensation is -0.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_0_7:
    E_DjiCameraManagerExposureCompensation = 14;
#[doc = " The camera's exposure compensation is -0.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_0_3:
    E_DjiCameraManagerExposureCompensation = 15;
#[doc = " The camera's exposure compensation is 0.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_N_0_0:
    E_DjiCameraManagerExposureCompensation = 16;
#[doc = " The camera's exposure compensation is +0.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_0_3:
    E_DjiCameraManagerExposureCompensation = 17;
#[doc = " The camera's exposure compensation is +0.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_0_7:
    E_DjiCameraManagerExposureCompensation = 18;
#[doc = " The camera's exposure compensation is +1.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_1_0:
    E_DjiCameraManagerExposureCompensation = 19;
#[doc = " The camera's exposure compensation is +1.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_1_3:
    E_DjiCameraManagerExposureCompensation = 20;
#[doc = " The camera's exposure compensation is +1.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_1_7:
    E_DjiCameraManagerExposureCompensation = 21;
#[doc = " The camera's exposure compensation is +2.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_2_0:
    E_DjiCameraManagerExposureCompensation = 22;
#[doc = " The camera's exposure compensation is +2.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_2_3:
    E_DjiCameraManagerExposureCompensation = 23;
#[doc = " The camera's exposure compensation is +2.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_2_7:
    E_DjiCameraManagerExposureCompensation = 24;
#[doc = " The camera's exposure compensation is +3.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_3_0:
    E_DjiCameraManagerExposureCompensation = 25;
#[doc = " The camera's exposure compensation is +3.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_3_3:
    E_DjiCameraManagerExposureCompensation = 26;
#[doc = " The camera's exposure compensation is +3.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_3_7:
    E_DjiCameraManagerExposureCompensation = 27;
#[doc = " The camera's exposure compensation is +4.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_4_0:
    E_DjiCameraManagerExposureCompensation = 28;
#[doc = " The camera's exposure compensation is +4.3ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_4_3:
    E_DjiCameraManagerExposureCompensation = 29;
#[doc = " The camera's exposure compensation is +4.7ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_4_7:
    E_DjiCameraManagerExposureCompensation = 30;
#[doc = " The camera's exposure compensation is +5.0ev."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_P_5_0:
    E_DjiCameraManagerExposureCompensation = 31;
#[doc = " The camera's exposure compensation is fixed by the camera."]
pub const E_DjiCameraManagerExposureCompensation_DJI_CAMERA_MANAGER_EXPOSURE_COMPENSATION_FIXED:
    E_DjiCameraManagerExposureCompensation = 255;
#[doc = " @brief CameraModule exposure compensation."]
pub type E_DjiCameraManagerExposureCompensation = ::std::os::raw::c_uint;
#[doc = " \tThe Aperture value is f/1.6. It is only supported by Z30\ncamera."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_1_DOT_6:
    E_DjiCameraManagerAperture = 160;
#[doc = " The Aperture value is f/1.7."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_1_DOT_7:
    E_DjiCameraManagerAperture = 170;
#[doc = " The Aperture value is f/1.8."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_1_DOT_8:
    E_DjiCameraManagerAperture = 180;
#[doc = " The Aperture value is f/2."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_2: E_DjiCameraManagerAperture =
    200;
#[doc = " The Aperture value is f/2.2."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_2_DOT_2:
    E_DjiCameraManagerAperture = 220;
#[doc = " The Aperture value is f/2.4. It is only supported by Z30 camera."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_2_DOT_4:
    E_DjiCameraManagerAperture = 240;
#[doc = " The Aperture value is f/2.5."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_2_DOT_5:
    E_DjiCameraManagerAperture = 250;
#[doc = " The Aperture value is f/2.6."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_2_DOT_6:
    E_DjiCameraManagerAperture = 260;
#[doc = " The Aperture value is f/2.8."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_2_DOT_8:
    E_DjiCameraManagerAperture = 280;
#[doc = " The Aperture value is f/3.2."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_3_DOT_2:
    E_DjiCameraManagerAperture = 320;
#[doc = " The Aperture value is f/3.4."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_3_DOT_4:
    E_DjiCameraManagerAperture = 340;
#[doc = " The Aperture value is f/3.5."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_3_DOT_5:
    E_DjiCameraManagerAperture = 350;
#[doc = " The Aperture value is f/4."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_4: E_DjiCameraManagerAperture =
    400;
#[doc = " The Aperture value is f/4.5."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_4_DOT_5:
    E_DjiCameraManagerAperture = 450;
#[doc = " The Aperture value is f/4.8."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_4_DOT_8:
    E_DjiCameraManagerAperture = 480;
#[doc = " The Aperture value is f/5."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_5: E_DjiCameraManagerAperture =
    500;
#[doc = " The Aperture value is f/5.6."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_5_DOT_6:
    E_DjiCameraManagerAperture = 560;
#[doc = " The Aperture value is f/6.3."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_6_DOT_3:
    E_DjiCameraManagerAperture = 630;
#[doc = " The Aperture value is f/6.8."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_6_DOT_8:
    E_DjiCameraManagerAperture = 680;
#[doc = " The Aperture value is f/7.1."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_7_DOT_1:
    E_DjiCameraManagerAperture = 710;
#[doc = " The Aperture value is f/8."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_8: E_DjiCameraManagerAperture =
    800;
#[doc = " The Aperture value is f/9."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_9: E_DjiCameraManagerAperture =
    900;
#[doc = " The Aperture value is f/9.6."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_9_DOT_6:
    E_DjiCameraManagerAperture = 960;
#[doc = " The Aperture value is f/10."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_10: E_DjiCameraManagerAperture =
    1000;
#[doc = " The Aperture value is f/11."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_11: E_DjiCameraManagerAperture =
    1100;
#[doc = " The Aperture value is f/13."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_13: E_DjiCameraManagerAperture =
    1300;
#[doc = " The Aperture value is f/14."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_14: E_DjiCameraManagerAperture =
    1400;
#[doc = " The Aperture value is f/16."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_16: E_DjiCameraManagerAperture =
    1600;
#[doc = " The Aperture value is f/18."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_18: E_DjiCameraManagerAperture =
    1800;
#[doc = " The Aperture value is f/19."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_19: E_DjiCameraManagerAperture =
    1900;
#[doc = " The Aperture value is f/20."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_20: E_DjiCameraManagerAperture =
    2000;
#[doc = " The Aperture value is f/22."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_22: E_DjiCameraManagerAperture =
    2200;
#[doc = " The Aperture value is Unknown."]
pub const E_DjiCameraManagerAperture_DJI_CAMERA_MANAGER_APERTURE_F_UNKNOWN:
    E_DjiCameraManagerAperture = 65535;
#[doc = " @brief CameraModule aperture values.\n  @note X5, X5R, Z30, Phantom 4 Pro camera, X4S and X5S support this\n setting."]
pub type E_DjiCameraManagerAperture = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerRecordingControl_DJI_CAMERA_MANAGER_RECORDING_CONTROL_STOP:
    E_DjiCameraManagerRecordingControl = 0;
pub const E_DjiCameraManagerRecordingControl_DJI_CAMERA_MANAGER_RECORDING_CONTROL_BEGIN:
    E_DjiCameraManagerRecordingControl = 1;
pub const E_DjiCameraManagerRecordingControl_DJI_CAMERA_MANAGER_RECORDING_CONTROL_PAUSE:
    E_DjiCameraManagerRecordingControl = 2;
pub const E_DjiCameraManagerRecordingControl_DJI_CAMERA_MANAGER_RECORDING_CONTROL_RESUME:
    E_DjiCameraManagerRecordingControl = 3;
pub type E_DjiCameraManagerRecordingControl = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerFileListCountPerSlice_DJI_CAMERA_MANAGER_FILE_LIST_COUNT_60_PER_SLICE : E_DjiCameraManagerFileListCountPerSlice = 60 ;
pub const E_DjiCameraManagerFileListCountPerSlice_DJI_CAMERA_MANAGER_FILE_LIST_COUNT_120_PER_SLICE : E_DjiCameraManagerFileListCountPerSlice = 120 ;
pub const E_DjiCameraManagerFileListCountPerSlice_DJI_CAMERA_MANAGER_FILE_LIST_COUNT_ALL_PER_SLICE : E_DjiCameraManagerFileListCountPerSlice = 65535 ;
pub type E_DjiCameraManagerFileListCountPerSlice = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerStreamSource_DJI_CAMERA_MANAGER_SOURCE_DEFAULT_CAM:
    E_DjiCameraManagerStreamSource = 0;
pub const E_DjiCameraManagerStreamSource_DJI_CAMERA_MANAGER_SOURCE_WIDE_CAM:
    E_DjiCameraManagerStreamSource = 1;
pub const E_DjiCameraManagerStreamSource_DJI_CAMERA_MANAGER_SOURCE_ZOOM_CAM:
    E_DjiCameraManagerStreamSource = 2;
pub const E_DjiCameraManagerStreamSource_DJI_CAMERA_MANAGER_SOURCE_IR_CAM:
    E_DjiCameraManagerStreamSource = 3;
pub const E_DjiCameraManagerStreamSource_DJI_CAMERA_MANAGER_SOURCE_VISIBLE_CAM:
    E_DjiCameraManagerStreamSource = 7;
pub type E_DjiCameraManagerStreamSource = ::std::os::raw::c_uint;
pub use self::E_DjiCameraManagerStreamSource as E_DjiCameraManagerStreamStorage;
pub const E_DjiCameraManagerNightSceneMode_DJI_CAMERA_MANAGER_NIGHT_SCENE_MODE_DISABLE:
    E_DjiCameraManagerNightSceneMode = 0;
pub const E_DjiCameraManagerNightSceneMode_DJI_CAMERA_MANAGER_NIGHT_SCENE_MODE_ENABLE:
    E_DjiCameraManagerNightSceneMode = 1;
pub const E_DjiCameraManagerNightSceneMode_DJI_CAMERA_MANAGER_NIGHT_SCENE_MODE_AUTO:
    E_DjiCameraManagerNightSceneMode = 2;
pub type E_DjiCameraManagerNightSceneMode = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerCaptureOrRecording_DJI_CAMERA_MANAGER_CAPTURE_OR_RECORDING_CAPTURE:
    E_DjiCameraManagerCaptureOrRecording = 0;
pub const E_DjiCameraManagerCaptureOrRecording_DJI_CAMERA_MANAGER_CAPTURE_OR_RECORDING_RECORDING:
    E_DjiCameraManagerCaptureOrRecording = 1;
pub type E_DjiCameraManagerCaptureOrRecording = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerExpandNameType_DJI_CAMERA_MANAGER_EXPAND_NAME_TYPE_FILE:
    E_DjiCameraManagerExpandNameType = 1;
pub const E_DjiCameraManagerExpandNameType_DJI_CAMERA_MANAGER_EXPAND_NAME_TYPE_DIR:
    E_DjiCameraManagerExpandNameType = 2;
pub type E_DjiCameraManagerExpandNameType = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerPhotoRatio_DJI_CAMERA_MANAGER_PHOTO_RATIO_4X3:
    E_DjiCameraManagerPhotoRatio = 0;
pub const E_DjiCameraManagerPhotoRatio_DJI_CAMERA_MANAGER_PHOTO_RATIO_16X9:
    E_DjiCameraManagerPhotoRatio = 1;
pub const E_DjiCameraManagerPhotoRatio_DJI_CAMERA_MANAGER_PHOTO_RATIO_3X2:
    E_DjiCameraManagerPhotoRatio = 2;
pub const E_DjiCameraManagerPhotoRatio_DJI_CAMERA_MANAGER_PHOTO_RATIO_1X1:
    E_DjiCameraManagerPhotoRatio = 3;
pub const E_DjiCameraManagerPhotoRatio_DJI_CAMERA_MANAGER_PHOTO_RATIO_18X3:
    E_DjiCameraManagerPhotoRatio = 4;
pub const E_DjiCameraManagerPhotoRatio_DJI_CAMERA_MANAGER_PHOTO_RATIO_5X4:
    E_DjiCameraManagerPhotoRatio = 5;
pub type E_DjiCameraManagerPhotoRatio = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerFirmwareVersion {
    pub firmware_version: [u8; 4usize],
}
#[doc = " @brief Tap zoom target point data struct, used by user."]
pub type T_DjiCameraManagerTapZoomPosData = T_DjiCameraPointInScreen;
#[doc = " @brief Tap focus target point data struct, used by user."]
pub type T_DjiCameraManagerFocusPosData = T_DjiCameraPointInScreen;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerOpticalZoomParam {
    pub currentOpticalZoomFactor: dji_f32_t,
    pub maxOpticalZoomFactor: dji_f32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerFileCreateTime {
    pub second: u8,
    pub minute: u8,
    pub hour: u8,
    pub day: u8,
    pub month: u8,
    pub year: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiCameraManagerFileAttributeData {
    pub __bindgen_anon_1: T_DjiCameraManagerFileAttributeData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DjiCameraManagerFileAttributeData__bindgen_ty_1 {
    pub photoAttribute: T_DjiCameraManagerFileAttributeData__bindgen_ty_1__bindgen_ty_1,
    pub videoAttribute: T_DjiCameraManagerFileAttributeData__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerFileAttributeData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved: [u8; 12usize],
}
impl T_DjiCameraManagerFileAttributeData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn attributePhotoReserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_attributePhotoReserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn attributePhotoRatio(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_attributePhotoRatio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn attributePhotoRotation(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_attributePhotoRotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        attributePhotoReserved: u32,
        attributePhotoRatio: u32,
        attributePhotoRotation: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let attributePhotoReserved: u32 =
                unsafe { ::std::mem::transmute(attributePhotoReserved) };
            attributePhotoReserved as u64
        });
        __bindgen_bitfield_unit.set(22usize, 8u8, {
            let attributePhotoRatio: u32 = unsafe { ::std::mem::transmute(attributePhotoRatio) };
            attributePhotoRatio as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let attributePhotoRotation: u32 =
                unsafe { ::std::mem::transmute(attributePhotoRotation) };
            attributePhotoRotation as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerFileAttributeData__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved: [u8; 12usize],
}
impl T_DjiCameraManagerFileAttributeData__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn attributeVideoDuration(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_attributeVideoDuration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn attributeVideoFramerate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_attributeVideoFramerate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn attributeVideoRotation(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_attributeVideoRotation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn attributeVideoResolution(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_attributeVideoResolution(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        attributeVideoDuration: u32,
        attributeVideoFramerate: u32,
        attributeVideoRotation: u32,
        attributeVideoResolution: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let attributeVideoDuration: u32 =
                unsafe { ::std::mem::transmute(attributeVideoDuration) };
            attributeVideoDuration as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let attributeVideoFramerate: u32 =
                unsafe { ::std::mem::transmute(attributeVideoFramerate) };
            attributeVideoFramerate as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let attributeVideoRotation: u32 =
                unsafe { ::std::mem::transmute(attributeVideoRotation) };
            attributeVideoRotation as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let attributeVideoResolution: u32 =
                unsafe { ::std::mem::transmute(attributeVideoResolution) };
            attributeVideoResolution as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for T_DjiCameraManagerFileAttributeData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DjiCameraManagerFileAttributeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiCameraManagerSubFileListInfo {
    pub fileName: [::std::os::raw::c_char; 256usize],
    pub fileSize: u32,
    pub fileIndex: u32,
    pub createTime: T_DjiCameraManagerFileCreateTime,
    pub type_: E_DjiCameraMediaFileSubType,
    pub attributeData: T_DjiCameraManagerFileAttributeData,
}
impl Default for T_DjiCameraManagerSubFileListInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiCameraManagerFileListInfo {
    pub fileName: [::std::os::raw::c_char; 256usize],
    pub fileSize: u32,
    pub fileIndex: u32,
    pub createTime: T_DjiCameraManagerFileCreateTime,
    pub type_: E_DjiCameraMediaFileType,
    pub attributeData: T_DjiCameraManagerFileAttributeData,
    pub subFileListTotalNum: u8,
    pub subFileListInfo: *mut T_DjiCameraManagerSubFileListInfo,
}
impl Default for T_DjiCameraManagerFileListInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerFileList {
    pub totalCount: u16,
    pub fileListInfo: *mut T_DjiCameraManagerFileListInfo,
}
impl Default for T_DjiCameraManagerFileList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerSliceConfig {
    pub sliceStartIndex: u16,
    pub countPerSlice: E_DjiCameraManagerFileListCountPerSlice,
}
impl Default for T_DjiCameraManagerSliceConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const E_DjiDownloadFileEvent_DJI_DOWNLOAD_FILE_EVENT_START: E_DjiDownloadFileEvent = 0;
pub const E_DjiDownloadFileEvent_DJI_DOWNLOAD_FILE_EVENT_TRANSFER: E_DjiDownloadFileEvent = 1;
pub const E_DjiDownloadFileEvent_DJI_DOWNLOAD_FILE_EVENT_END: E_DjiDownloadFileEvent = 2;
pub const E_DjiDownloadFileEvent_DJI_DOWNLOAD_FILE_EVENT_START_TRANSFER_END:
    E_DjiDownloadFileEvent = 3;
pub type E_DjiDownloadFileEvent = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerVideoResolution_DJI_CAMERA_MANAGER_VIDEO_RESOLUTION_640X480P:
    E_DjiCameraManagerVideoResolution = 0;
pub const E_DjiCameraManagerVideoResolution_DJI_CAMERA_MANAGER_VIDEO_RESOLUTION_1280X640P:
    E_DjiCameraManagerVideoResolution = 2;
pub const E_DjiCameraManagerVideoResolution_DJI_CAMERA_MANAGER_VIDEO_RESOLUTION_1280X720P:
    E_DjiCameraManagerVideoResolution = 4;
pub const E_DjiCameraManagerVideoResolution_DJI_CAMERA_MANAGER_VIDEO_RESOLUTION_1920X1080P:
    E_DjiCameraManagerVideoResolution = 10;
pub const E_DjiCameraManagerVideoResolution_DJI_CAMERA_MANAGER_VIDEO_RESOLUTION_3840X2160P:
    E_DjiCameraManagerVideoResolution = 16;
pub type E_DjiCameraManagerVideoResolution = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerVideoFrameRate_DJI_CAMERA_MANAGER_VIDEO_FRAME_RATE_15FPS:
    E_DjiCameraManagerVideoFrameRate = 0;
pub const E_DjiCameraManagerVideoFrameRate_DJI_CAMERA_MANAGER_VIDEO_FRAME_RATE_25FPS:
    E_DjiCameraManagerVideoFrameRate = 2;
pub const E_DjiCameraManagerVideoFrameRate_DJI_CAMERA_MANAGER_VIDEO_FRAME_RATE_30FPS:
    E_DjiCameraManagerVideoFrameRate = 3;
pub const E_DjiCameraManagerVideoFrameRate_DJI_CAMERA_MANAGER_VIDEO_FRAME_RATE_60FPS:
    E_DjiCameraManagerVideoFrameRate = 6;
pub type E_DjiCameraManagerVideoFrameRate = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerPhotoStorageFormat_DJI_CAMERA_MANAGER_PHOTO_STORAGE_FORMAT_RAW:
    E_DjiCameraManagerPhotoStorageFormat = 0;
pub const E_DjiCameraManagerPhotoStorageFormat_DJI_CAMERA_MANAGER_PHOTO_STORAGE_FORMAT_JPEG:
    E_DjiCameraManagerPhotoStorageFormat = 1;
pub const E_DjiCameraManagerPhotoStorageFormat_DJI_CAMERA_MANAGER_PHOTO_STORAGE_FORMAT_RAW_JPEG:
    E_DjiCameraManagerPhotoStorageFormat = 2;
pub const E_DjiCameraManagerPhotoStorageFormat_DJI_CAMERA_MANAGER_PHOTO_STORAGE_FORMAT_YUV:
    E_DjiCameraManagerPhotoStorageFormat = 3;
pub const E_DjiCameraManagerPhotoStorageFormat_DJI_CAMERA_MANAGER_PHOTO_STORAGE_FORMAT_RJPEG:
    E_DjiCameraManagerPhotoStorageFormat = 7;
pub type E_DjiCameraManagerPhotoStorageFormat = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerVideoStorageFormat_DJI_CAMERA_MANAGER_VIDEO_STORAGE_FORMAT_MOV:
    E_DjiCameraManagerVideoStorageFormat = 0;
pub const E_DjiCameraManagerVideoStorageFormat_DJI_CAMERA_MANAGER_VIDEO_STORAGE_FORMAT_MP4:
    E_DjiCameraManagerVideoStorageFormat = 1;
pub type E_DjiCameraManagerVideoStorageFormat = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerMeteringMode_DJI_CAMERA_MANAGER_METERING_MODE_CENTRAL:
    E_DjiCameraManagerMeteringMode = 0;
pub const E_DjiCameraManagerMeteringMode_DJI_CAMERA_MANAGER_METERING_MODE_AVERAGE:
    E_DjiCameraManagerMeteringMode = 1;
pub const E_DjiCameraManagerMeteringMode_DJI_CAMERA_MANAGER_METERING_MODE_SPOT:
    E_DjiCameraManagerMeteringMode = 2;
pub type E_DjiCameraManagerMeteringMode = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerFfcMode_DJI_CAMERA_MANAGER_FFC_MODE_MANUAL: E_DjiCameraManagerFfcMode =
    0;
pub const E_DjiCameraManagerFfcMode_DJI_CAMERA_MANAGER_FFC_MODE_AUTO: E_DjiCameraManagerFfcMode = 1;
pub type E_DjiCameraManagerFfcMode = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerIrGainMode_DJI_CAMERA_MANAGER_IR_GAIN_MODE_AUTO:
    E_DjiCameraManagerIrGainMode = 0;
pub const E_DjiCameraManagerIrGainMode_DJI_CAMERA_MANAGER_IR_GAIN_MODE_LOW:
    E_DjiCameraManagerIrGainMode = 1;
pub const E_DjiCameraManagerIrGainMode_DJI_CAMERA_MANAGER_IR_GAIN_MODE_HIGH:
    E_DjiCameraManagerIrGainMode = 2;
pub type E_DjiCameraManagerIrGainMode = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerCapturingState_DJI_CAMERA_MANAGER_CAPTURING_STATE_IDLE:
    E_DjiCameraManagerCapturingState = 0;
pub const E_DjiCameraManagerCapturingState_DJI_CAMERA_MANAGER_CAPTURING_STATE_SINGLE:
    E_DjiCameraManagerCapturingState = 1;
pub const E_DjiCameraManagerCapturingState_DJI_CAMERA_MANAGER_CAPTURING_STATE_MULTI:
    E_DjiCameraManagerCapturingState = 2;
pub type E_DjiCameraManagerCapturingState = ::std::os::raw::c_uint;
pub const E_DjiCameraManagerRecordingState_DJI_CAMERA_MANAGER_RECORDING_STATE_IDLE:
    E_DjiCameraManagerRecordingState = 0;
pub const E_DjiCameraManagerRecordingState_DJI_CAMERA_MANAGER_RECORDING_STATE_STARTING:
    E_DjiCameraManagerRecordingState = 1;
pub const E_DjiCameraManagerRecordingState_DJI_CAMERA_MANAGER_RECORDING_STATE_RECORDING:
    E_DjiCameraManagerRecordingState = 2;
pub const E_DjiCameraManagerRecordingState_DJI_CAMERA_MANAGER_RECORDING_STATE_STOPPING:
    E_DjiCameraManagerRecordingState = 3;
pub type E_DjiCameraManagerRecordingState = ::std::os::raw::c_uint;
#[doc = " @brief: when the remote control is in split-screen mode, the coordinate range of the x-axis is 0-0.5."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerPointThermometryCoordinate {
    pub pointX: dji_f32_t,
    #[doc = " x-coordinate of point thermometry, range: 0-1"]
    pub pointY: dji_f32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerAreaThermometryCoordinate {
    pub areaTempLtX: dji_f32_t,
    #[doc = " x-coordinate of the upper left corner of the area thermometry, range: 0-1"]
    pub areaTempLtY: dji_f32_t,
    #[doc = " y-coordinate of the upper left corner of the area thermometry, range: 0-1"]
    pub areaTempRbX: dji_f32_t,
    #[doc = " x-coordinate of the lower right corner of the area thermometry, range: 0-1"]
    pub areaTempRbY: dji_f32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerPointThermometryData {
    pub pointX: dji_f32_t,
    #[doc = " x-coordinate of point thermometry, range: 0-1"]
    pub pointY: dji_f32_t,
    #[doc = " y-coordinate of point thermometry, range: 0-1"]
    pub pointTemperature: dji_f32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerAreaThermometryData {
    pub areaTempLtX: dji_f32_t,
    #[doc = " x_coordinate of the upper left corner of the current thermometry area"]
    pub areaTempLtY: dji_f32_t,
    #[doc = " y_coordinate of the upper left corner of the current thermometry area"]
    pub areaTempRbX: dji_f32_t,
    #[doc = " x_coordinate of the lower right corner of the current thermometry area"]
    pub areaTempRbY: dji_f32_t,
    #[doc = " y_coordinate of the lower right corner of the current thermometry area"]
    pub areaAveTemp: dji_f32_t,
    #[doc = " The average temperature of the current thermometry area"]
    pub areaMinTemp: dji_f32_t,
    #[doc = " The minimum temperature of the current thermometry area"]
    pub areaMaxTemp: dji_f32_t,
    #[doc = " The maximum temperature of the current thermometry area"]
    pub areaMinTempPointX: dji_f32_t,
    #[doc = " x_coordinate of the minimum temperature in the thermometry area"]
    pub areaMinTempPointY: dji_f32_t,
    #[doc = " y_coordinate of the minimum temperature in the thermometry area"]
    pub areaMaxTempPointX: dji_f32_t,
    #[doc = " x_coordinate of the maximum temperature in the thermometry area"]
    pub areaMaxTempPointY: dji_f32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiDownloadFilePacketInfo {
    pub downloadFileEvent: E_DjiDownloadFileEvent,
    pub fileType: u8,
    pub fileIndex: u32,
    pub fileSize: u32,
    pub progressInPercent: dji_f32_t,
}
impl Default for T_DjiDownloadFilePacketInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerLaserRangingInfo {
    pub longitude: dji_f64_t,
    #[doc = " Range: [-180,180]"]
    pub latitude: dji_f64_t,
    #[doc = " Range: [-90,90]"]
    pub altitude: i32,
    #[doc = " Unit: 0.1m"]
    pub distance: i32,
    #[doc = " Unit: 0.1m"]
    pub screenX: i16,
    #[doc = " Unit: 0.1%"]
    pub screenY: i16,
    #[doc = " Unit: 0.1%"]
    pub enable_lidar: bool,
    pub exception: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerStreamList {
    pub size: u32,
    pub streamSource: [E_DjiCameraManagerStreamSource; 4usize],
    pub streamStorage: [E_DjiCameraManagerStreamStorage; 4usize],
}
impl Default for T_DjiCameraManagerStreamList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerVideoFormat {
    pub videoResolution: E_DjiCameraManagerVideoResolution,
    pub videoFrameRate: E_DjiCameraManagerVideoFrameRate,
}
impl Default for T_DjiCameraManagerVideoFormat {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiCameraManagerRangeList {
    pub size: u8,
    pub __bindgen_anon_1: T_DjiCameraManagerRangeList__bindgen_ty_1,
    pub minValue: u32,
    pub maxValue: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DjiCameraManagerRangeList__bindgen_ty_1 {
    pub photoStorageFormat: [E_DjiCameraManagerPhotoStorageFormat; 16usize],
    pub videoStorageFormat: [E_DjiCameraManagerVideoStorageFormat; 16usize],
    pub photoRatioFormat: [E_DjiCameraManagerPhotoRatio; 16usize],
    pub streamSource: [E_DjiCameraManagerStreamSource; 16usize],
    pub streamStorage: [E_DjiCameraManagerStreamStorage; 16usize],
    pub nightSceneMode: [E_DjiCameraManagerNightSceneMode; 16usize],
}
impl Default for T_DjiCameraManagerRangeList__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DjiCameraManagerRangeList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerIrTempMeterRange {
    pub lowGainTempMin: f64,
    pub lowGainTempMax: f64,
    pub highGainTempMin: f64,
    pub highGainTempMax: f64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerStorageInfo {
    pub totalCapacity: u32,
    pub remainCapacity: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraManagerPointCloudHeader {
    pub flag: u32,
    pub seqNum: u32,
    pub timestamp: u64,
    pub dataByte: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerPointXYZRGBInfo {
    pub x: dji_f32_t,
    pub y: dji_f32_t,
    pub z: dji_f32_t,
    pub intensity: u8,
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiCameraManagerColorPointCloud {
    pub pointCloudHeader: T_DjiCameraManagerPointCloudHeader,
    pub crc_header: u32,
    pub crc_rest: u32,
    pub points: [T_DjiCameraManagerPointXYZRGBInfo; 1usize],
}
pub type DjiCameraManagerDownloadFileDataCallback = ::std::option::Option<
    unsafe extern "C" fn(
        packetInfo: T_DjiDownloadFilePacketInfo,
        data: *const u8,
        dataLen: u16,
    ) -> T_DjiReturnCode,
>;
extern "C" {
    #[doc = " @brief Initialise camera manager module, and user should call this function\n before using camera manager features.\n @return Execution result."]
    pub fn DjiCameraManager_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialise camera manager module.\n @return Execution result."]
    pub fn DjiCameraManager_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera type of the selected camera mounted position.\n @param position: camera mounted position\n @param cameraType: refer to E_DjiCameraType.\n @return Execution result."]
    pub fn DjiCameraManager_GetCameraType(
        position: E_DjiMountPosition,
        cameraType: *mut E_DjiCameraType,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera firmware version of the selected camera mounted position.\n @param position: camera mounted position\n @param firmwareVersion: refer to T_DjiCameraManagerFirmwareVersion.\n @return Execution result."]
    pub fn DjiCameraManager_GetFirmwareVersion(
        position: E_DjiMountPosition,
        firmwareVersion: *mut T_DjiCameraManagerFirmwareVersion,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera connection status.\n @param position: camera mounted position\n @param connectStatus: returned value of connection status\n @return Execution result."]
    pub fn DjiCameraManager_GetCameraConnectStatus(
        position: E_DjiMountPosition,
        connectStatus: *mut bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera working mode of the selected camera mounted position.\n @note Set the camera's work mode to options such as taking pictures, recording video,\n playback, or downloading. Please note that you cannot change the mode when a certain\n task is executing. This action takes about 1-2 s.\n @param position: camera mounted position\n @param workMode: refer to E_DjiCameraManagerWorkMode.\n @return Execution result."]
    pub fn DjiCameraManager_SetMode(
        position: E_DjiMountPosition,
        workMode: E_DjiCameraManagerWorkMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera working mode of the selected camera mounted position.\n @param position: camera mounted position\n @param workMode: refer to E_DjiCameraManagerWorkMode.\n @return Execution result."]
    pub fn DjiCameraManager_GetMode(
        position: E_DjiMountPosition,
        workMode: *mut E_DjiCameraManagerWorkMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera shoot mode of the selected camera mounted position.\n @param position: camera mounted position\n @param mode: refer to E_DjiCameraManagerShootPhotoMode.\n @return Execution result."]
    pub fn DjiCameraManager_SetShootPhotoMode(
        position: E_DjiMountPosition,
        mode: E_DjiCameraManagerShootPhotoMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera shoot mode of the selected camera mounted position.\n @param position: camera mounted position\n @param mode: refer to E_DjiCameraManagerShootPhotoMode.\n @return Execution result."]
    pub fn DjiCameraManager_GetShootPhotoMode(
        position: E_DjiMountPosition,
        takePhotoMode: *mut E_DjiCameraManagerShootPhotoMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Start shooting photo.\n @note Camera must be in ShootPhoto mode. For thermal imaging cameras,\n it is allowed to take a single photo while recording video. Check the SD\n card's capacity before using this method to ensure there is enough space.\n @param position: camera mounted position\n @param mode: refer to E_DjiCameraManagerShootPhotoMode.\n @return Execution result."]
    pub fn DjiCameraManager_StartShootPhoto(
        position: E_DjiMountPosition,
        mode: E_DjiCameraManagerShootPhotoMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Stop shooting photo.\n @note Camera must be in ShootPhoto mode and the shoot mode is either\n Interval or Time-lapse. If set to single shot mode, the camera will\n automatically stop after taking the photo.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_StopShootPhoto(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera capturing state.\n @note This API is not supported by L1/P1/M3D/M3TD models.\n @param position: camera mounted position\n @param capturingState: result of getting, see E_DjiCameraManagerCapturingState.\n @return Execution result."]
    pub fn DjiCameraManager_GetCapturingState(
        position: E_DjiMountPosition,
        capturingState: *mut E_DjiCameraManagerCapturingState,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set the burst count for burst shooting mode.\n @param position: camera mounted position\n @param count: refer to E_DjiCameraBurstCount.\n @return Execution result."]
    pub fn DjiCameraManager_SetPhotoBurstCount(
        position: E_DjiMountPosition,
        count: E_DjiCameraBurstCount,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set the parameters for INTERVAL shooting mode.\n @note In this mode, the camera captures a photo, waits a specified interval\n of time, then captures another photo, continuing until the set number of\n photos is reached. Supported by thermal imaging cameras, too.\n @param position: camera mounted position\n @param intervalSetting: refer to T_DjiCameraPhotoTimeIntervalSettings.\n @return Execution result."]
    pub fn DjiCameraManager_SetPhotoTimeIntervalSettings(
        position: E_DjiMountPosition,
        intervalSetting: T_DjiCameraPhotoTimeIntervalSettings,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the parameters for INTERVAL shooting mode.\n @param position: camera mounted position\n @param intervalSetting: refer to T_DjiCameraPhotoTimeIntervalSettings.\n @return Execution result."]
    pub fn DjiCameraManager_GetPhotoTimeIntervalSettings(
        position: E_DjiMountPosition,
        intervalSetting: *mut T_DjiCameraPhotoTimeIntervalSettings,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the remaining time of interval shooting.\n @note Not supported by L1/P1/M3D/M3TD models.\n @param position: camera mounted position\n @param remainTime: time in seconds.\n @return Execution result."]
    pub fn DjiCameraManager_GetIntervalShootingRemainTime(
        position: E_DjiMountPosition,
        remainTime: *mut u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera focus mode of the selected camera mounted position.\n @note Set the lens focus mode. In auto focus mode, the target\n point is the focal point. In manual focus mode, if focus assist is\n enabled, it adjusts focus in the zoomed-out area.\n @param position: camera mounted position\n @param focusMode: refer to E_DjiCameraManagerFocusMode.\n @return Execution result."]
    pub fn DjiCameraManager_SetFocusMode(
        position: E_DjiMountPosition,
        focusMode: E_DjiCameraManagerFocusMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera focus mode of the selected camera mounted position.\n @param position: camera mounted position\n @param focusMode: refer to E_DjiCameraManagerFocusMode.\n @return Execution result."]
    pub fn DjiCameraManager_GetFocusMode(
        position: E_DjiMountPosition,
        focusMode: *mut E_DjiCameraManagerFocusMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera focus point of the selected camera mounted position.\n @note  Sets the target point for focusing. In auto mode, this is the focal\n point. In manual mode with focus assist enabled, it's the zoomed-out area.\n @param position: camera mounted position\n @param focusPosData: refer to T_DjiCameraManagerFocusPosData.\n @return Execution result."]
    pub fn DjiCameraManager_SetFocusTarget(
        position: E_DjiMountPosition,
        focusPosData: T_DjiCameraManagerFocusPosData,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera focus point of the selected camera mounted position.\n @param position: camera mounted position\n @param focusPosData: refer to T_DjiCameraManagerFocusPosData.\n @return Execution result."]
    pub fn DjiCameraManager_GetFocusTarget(
        position: E_DjiMountPosition,
        tapFocusPos: *mut T_DjiCameraManagerFocusPosData,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Start camera optical zooming of the selected camera mounted position.\n @note Changes the lens's focal length in the specified direction at a specified\n speed. Zooming stops at the lens's max or min focal length or when\n StopContinuousOpticalZoom is called.\n @param position: camera mounted position\n @param zoomDirection: optical zoom direction, refer to E_DjiCameraZoomDirection.\n @param zoomSpeed: optical zoom direction, refer to E_DjiCameraZoomSpeed.\n @return Execution result."]
    pub fn DjiCameraManager_StartContinuousOpticalZoom(
        position: E_DjiMountPosition,
        zoomDirection: E_DjiCameraZoomDirection,
        zoomSpeed: E_DjiCameraZoomSpeed,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Stop the ongoing optical zoom operation of the selected camera mounted position.\n @note Should be called to halt the focal length change initiated by\n DjiCameraManager_StartContinuousOpticalZoom.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_StopContinuousOpticalZoom(
        position: E_DjiMountPosition,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set target zoom factor for optical zooming of the selected camera mounted position.\n @note This interface sets the zoom to the specified target value.\n @param position: camera mounted position\n @param zoomDirection: optical zoom direction, refer to E_DjiCameraZoomDirection.\n @param factor: target zoom factor.\n @return Execution result."]
    pub fn DjiCameraManager_SetOpticalZoomParam(
        position: E_DjiMountPosition,
        zoomDirection: E_DjiCameraZoomDirection,
        factor: dji_f32_t,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get parameters for camera optical zooming of the selected camera mounted position.\n @param position: camera mounted position\n @param opticalZoomParam: refer to T_DjiCameraManagerOpticalZoomParam.\n @return Execution result."]
    pub fn DjiCameraManager_GetOpticalZoomParam(
        position: E_DjiMountPosition,
        opticalZoomParam: *mut T_DjiCameraManagerOpticalZoomParam,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief  Set target zoom factor for infrared zooming of the selected camera mounted position.\n @param position: camera mounted position\n @param factor: target zoom factor.\n @return Execution result."]
    pub fn DjiCameraManager_SetInfraredZoomParam(
        position: E_DjiMountPosition,
        factor: dji_f32_t,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable the tap-zoom function for the selected camera mounted position.\n @note TapZoomAtTarget can only be called when tap-zoom is enabled.\n @param position: camera mounted position\n @param param: enable/disable\n @return Execution result."]
    pub fn DjiCameraManager_SetTapZoomEnabled(
        position: E_DjiMountPosition,
        param: bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get status of camera's tap-zoom function of the selected camera mounted position.\n @param position: camera mounted position\n @param param: enable/disable\n @return Execution result."]
    pub fn DjiCameraManager_GetTapZoomEnabled(
        position: E_DjiMountPosition,
        param: *mut bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's tap-zoom multiplier of the selected camera mounted position.\n @note The final zoom scale during a tap-zoom action will be:\n Current Zoom Scale x Multiplier.\n @param position: camera mounted position\n @param tapZoomMultiplier: The multiplier range is [1,5]. A multiplier of 1 will not change the zoom.\n hen the multiplier is 1, the zoom scale will not change during TapZoom.\n @return Execution result."]
    pub fn DjiCameraManager_SetTapZoomMultiplier(
        position: E_DjiMountPosition,
        tapZoomMultiplier: u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera's tap-zoom multiplier of the selected camera mounted position.\n @param position: camera mounted position\n @param tapZoomMultiplier: The multiplier range is [1,5]. A multiplier of 1 will not change the zoom.\n When the multiplier is 1, the zoom scale will not change during TapZoom.\n @return Execution result."]
    pub fn DjiCameraManager_GetTapZoomMultiplier(
        position: E_DjiMountPosition,
        tapZoomMultiplier: *mut u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's tap-zoom point of the selected camera mounted position.\n @note Only available when tap-zoom is enabled. Sets a new target,\n reorienting the gimbal to locate the target on the screen center and\n applying the tap-zoom multiplier.\n @param position: camera mounted position\n @param tapZoomPos: refer to T_DjiCameraManagerTapZoomPosData.\n @return Execution result."]
    pub fn DjiCameraManager_TapZoomAtTarget(
        position: E_DjiMountPosition,
        tapZoomPos: T_DjiCameraManagerTapZoomPosData,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera focus ring value range.\n @param position: camera mounted position\n @param rangeList: returned value of range.\n @return Execution result."]
    pub fn DjiCameraManager_GetFocusRingRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera focus ring value.\n @param position: camera mounted position\n @param value: focus ring value.\n @return Execution result."]
    pub fn DjiCameraManager_SetFocusRingValue(
        position: E_DjiMountPosition,
        value: u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera focus ring value.\n @param position: camera mounted position\n @param value: focus ring value to be returned.\n @return Execution result."]
    pub fn DjiCameraManager_GetFocusRingValue(
        position: E_DjiMountPosition,
        value: *mut u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's exposure mode of the selected camera mounted position.\n @note Different exposure modes define whether settings like aperture, shutter\n speed, and ISO are set automatically or manually. Exposure compensation is\n adjustable in all modes except the manual mode.\n @param position: camera mounted position\n @param mode: refer to E_DjiCameraManagerExposureMode.\n @return Execution result."]
    pub fn DjiCameraManager_SetExposureMode(
        position: E_DjiMountPosition,
        mode: E_DjiCameraManagerExposureMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera's exposure mode of the selected camera mounted position.\n @note Different exposure modes define whether settings like aperture, shutter\n speed, and ISO are set automatically or manually. Exposure compensation is\n adjustable in all modes except the manual mode.\n @param position: camera mounted position\n @param mode: refer to E_DjiCameraManagerExposureMode.\n @return Execution result."]
    pub fn DjiCameraManager_GetExposureMode(
        position: E_DjiMountPosition,
        mode: *mut E_DjiCameraManagerExposureMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's iso value of the selected camera mounted position.\n @note  ISO value can only be set when the camera exposure mode is in\n manual mode.\n @param position: camera mounted position\n @param iso: refer to E_DjiCameraManagerISO.\n @return Execution result."]
    pub fn DjiCameraManager_SetISO(
        position: E_DjiMountPosition,
        iso: E_DjiCameraManagerISO,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera's iso value of the selected camera mounted position.\n @param position: camera mounted position\n @param iso: refer to E_DjiCameraManagerISO.\n @return Execution result."]
    pub fn DjiCameraManager_GetISO(
        position: E_DjiMountPosition,
        iso: *mut E_DjiCameraManagerISO,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's aperture size value of the selected camera mounted position.\n @note The exposure mode must be on DJI_CAMERA_MANAGER_EXPOSURE_MODE_EXPOSURE_MANUAL or\n DJI_CAMERA_MANAGER_EXPOSURE_MODE_APERTURE_PRIORITY.\n @param position: camera mounted position\n @param aperture: refer to E_DjiCameraManagerAperture.\n @return Execution result."]
    pub fn DjiCameraManager_SetAperture(
        position: E_DjiMountPosition,
        aperture: E_DjiCameraManagerAperture,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera's aperture size value of the selected camera mounted position.\n @param position: camera mounted position\n @param aperture: refer to E_DjiCameraManagerAperture.\n @return Execution result."]
    pub fn DjiCameraManager_GetAperture(
        position: E_DjiMountPosition,
        aperture: *mut E_DjiCameraManagerAperture,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's shutter speed value of the selected camera mounted position.\n @note Set the camera shutter speed. Ensure the shutter speed is not set\n slower than the video frame rate when the camera's mode is RECORD_VIDEO.\n For example, if the video frame rate is 30fps, the shutterSpeed must be <=\n 1/30. Precondition: The shutter speed can be set only when the camera\n exposure mode is DJI_CAMERA_MANAGER_EXPOSURE_MODE_EXPOSURE_MANUAL mode or\n DJI_CAMERA_MANAGER_EXPOSURE_MODE_SHUTTER_PRIORITY\n @param position: camera mounted position\n @param shutterSpeed: refer to E_DjiCameraManagerShutterSpeed.\n @return Execution result."]
    pub fn DjiCameraManager_SetShutterSpeed(
        position: E_DjiMountPosition,
        shutterSpeed: E_DjiCameraManagerShutterSpeed,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera's shutter value of the selected camera mounted position.\n @param position: camera mounted position\n @param shutterSpeed: refer to E_DjiCameraManagerShutterSpeed.\n @return Execution result."]
    pub fn DjiCameraManager_GetShutterSpeed(
        position: E_DjiMountPosition,
        shutterSpeed: *mut E_DjiCameraManagerShutterSpeed,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera's EV value of the selected camera mounted position.\n @note This function is available in program, shutter, or aperture\n exposure modes. Enums are DJI_CAMERA_MANAGER_EXPOSURE_MODE_EXPOSURE_MANUAL,\n DJI_CAMERA_MANAGER_EXPOSURE_MODE_SHUTTER_PRIORITY, and\n DJI_CAMERA_MANAGER_EXPOSURE_APERTURE_PRIORITY\n @param position: camera mounted position\n @param ev: refer to E_DjiCameraManagerExposureCompensation.\n @return Execution result."]
    pub fn DjiCameraManager_SetExposureCompensation(
        position: E_DjiMountPosition,
        ev: E_DjiCameraManagerExposureCompensation,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera's EV value of the selected camera mounted position.\n @param position: camera mounted position\n @param ev: refer to E_DjiCameraManagerExposureCompensation.\n @return Execution result."]
    pub fn DjiCameraManager_GetExposureCompensation(
        position: E_DjiMountPosition,
        ev: *mut E_DjiCameraManagerExposureCompensation,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set AE lock mode.\n @param position: camera mounted position\n @param enable: true to enable, false to disable AE lock.\n @return Execution result."]
    pub fn DjiCameraManager_SetAELockEnabled(
        position: E_DjiMountPosition,
        enable: bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get AE lock mode.\n @note This API is not supported by L1/P1/M3D/M3TD models.\n @param position: camera mounted position\n @param enable: result of AE lock mode.\n @return Execution result."]
    pub fn DjiCameraManager_GetAELockEnabled(
        position: E_DjiMountPosition,
        enable: *mut bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Reset camera settings.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_ResetCameraSettings(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Start to take video of the selected camera mounted position.\n @note Camera must be in RECORD_VIDEO mode. For thermal imaging camera,\n user can take a single photo when recording video.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_StartRecordVideo(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Stop to take video of the selected camera mounted position.\n @note Precondition: The camera is recording currently.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_StopRecordVideo(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera recording state.\n @param position: camera mounted position\n @param recordingState: result of getting, see E_DjiCameraManagerRecordingState.\n @return Execution result."]
    pub fn DjiCameraManager_GetRecordingState(
        position: E_DjiMountPosition,
        recordingState: *mut E_DjiCameraManagerRecordingState,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera recording time.\n @note This API is not supported by L1/P1/M3D/M3TD models.\n @param position: camera mounted position\n @param recordingTime: result of getting, unit is seconds.\n @return Execution result."]
    pub fn DjiCameraManager_GetRecordingTime(
        position: E_DjiMountPosition,
        recordingTime: *mut u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera stream source range.\n @param position: camera mounted position\n @param rangeList: pointer to the result.\n @return Execution result."]
    pub fn DjiCameraManager_GetStreamSourceRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Choose camera stream source.\n @param position: camera mounted position\n @param streamSource: stream source to be chose.\n @return Execution result."]
    pub fn DjiCameraManager_SetStreamSource(
        position: E_DjiMountPosition,
        streamSource: E_DjiCameraManagerStreamSource,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get photo storage format range.\n @param position: camera mounted position\n @param rangeList: range list returned value\n @return Execution result."]
    pub fn DjiCameraManager_GetPhotoStorageFormatRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set photo storage format.\n @param position: camera mounted position\n @param format: storage format.\n @return Execution result."]
    pub fn DjiCameraManager_SetPhotoFormat(
        position: E_DjiMountPosition,
        format: E_DjiCameraManagerPhotoStorageFormat,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get photo storage format.\n @param position: camera mounted position\n @param format: returned value of storage format.\n @return Execution result."]
    pub fn DjiCameraManager_GetPhotoFormat(
        position: E_DjiMountPosition,
        format: *mut E_DjiCameraManagerPhotoStorageFormat,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get video storage format range.\n @param position: camera mounted position\n @param rangeList: range list returned value\n @return Execution result."]
    pub fn DjiCameraManager_GetVideoFormatRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set video storage format.\n @param position: camera mounted position\n @param format: storage format.\n @return Execution result."]
    pub fn DjiCameraManager_SetVideoStorageFormat(
        position: E_DjiMountPosition,
        format: E_DjiCameraManagerVideoStorageFormat,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get video storage format.\n @param position: camera mounted position\n @param format: returned value of storage format.\n @return Execution result."]
    pub fn DjiCameraManager_GetVideoFormat(
        position: E_DjiMountPosition,
        format: *mut E_DjiCameraManagerVideoStorageFormat,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get photo ratio range\n @param position: camera mounted position\n @param rangeList: range list returned value\n @return Execution result."]
    pub fn DjiCameraManager_GetPhotoRatioRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera photo ratio\n @param position: camera mounted position\n @param photoRatio: ratio to be set\n @return Execution result."]
    pub fn DjiCameraManager_SetPhotoRatio(
        position: E_DjiMountPosition,
        photoRatio: E_DjiCameraManagerPhotoRatio,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera photo ratio\n @param position: camera mounted position\n @param photoRatio: returned value of photo ratio\n @return Execution result."]
    pub fn DjiCameraManager_GetPhotoRatio(
        position: E_DjiMountPosition,
        photoRatio: *mut E_DjiCameraManagerPhotoRatio,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera video resolution and frame rate\n @param position: camera mounted position\n @param photoRatio: returned value of video resolution and frame rate\n @return Execution result."]
    pub fn DjiCameraManager_GetVideoResolutionFrameRate(
        position: E_DjiMountPosition,
        videoParam: *mut T_DjiCameraManagerVideoFormat,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get night scene mode range.\n @param position: camera mounted position.\n @param tempRange: returned valued of night scene mode range.\n @return Execution result."]
    pub fn DjiCameraManager_GetNightSceneModeRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set night scene mode.\n @note Make sure that stream source is zoom or wide camera.\n @param position: camera mounted position\n @param nightSceneMode: night scene mode.\n @return Execution result."]
    pub fn DjiCameraManager_SetNightSceneMode(
        position: E_DjiMountPosition,
        nightSceneMode: E_DjiCameraManagerNightSceneMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get night scene mode.\n @param position: camera mounted position\n @param nightSceneMode: pointer to night scene mode.\n @return Execution result."]
    pub fn DjiCameraManager_GetNightSceneMode(
        position: E_DjiMountPosition,
        nightSceneMode: *mut E_DjiCameraManagerNightSceneMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get range of stream source(s) can be stored when capturing or recording.\n @param position: camera mounted position.\n @param rangeList: returned value of range, in member streamStorage.\n @return Execution result."]
    pub fn DjiCameraManager_GetStreamStorageRange(
        position: E_DjiMountPosition,
        rangeList: *mut T_DjiCameraManagerRangeList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Select capture or recording stream(s) to store.\n @note Precondition: set camera's work corresponding to streamType\n @param position: camera mounted position.\n @param streamType: capture mode or recording mode.\n @param streamStorageList: Pointer to the struct that contains stream list.\n @return Execution result."]
    pub fn DjiCameraManager_SetCaptureRecordingStreams(
        position: E_DjiMountPosition,
        streamType: E_DjiCameraManagerCaptureOrRecording,
        streamStorageList: *mut T_DjiCameraManagerStreamList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the stream(s) of capture or recording mode to be stored.\n @param position: camera mounted position.\n @param streamType: capture mode or recording mode.\n @param streamSourceList: the real return value.\n @return Execution result."]
    pub fn DjiCameraManager_GetCaptureRecordingStreams(
        position: E_DjiMountPosition,
        streamType: E_DjiCameraManagerCaptureOrRecording,
        streamStorageList: *mut T_DjiCameraManagerStreamList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Turn on/off synchronized split screen zoom function.\n @param position: camera mounted position.\n @param enable: set true to turn on, false to turn off.\n @return Execution result."]
    pub fn DjiCameraManager_SetSynchronizedSplitScreenZoomEnabled(
        position: E_DjiMountPosition,
        enable: bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set suffix name of directory or file.\n @note This setting applies only once for file names.\n @param position: camera mounted position.\n @param nameType: see E_DjiCameraManagerExpandNameType, select to set name of directory or file.\n @param nameSize: Length of the name string, between 1 and 239 characters.\n @param nameStr: Content of custom suffix name.\n @return Execution result."]
    pub fn DjiCameraManager_SetCustomExpandName(
        position: E_DjiMountPosition,
        nameType: E_DjiCameraManagerExpandNameType,
        nameStr: *const u8,
        nameSize: u32,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the custom suffix of the most recent directory or file name.\n @param position: camera mounted position\n @param nameType: to choose directory or file to get custom name\n @param nameStr: name string buffer\n @param nameSize: On input, indicates the maximum size of nameStr; on output,\n the actual size of the name string.\n @return Execution result."]
    pub fn DjiCameraManager_GetCustomExpandName(
        position: E_DjiMountPosition,
        nameType: E_DjiCameraManagerExpandNameType,
        nameStr: *mut u8,
        nameSize: *mut u32,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Downloads a list of media files from the selected camera.\n @note This synchronous interface may lead to higher CPU usage.\n Times out after 3 seconds if the download fails.\n @param position: the mount position of the camera\n @param fileList: the pointer to the downloaded camera file list\n @return Execution result."]
    pub fn DjiCameraManager_DownloadFileList(
        position: E_DjiMountPosition,
        fileList: *mut T_DjiCameraManagerFileList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Download selected camera media file list by slices.\n @note This synchronous interface may lead to higher CPU usage.\n Times out after 3 seconds if the download fails.\n @param position: the mount position of the camera\n @param sliceConfig: the slices config for downloading file list\n @param fileList: the pointer to the downloaded camera file list\n @return Execution result."]
    pub fn DjiCameraManager_DownloadFileListBySlices(
        position: E_DjiMountPosition,
        sliceConfig: T_DjiCameraManagerSliceConfig,
        fileList: *mut T_DjiCameraManagerFileList,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Registers a callback for downloading file data.\n @param position: the mount position of the camera\n @param callback: the download file data callback\n @return Execution result."]
    pub fn DjiCameraManager_RegDownloadFileDataCallback(
        position: E_DjiMountPosition,
        callback: DjiCameraManagerDownloadFileDataCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Downloads a media file specified by its index.\n @note Supports downloading one file at a time. Wait for a download to finish before starting another.\n This synchronous interface may lead to higher CPU usage.\n Times out after 3 seconds if the download fails.\n @param position: the mount position of the camera\n @param fileIndex: the index of the camera media file\n @return Execution result."]
    pub fn DjiCameraManager_DownloadFileByIndex(
        position: E_DjiMountPosition,
        fileIndex: u32,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Download selected camera media file by file index and file type.\n @note This API only supports L2 camera.\n Supports downloading one file at a time. Wait for a download to finish before starting another.\n This synchronous interface may lead to higher CPU usage.\n Times out after 3 seconds if the download fails.\n @param position: the mount position of the camera\n @param fileIndex: the index of the camera media file\n @param fileType: the sub type of the camera media file\n @return Execution result."]
    pub fn DjiCameraManager_DownloadSubFileByIndexAndSubType(
        position: E_DjiMountPosition,
        index: u32,
        fileType: E_DjiCameraMediaFileSubType,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Obtains the rights to download media files before downloading media files\n @param position: the mount position of the camera\n @return Execution result."]
    pub fn DjiCameraManager_ObtainDownloaderRights(position: E_DjiMountPosition)
        -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Releases the rights to download media files after downloading media files\n @note Failure to release downloader rights may restrict access to the camera album\n by the pilot app.\n @param position: the mount position of the camera\n @return Execution result."]
    pub fn DjiCameraManager_ReleaseDownloaderRights(
        position: E_DjiMountPosition,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Format SD card.\n @param position: the mount position of the camera\n @return Execution result."]
    pub fn DjiCameraManager_FormatStorage(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get storage info of SD card.\n @note This API doesn't support L1/P1/M3D/M3TD models.\n @param position: the mount position of the camera\n @param storageInfo: Result of SD Card storage information\n @return Execution result."]
    pub fn DjiCameraManager_GetStorageInfo(
        position: E_DjiMountPosition,
        storageInfo: *mut T_DjiCameraManagerStorageInfo,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Delete selected camera media file by file index.\n @param position: the mount position of the camera\n @param fileIndex: the index of the camera media file\n @return Execution result."]
    pub fn DjiCameraManager_DeleteFileByIndex(
        position: E_DjiMountPosition,
        fileIndex: u32,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the camera laser ranging info of the selected camera mounted position.\n @note Maximum data update frequency: 5Hz.\n @param position: the mount position of the camera\n @param laserRangingInfo: the pointer to the camera laser ranging info\n @return Execution result."]
    pub fn DjiCameraManager_GetLaserRangingInfo(
        position: E_DjiMountPosition,
        laserRangingInfo: *mut T_DjiCameraManagerLaserRangingInfo,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set point thermometry coordinates of the selected camera mounted position.\n @param position: camera mounted position\n @param pointCoordinate: point thermometry coordinates\n @return Execution result."]
    pub fn DjiCameraManager_SetPointThermometryCoordinate(
        position: E_DjiMountPosition,
        pointCoordinate: T_DjiCameraManagerPointThermometryCoordinate,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get point thermometry result.\n @note Before get point thermometry data from camera, DjiCameraManager_SetPointThermometryCoordinate()\n function has to be called.\n @param position: camera mounted position\n @param pointThermometryData: point thermometry result\n @return Execution result."]
    pub fn DjiCameraManager_GetPointThermometryData(
        position: E_DjiMountPosition,
        pointThermometryData: *mut T_DjiCameraManagerPointThermometryData,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set area thermometry coordinates of the selected camera mounted position.\n @param position: camera mounted position\n @param areaCoordinate: area thermometry coordinates\n @return Execution result."]
    pub fn DjiCameraManager_SetAreaThermometryCoordinate(
        position: E_DjiMountPosition,
        areaCoordinate: T_DjiCameraManagerAreaThermometryCoordinate,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get area thermometry result.\n @note Before get area thermometry data from camera, DjiCameraManager_SetAreaThermometryCoordinate()\n function has to be called.\n @param position: camera mounted position\n @param areaThermometryData: area thermometry result\n @return Execution result."]
    pub fn DjiCameraManager_GetAreaThermometryData(
        position: E_DjiMountPosition,
        areaThermometryData: *mut T_DjiCameraManagerAreaThermometryData,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set FFC mode.\n @param position: camera mounted position.\n @param ffcMode: mode to be set.\n @return Execution result."]
    pub fn DjiCameraManager_SetFfcMode(
        position: E_DjiMountPosition,
        ffcMode: E_DjiCameraManagerFfcMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Trigger FFC one time.\n @param position: camera mounted position.\n @return Execution result."]
    pub fn DjiCameraManager_TriggerFfc(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set infrared camera gain mode.\n @param position: camera mounted position.\n @param gainMode: gain mode to set.\n @return Execution result."]
    pub fn DjiCameraManager_SetInfraredCameraGainMode(
        position: E_DjiMountPosition,
        gainMode: E_DjiCameraManagerIrGainMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get temperature range of infrared camera.\n @param position: camera mounted position.\n @param tempRange: returned valued of temperature range.\n @return Execution result."]
    pub fn DjiCameraManager_GetInfraredCameraGainModeTemperatureRange(
        position: E_DjiMountPosition,
        tempRange: *mut T_DjiCameraManagerIrTempMeterRange,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set camera metering mode.\n @param position: camera mounted position\n @param meteringMode: metering mode\n @return Execution result."]
    pub fn DjiCameraManager_SetMeteringMode(
        position: E_DjiMountPosition,
        meteringMode: E_DjiCameraManagerMeteringMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera metering mode.\n @param position: camera mounted position\n @param meteringMode: pointer to returned value of metering mode\n @return Execution result."]
    pub fn DjiCameraManager_GetMeteringMode(
        position: E_DjiMountPosition,
        meteringMode: *mut E_DjiCameraManagerMeteringMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get range of metering point.\n @param position: camera mounted position\n @param hrzNum: returned value, horizontal range.\n @param vtcNum: returned value, vertical range.\n @return Execution result."]
    pub fn DjiCameraManager_GetMeteringPointRegionRange(
        position: E_DjiMountPosition,
        hrzNum: *mut u8,
        vtcNum: *mut u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set metering point.\n @param position: camera mounted position\n @param x: Horizontal coordinate value, should be no greater than hrzNum - 1.\n @param y: Horizontal coordinate value, should be no greater than vtcNum - 1.\n @return Execution result."]
    pub fn DjiCameraManager_SetMeteringPoint(
        position: E_DjiMountPosition,
        x: u8,
        y: u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera metering mode.\n @param position: camera mounted position\n @param x: returned valued, current metering point in horizontal coordinate.\n @param y: returned valued, current metering point in vertical coordinate.\n @return Execution result."]
    pub fn DjiCameraManager_GetMeteringPoint(
        position: E_DjiMountPosition,
        x: *mut u8,
        y: *mut u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Start to record point cloud of the selected camera mounted position.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_StartRecordPointCloud(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Stop to record point cloud of the selected camera mounted position.\n @note Precondition: The camera is recording currently.\n @param position: camera mounted position\n @return Execution result."]
    pub fn DjiCameraManager_StopRecordPointCloud(position: E_DjiMountPosition) -> T_DjiReturnCode;
}
#[doc = " @brief Platform handle of uart operation."]
pub type T_DjiUartHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of usb bulk operation."]
pub type T_DjiUsbBulkHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of network operation."]
pub type T_DjiNetworkHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of thread task operation."]
pub type T_DjiTaskHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of mutex operation."]
pub type T_DjiMutexHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of semaphore operation."]
pub type T_DjiSemaHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of file operation."]
pub type T_DjiFileHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of dir operation."]
pub type T_DjiDirHandle = *mut ::std::os::raw::c_void;
#[doc = " @brief Platform handle of socket operation."]
pub type T_DjiSocketHandle = *mut ::std::os::raw::c_void;
#[doc = " All aircraft type support，users can connect via chip serial port or USB to TTL serial port.\n Baud rate support list on M300 RTK Payload Port: 115200, 230400, 460800, 921600.\n Baud rate support list on M300 RTK Extension Port: 115200, 230400, 460800, 921600, 1000000.\n Baud rate support list on M30/M30T: 115200, 230400, 460800, 921600, 1000000.\n Baud rate support list on M3E/M3T: 921600.\n Baud rate support list on M350 RTK Payload Port: 115200, 230400, 460800, 921600.\n Baud rate support list on M350 RTK Extension Port: 115200, 230400, 460800, 921600, 1000000."]
pub const E_DjiHalUartNum_DJI_HAL_UART_NUM_0: E_DjiHalUartNum = 0;
#[doc = " Only support on M300/M350 RTK Extension Port by USB virtual serial port, such as /dev/ttyACM0.\n Baud rate support list on M300 RTK Extension Port: 921600.\n Baud rate support list on M350 RTK Extension Port: 921600."]
pub const E_DjiHalUartNum_DJI_HAL_UART_NUM_1: E_DjiHalUartNum = 1;
pub type E_DjiHalUartNum = ::std::os::raw::c_uint;
pub const E_DjiHalUsbBulkNum_DJI_HAL_USB_BULK_NUM_0: E_DjiHalUsbBulkNum = 0;
pub const E_DjiHalUsbBulkNum_DJI_HAL_USB_BULK_NUM_1: E_DjiHalUsbBulkNum = 1;
pub const E_DjiHalUsbBulkNum_DJI_HAL_USB_BULK_NUM_MAX: E_DjiHalUsbBulkNum = 2;
pub type E_DjiHalUsbBulkNum = ::std::os::raw::c_uint;
pub const E_DjiSocketMode_DJI_SOCKET_MODE_UDP: E_DjiSocketMode = 0;
pub const E_DjiSocketMode_DJI_SOCKET_MODE_TCP: E_DjiSocketMode = 1;
pub type E_DjiSocketMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUartStatus {
    pub isConnect: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiTime {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub minute: u8,
    pub second: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFileInfo {
    pub size: u32,
    pub createTime: T_DjiTime,
    pub modifyTime: T_DjiTime,
    pub path: [::std::os::raw::c_char; 512usize],
    pub isDir: bool,
}
impl Default for T_DjiFileInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalUartHandler {
    pub UartInit: ::std::option::Option<
        unsafe extern "C" fn(
            uartNum: E_DjiHalUartNum,
            baudRate: u32,
            uartHandle: *mut T_DjiUartHandle,
        ) -> T_DjiReturnCode,
    >,
    pub UartDeInit:
        ::std::option::Option<unsafe extern "C" fn(uartHandle: T_DjiUartHandle) -> T_DjiReturnCode>,
    pub UartWriteData: ::std::option::Option<
        unsafe extern "C" fn(
            uartHandle: T_DjiUartHandle,
            buf: *const u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub UartReadData: ::std::option::Option<
        unsafe extern "C" fn(
            uartHandle: T_DjiUartHandle,
            buf: *mut u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub UartGetStatus: ::std::option::Option<
        unsafe extern "C" fn(
            uartNum: E_DjiHalUartNum,
            status: *mut T_DjiUartStatus,
        ) -> T_DjiReturnCode,
    >,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalUsbBulkChannelInfo {
    pub interfaceNum: u16,
    pub endPointIn: u16,
    pub endPointOut: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalUsbBulkInfo {
    pub isUsbHost: bool,
    pub pid: u16,
    pub vid: u16,
    pub channelInfo: T_DjiHalUsbBulkChannelInfo,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalUsbBulkDeviceInfo {
    pub pid: u16,
    pub vid: u16,
    pub channelInfo: [T_DjiHalUsbBulkChannelInfo; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalNetworkDeviceInfo {
    pub usbNetAdapter: T_DjiHalNetworkDeviceInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalNetworkDeviceInfo__bindgen_ty_1 {
    pub vid: u16,
    pub pid: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalUsbBulkHandler {
    pub UsbBulkInit: ::std::option::Option<
        unsafe extern "C" fn(
            usbBulkInfo: T_DjiHalUsbBulkInfo,
            usbBulkHandle: *mut T_DjiUsbBulkHandle,
        ) -> T_DjiReturnCode,
    >,
    pub UsbBulkDeInit: ::std::option::Option<
        unsafe extern "C" fn(usbBulkHandle: T_DjiUsbBulkHandle) -> T_DjiReturnCode,
    >,
    pub UsbBulkWriteData: ::std::option::Option<
        unsafe extern "C" fn(
            usbBulkHandle: T_DjiUsbBulkHandle,
            buf: *const u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub UsbBulkReadData: ::std::option::Option<
        unsafe extern "C" fn(
            usbBulkHandle: T_DjiUsbBulkHandle,
            buf: *mut u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub UsbBulkGetDeviceInfo: ::std::option::Option<
        unsafe extern "C" fn(deviceInfo: *mut T_DjiHalUsbBulkDeviceInfo) -> T_DjiReturnCode,
    >,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHalNetworkHandler {
    pub NetworkInit: ::std::option::Option<
        unsafe extern "C" fn(
            ipAddr: *const ::std::os::raw::c_char,
            netMask: *const ::std::os::raw::c_char,
            networkHandle: *mut T_DjiNetworkHandle,
        ) -> T_DjiReturnCode,
    >,
    pub NetworkDeInit: ::std::option::Option<
        unsafe extern "C" fn(networkHandle: T_DjiNetworkHandle) -> T_DjiReturnCode,
    >,
    pub NetworkGetDeviceInfo: ::std::option::Option<
        unsafe extern "C" fn(deviceInfo: *mut T_DjiHalNetworkDeviceInfo) -> T_DjiReturnCode,
    >,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiOsalHandler {
    pub TaskCreate: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            taskFunc: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                ) -> *mut ::std::os::raw::c_void,
            >,
            stackSize: u32,
            arg: *mut ::std::os::raw::c_void,
            task: *mut T_DjiTaskHandle,
        ) -> T_DjiReturnCode,
    >,
    pub TaskDestroy:
        ::std::option::Option<unsafe extern "C" fn(task: T_DjiTaskHandle) -> T_DjiReturnCode>,
    pub TaskSleepMs: ::std::option::Option<unsafe extern "C" fn(timeMs: u32) -> T_DjiReturnCode>,
    pub MutexCreate: ::std::option::Option<
        unsafe extern "C" fn(mutex: *mut T_DjiMutexHandle) -> T_DjiReturnCode,
    >,
    pub MutexDestroy:
        ::std::option::Option<unsafe extern "C" fn(mutex: T_DjiMutexHandle) -> T_DjiReturnCode>,
    pub MutexLock:
        ::std::option::Option<unsafe extern "C" fn(mutex: T_DjiMutexHandle) -> T_DjiReturnCode>,
    pub MutexUnlock:
        ::std::option::Option<unsafe extern "C" fn(mutex: T_DjiMutexHandle) -> T_DjiReturnCode>,
    pub SemaphoreCreate: ::std::option::Option<
        unsafe extern "C" fn(initValue: u32, semaphore: *mut T_DjiSemaHandle) -> T_DjiReturnCode,
    >,
    pub SemaphoreDestroy:
        ::std::option::Option<unsafe extern "C" fn(semaphore: T_DjiSemaHandle) -> T_DjiReturnCode>,
    pub SemaphoreWait:
        ::std::option::Option<unsafe extern "C" fn(semaphore: T_DjiSemaHandle) -> T_DjiReturnCode>,
    pub SemaphoreTimedWait: ::std::option::Option<
        unsafe extern "C" fn(semaphore: T_DjiSemaHandle, waitTimeMs: u32) -> T_DjiReturnCode,
    >,
    pub SemaphorePost:
        ::std::option::Option<unsafe extern "C" fn(semaphore: T_DjiSemaHandle) -> T_DjiReturnCode>,
    pub GetTimeMs: ::std::option::Option<unsafe extern "C" fn(ms: *mut u32) -> T_DjiReturnCode>,
    pub GetTimeUs: ::std::option::Option<unsafe extern "C" fn(us: *mut u64) -> T_DjiReturnCode>,
    pub GetRandomNum:
        ::std::option::Option<unsafe extern "C" fn(randomNum: *mut u16) -> T_DjiReturnCode>,
    pub Malloc:
        ::std::option::Option<unsafe extern "C" fn(size: u32) -> *mut ::std::os::raw::c_void>,
    pub Free: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFileSystemHandler {
    pub FileOpen: ::std::option::Option<
        unsafe extern "C" fn(
            fileName: *const ::std::os::raw::c_char,
            fileMode: *const ::std::os::raw::c_char,
            fileObj: *mut T_DjiFileHandle,
        ) -> T_DjiReturnCode,
    >,
    pub FileClose:
        ::std::option::Option<unsafe extern "C" fn(fileObj: T_DjiFileHandle) -> T_DjiReturnCode>,
    pub FileWrite: ::std::option::Option<
        unsafe extern "C" fn(
            fileObj: T_DjiFileHandle,
            buf: *const u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub FileRead: ::std::option::Option<
        unsafe extern "C" fn(
            fileObj: T_DjiFileHandle,
            buf: *mut u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub FileSeek: ::std::option::Option<
        unsafe extern "C" fn(fileObj: T_DjiFileHandle, offset: u32) -> T_DjiReturnCode,
    >,
    pub FileSync:
        ::std::option::Option<unsafe extern "C" fn(fileObj: T_DjiFileHandle) -> T_DjiReturnCode>,
    pub DirOpen: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            dirObj: *mut T_DjiDirHandle,
        ) -> T_DjiReturnCode,
    >,
    pub DirClose:
        ::std::option::Option<unsafe extern "C" fn(dirObj: T_DjiDirHandle) -> T_DjiReturnCode>,
    pub DirRead: ::std::option::Option<
        unsafe extern "C" fn(
            dirObj: T_DjiDirHandle,
            fileInfo: *mut T_DjiFileInfo,
        ) -> T_DjiReturnCode,
    >,
    pub Mkdir: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    pub Unlink: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    pub Rename: ::std::option::Option<
        unsafe extern "C" fn(
            oldFilePath: *const ::std::os::raw::c_char,
            newFilePath: *const ::std::os::raw::c_char,
        ) -> T_DjiReturnCode,
    >,
    pub Stat: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            fileInfo: *mut T_DjiFileInfo,
        ) -> T_DjiReturnCode,
    >,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiSocketHandler {
    pub Socket: ::std::option::Option<
        unsafe extern "C" fn(
            mode: E_DjiSocketMode,
            socketHandle: *mut T_DjiSocketHandle,
        ) -> T_DjiReturnCode,
    >,
    pub Close: ::std::option::Option<
        unsafe extern "C" fn(socketHandle: T_DjiSocketHandle) -> T_DjiReturnCode,
    >,
    pub Bind: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            ipAddr: *const ::std::os::raw::c_char,
            port: u32,
        ) -> T_DjiReturnCode,
    >,
    pub UdpSendData: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            ipAddr: *const ::std::os::raw::c_char,
            port: u32,
            buf: *const u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub UdpRecvData: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            ipAddr: *mut ::std::os::raw::c_char,
            port: *mut u32,
            buf: *mut u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub TcpListen: ::std::option::Option<
        unsafe extern "C" fn(socketHandle: T_DjiSocketHandle) -> T_DjiReturnCode,
    >,
    pub TcpAccept: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            ipAddr: *mut ::std::os::raw::c_char,
            port: *mut u32,
            outSocketHandle: *mut T_DjiSocketHandle,
        ) -> T_DjiReturnCode,
    >,
    pub TcpConnect: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            ipAddr: *const ::std::os::raw::c_char,
            port: u32,
        ) -> T_DjiReturnCode,
    >,
    pub TcpSendData: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            buf: *const u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
    pub TcpRecvData: ::std::option::Option<
        unsafe extern "C" fn(
            socketHandle: T_DjiSocketHandle,
            buf: *mut u8,
            len: u32,
            realLen: *mut u32,
        ) -> T_DjiReturnCode,
    >,
}
extern "C" {
    #[doc = " @brief Register the handler for hal uart interfaces by your platform.\n @note It should be noted that the interface in hal is written and tested well. Users need to implement all the\n interfaces. Otherwise, the user interface cannot be successfully registered, and then the user interface is registered\n through the interface. If the registration fails, it needs to be based on the return code. To judge the problem. Make\n sure that the feature is available after a successful registration. The interface needs to be called at the beginning of\n the application for registration, otherwise, the subsequent functions will not work properly.\n @param halUartHandler: pointer to the handler for hal uart interfaces by your platform.\n @return Execution result."]
    pub fn DjiPlatform_RegHalUartHandler(
        halUartHandler: *const T_DjiHalUartHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for usb bulk interfaces by your platform.\n @param fileSystemHandler: pointer to the handler for usb bulk interfaces by your platform.\n @return Execution result."]
    pub fn DjiPlatform_RegHalUsbBulkHandler(
        halUsbBulkHandler: *const T_DjiHalUsbBulkHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for hal network interfaces by your platform.\n @note It should be noted that the interface in hal is written and tested well. Users need to implement all the\n interfaces. Otherwise, the user interface cannot be successfully registered, and then the user interface is registered\n through the interface. If the registration fails, it needs to be based on the return code. To judge the problem. Make\n sure that the feature is available after a successful registration.\n @attention The interface needs to be called at the beginning of the application for registration, otherwise, the\n subsequent functions will not work properly.\n @param osalHandler: pointer to the handler for network handler interfaces by your platform.\n @return Execution result."]
    pub fn DjiPlatform_RegHalNetworkHandler(
        halNetworkHandler: *const T_DjiHalNetworkHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for osal interfaces by your platform.\n @note It should be noted that the interface in osal is written and tested well. Users need to implement all the\n interfaces. Otherwise, the user interface cannot be successfully registered, and then the user interface is registered\n through the interface. If the registration fails, it needs to be based on the return code. To judge the problem. Make\n sure that the feature is available after a successful registration. The interface needs to be called at the beginning of\n the application for registration, otherwise, the subsequent functions will not work properly.\n @param osalHandler: pointer to the handler for osal interfaces by your platform.\n @return Execution result."]
    pub fn DjiPlatform_RegOsalHandler(osalHandler: *const T_DjiOsalHandler) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for file-system interfaces by your platform.\n @param fileSystemHandler: pointer to the handler for file-system interfaces by your platform.\n @return Execution result."]
    pub fn DjiPlatform_RegFileSystemHandler(
        fileSystemHandler: *const T_DjiFileSystemHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for socket interfaces by your platform.\n @param fileSystemHandler: pointer to the handler for socket interfaces by your platform.\n @return Execution result."]
    pub fn DjiPlatform_RegSocketHandler(
        socketHandler: *const T_DjiSocketHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the handler of osal interfaces.\n @return Pointer to osal handler."]
    pub fn DjiPlatform_GetOsalHandler() -> *mut T_DjiOsalHandler;
}
extern "C" {
    #[doc = " @brief Get the handler of usb bulk interfaces.\n @return Pointer to usb bulk handler."]
    pub fn DjiPlatform_GetHalUsbBulkHandler() -> *mut T_DjiHalUsbBulkHandler;
}
extern "C" {
    #[doc = " @brief Get the handler of network interfaces.\n @return Pointer to network handler."]
    pub fn DjiPlatform_GetHalNetworkHandler() -> *mut T_DjiHalNetworkHandler;
}
extern "C" {
    #[doc = " @brief Get the handler of file-system interfaces.\n @return Pointer to file-system handler."]
    pub fn DjiPlatform_GetFileSystemHandler() -> *mut T_DjiFileSystemHandler;
}
extern "C" {
    #[doc = " @brief Get the handler of socket interfaces.\n @return Pointer to socket handler."]
    pub fn DjiPlatform_GetSocketHandler() -> *mut T_DjiSocketHandler;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUserInfo {
    #[doc = "< Specifies DJI SDK app name. This info can be obtained by logging in to the\ndeveloper website https://developer.dji.com/user/apps/#all. End with '\\0'."]
    pub appName: [::std::os::raw::c_char; 32usize],
    #[doc = "< Specifies DJI SDK app ID. This info can be obtained by logging in to the\ndeveloper website https://developer.dji.com/user/apps/#all."]
    pub appId: [::std::os::raw::c_char; 16usize],
    #[doc = "< Specifies DJI SDK app key. This info can be obtained by logging in to the\ndeveloper website https://developer.dji.com/user/apps/#all."]
    pub appKey: [::std::os::raw::c_char; 32usize],
    #[doc = "< Specifies DJI SDK app license. This info can be obtained by logging in to the\ndeveloper website https://developer.dji.com/user/apps/#all."]
    pub appLicense: [::std::os::raw::c_char; 512usize],
    #[doc = "< Specifies DJI SDK developer account email. This info can be obtained by\nlogging in to the developer website https://developer.dji.com/user/apps/#all.\nDeveloper's account and other related information need to be able to correspond.\nEnd with '\\0'."]
    pub developerAccount: [::std::os::raw::c_char; 64usize],
    #[doc = "< Specifies DJI SDK communication serial port baud rate."]
    pub baudRate: [::std::os::raw::c_char; 7usize],
}
impl Default for T_DjiUserInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize the Payload SDK core in blocking mode.\n @note The order of calling this call is crucial. It must be done after registering console/OSAL/HAL handler functions\n It must be done after registering console/OSAL/HAL handler functions and before using other functional module\n interfaces. Correctly fill in the developer information to ensure successful initialization. See the\n See the \"PSDK Initialization\" tutorial for more.\n This function does not return until the correct aircraft type and PSDK adapter type is obtained. The logic ensures\n that aircraft and PSDK adapter have been started up normally before PSDK functional module and user's program run.\n General execution time of this function is 2-4 seconds.\n @param userInfo: pointer to the PSDK application information.\n @return Execution result."]
    pub fn DjiCore_Init(userInfo: *const T_DjiUserInfo) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Sets an alias for a DJI application or product that meets the condition for DJI application or product.\n If an alias exists, it will be displayed in DJI Pilot.\n @note Still need to pass in correct DJI APP name that is obtained from DJI SDK developer website to DjiCore_Init()\n interface. The DJI APP name will be used to bind and verification.\n The alias will take effect after a short delay, up to a maximum of 1 second.\n @param productAlias: A pointer to the product alias string, which must end with '\\0'. The maximum length of the string is 31 characters.\n If the alias string exceeds 31 characters, it will be truncated before being passed in.\n @return Execution result."]
    pub fn DjiCore_SetAlias(productAlias: *const ::std::os::raw::c_char) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set custom firmware version for DJI application or product.\n @details Payload firmware version will always display in DJI Pilot payload settings interface.\n @param version: the custom firmware version to be set.\n @return Execution result."]
    pub fn DjiCore_SetFirmwareVersion(version: T_DjiFirmwareVersion) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set custom serial number for DJI application or product.\n @details Payload custom serial number will always display in DJI Pilot payload settings interface.\n @param productSerialNumber: the custom serial number to be set, needs to be no larger than 32 bytes.\n @return Execution result."]
    pub fn DjiCore_SetSerialNumber(
        productSerialNumber: *const ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Notify that the Payload SDK core application starts.\n @note The order of calling this interface requires special attention, The call needs to be completed after all the\n module initialize and register interfaces.\n @return Execution result."]
    pub fn DjiCore_ApplicationStart() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief DeInitialize the Payload SDK core in blocking mode.\n @return Execution result."]
    pub fn DjiCore_DeInit() -> T_DjiReturnCode;
}
#[doc = " @brief Quaternion of aircraft topic name. Quaternion topic provides aircraft body frame (FRD) to ground frame\n (NED) rotation. Please refer to ::T_DjiFcSubscriptionQuaternion for information about data structure.\n @details The DJI quaternion follows Hamilton convention (q0 = w, q1 = x, q2 = y, q3 = z).\n | Angle        | Unit | Accuracy   | Notes                                           |\n|--------------|------|------------|-------------------------------------------------|\n| pitch, roll  | deg  | <1         | in NON-AHRS mode                                |\n| yaw          | deg  | <3         | in well-calibrated compass with fine aligned    |\n| yaw with rtk | deg  | around 1.2 | in RTK heading fixed mode with 1 meter baseline |\n @datastruct \\ref T_DjiFcSubscriptionQuaternion"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_QUATERNION: E_DjiFcSubscriptionTopic =
    0;
#[doc = " @brief Provides aircraft's acceleration w.r.t a ground-fixed \\b NEU frame @ up to 200Hz\n @warning Please note that this data is not in a conventional right-handed frame of reference.\n @details This is a fusion output from the flight control system. The output is in a right-handed NED frame, but the\n sign of the Z-axis acceleration is flipped before publishing to this topic. So if you are looking to get acceleration\n in an NED frame, simply flip the sign of the z-axis value. Beyond that, you can convert using rotations to\n any right-handed frame of reference.\n @units m/s<SUP>2</SUP>\n @datastruct \\ref T_DjiFcSubscriptionAccelerationGround"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ACCELERATION_GROUND:
    E_DjiFcSubscriptionTopic = 1;
#[doc = " @brief Provides aircraft's acceleration w.r.t a body-fixed \\b FRU frame @ up to 200Hz\n @warning Please note that this data is not in a conventional right-handed frame of reference.\n @details This is a fusion output from the flight control system.\n @units m/s<SUP>2</SUP>\n @datastruct \\ref T_DjiFcSubscriptionAccelerationBody"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ACCELERATION_BODY:
    E_DjiFcSubscriptionTopic = 2;
#[doc = " @brief Provides aircraft's acceleration in an IMU-centered, body-fixed \\b FRD frame @ up to 400Hz\n @details This is a filtered output from the IMU on board the flight control system.\n @sensors IMU\n @units m/s<SUP>2</SUP>\n @datastruct \\ref T_DjiFcSubscriptionAccelerationRaw"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ACCELERATION_RAW:
    E_DjiFcSubscriptionTopic = 3;
#[doc = " @brief Velocity of aircraft topic name. Velocity topic provides aircraft's velocity in a ground-fixed NEU frame.\n Please refer to ::T_DjiFcSubscriptionVelocity for information about data structure.\n @warning Please note that this data is not in a conventional right-handed frame of reference.\n @details This velocity data is a fusion output from the aircraft. Original output is in a right-handed NED frame, but the\n sign of the Z-axis velocity is flipped before publishing to this topic. So if you are looking to get velocity\n in an NED frame, simply flip the sign of the z-axis value. Beyond that, you can convert using rotations to\n any right-handed frame of reference.\n | Axis     | Unit | Accuracy                                                                                    |\n|----------|------|---------------------------------------------------------------------------------------------|\n| vgx, vgy | m/s  | Around 5cm/s for GNSS navigation. Around 3cm/s with VO at 1 meter height                    |\n| vgz      | m/s  | 10cm/s only with barometer in steady air. 3cm/s with VO at 1 meter height with 8cm baseline |\n @datastruct \\ref T_DjiFcSubscriptionVelocity"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_VELOCITY: E_DjiFcSubscriptionTopic = 4;
#[doc = " @brief Provides aircraft's angular velocity in a ground-fixed \\b NED frame @ up to 200Hz\n @details This is a fusion output from the flight control system.\n @units rad/s\n @datastruct \\ref T_DjiFcSubscriptionAngularRateFusioned"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ANGULAR_RATE_FUSIONED:
    E_DjiFcSubscriptionTopic = 5;
#[doc = " @brief Provides aircraft's angular velocity in an IMU-centered, body-fixed \\b FRD frame @ up to 400Hz\n @details This is a filtered output from the IMU on board the flight control system.\n @sensors IMU\n @units rad/s\n @datastruct \\ref T_DjiFcSubscriptionAngularRateRaw"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ANGULAR_RATE_RAW:
    E_DjiFcSubscriptionTopic = 6;
#[doc = " @brief Fused altitude of aircraft topic name. Fused altitude topic provides aircraft's fused altitude from sea\n level. Please refer to ::T_DjiFcSubscriptionAltitudeFused for information about data structure.\n @units m\n @datastruct \\ref T_DjiFcSubscriptionAltitudeFused"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ALTITUDE_FUSED:
    E_DjiFcSubscriptionTopic = 7;
#[doc = " @brief Provides aircraft's pressure altitude from sea level using the ICAO model @ up to 200Hz\n @details\n This is a filetered output from the barometer without any further fusion.\n\n The ICAO model gives an MSL altitude of 1013.25mBar at 15&deg; C and a temperature lapse rate of -6.5&deg; C\n per 1000m. In your case, it may be possible that the take off altitude of the aircraft is recording a higher pressure\n than 1013.25mBar. Let's take an example - a weather station shows that SFO (San Francisco International Airport) had\n recently recorded a pressure of 1027.1mBar. SFO is 4m above MSL, yet, if you calculate the Pressure Altitude using\n the ICAO model, it relates to -114m. You can use an online calculator to similarly calculate the Pressure Altitude\n in your area.\n\n Another factor that may affect your altitude reading is manufacturing differences in the barometer - it is not\n uncommon to have a variation of &plusmn;30m readings at the same physical location with two different aircraft. For a given\n aircraft, these readings will be consistent, so you will need to calibrate the offset of your system if your code\n relies on the accuracy of the absolute value of altitude.\n @sensors GPS, Barometer, IMU\n @units m\n @datastruct \\ref T_DjiFcSubscriptionAltitudeBarometer"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ALTITUDE_BAROMETER:
    E_DjiFcSubscriptionTopic = 8;
#[doc = " @brief Provides the altitude from sea level when the aircraft last took off.\n @details\n This is a fusion output from the flight control system, and also uses the ICAO model.\n\n The ICAO model gives an MSL altitude of 1013.25mBar at 15&deg; C and a temperature lapse rate of -6.5&deg; C\n per 1000m. In your case, it may be possible that the take off altitude of the aircraft is recording a higher pressure\n than 1013.25mBar. Let's take an example - a weather station shows that SFO (San Francisco International Airport) had\n recently recorded a pressure of 1027.1mBar. SFO is 4m above MSL, yet, if you calculate the Pressure Altitude using\n the ICAO model, it relates to -114m. You can use an online calculator to similarly calculate the Pressure Altitude\n in your area.\n\n Another factor that may affect your altitude reading is manufacturing differences in the barometer - it is not\n uncommon to have a variation of &plusmn;30m readings at the same physical location with two different aircraft. For a given\n aircraft, these readings will be consistent, so you will need to calibrate the offset of your system if your code\n relies on the accuracy of the absolute value of altitude.\n\n @note This value is updated each time the drone takes off.\n\n @units m\n @datastruct \\ref T_DjiFcSubscriptionAltitudeOfHomePoint"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ALTITUDE_OF_HOMEPOINT:
    E_DjiFcSubscriptionTopic = 9;
#[doc = " @brief Provides the relative height above ground at up to 100Hz.\n @details\n This is a fusion output from the flight control system. The height is a direct estimate of the closest large object below the aircraft's ultrasonic sensors.\n A large object is something that covers the ultrasonic sensor for an extended duration of time.\n\n @warning This topic does not come with a 'valid' flag - so if the aircraft is too far from an object for the\n ultrasonic sensors/VO to provide any meaningful data, the values will latch and there is no way for user code to\n determine if the data is valid or not. Use with caution.\n @sensors Visual Odometry, Ultrasonic\n @units m\n @datastruct \\ref T_DjiFcSubscriptionHeightFusion"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_HEIGHT_FUSION:
    E_DjiFcSubscriptionTopic = 10;
#[doc = " @brief Relative height above ground of aircraft topic name. Please refer to\n ::T_DjiFcSubscriptionHeightRelative for information about data structure.\n @details This data is a fusion output from aircraft. The height is a direct estimate of the closest large object\n below the aircraft's ultrasonic sensors.\n @warning This topic does not come with a 'valid' flag - so if the aircraft is too far from an object for the\n ultrasonic sensors/VO to provide any meaningful data, the values will latch and there is no way for user to\n determine if the data is valid or not. Please use with caution.\n @datastruct \\ref T_DjiFcSubscriptionHeightRelative"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_HEIGHT_RELATIVE:
    E_DjiFcSubscriptionTopic = 11;
#[doc = " Fused position of aircraft topic name. Please refer to ::T_DjiFcSubscriptionPositionFused for information\n about data structure.\n @warning Please note that if GPS signal is weak (low visibleSatelliteNumber, see below), the\n latitude/longitude values won't be updated but the altitude might still be. There is currently no way to know if\n the lat/lon update is healthy.\n @details The most important component of this topic is the T_DjiFcSubscriptionPositionFused::visibleSatelliteNumber.\n Use this to track your GPS satellite coverage and build some heuristics for when you might expect to lose GPS updates.\n   | Axis | Unit | Position Sensor | Accuracy                                         |\n|------|------|-----------------|--------------------------------------------------|\n| x, y | m    | GPS             | <3m with open sky without multipath              |\n| z    | m    | GPS             | <5m with open sky without multipath              |\n @datastruct \\ref T_DjiFcSubscriptionPositionFused"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_POSITION_FUSED:
    E_DjiFcSubscriptionTopic = 12;
#[doc = " @brief GPS date topic name. Please refer to ::T_DjiFcSubscriptionGpsDate for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionGpsDate"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_DATE: E_DjiFcSubscriptionTopic =
    13;
#[doc = " @brief GPS time topic name. Please refer to ::T_DjiFcSubscriptionGpsTime for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionGpsTime"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_TIME: E_DjiFcSubscriptionTopic =
    14;
#[doc = " @brief GPS position topic name. Please refer to ::T_DjiFcSubscriptionGpsPosition for information about data structure.\n @details\n   | Axis | Accuracy                                         |\n|------|--------------------------------------------------|\n| x, y | <3m with open sky without multipath              |\n| z    | <5m with open sky without multipath              |\n @datastruct \\ref T_DjiFcSubscriptionGpsPosition"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_POSITION:
    E_DjiFcSubscriptionTopic = 15;
#[doc = " @brief GPS velocity topic name. Please refer to ::T_DjiFcSubscriptionGpsVelocity for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionGpsVelocity"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_VELOCITY:
    E_DjiFcSubscriptionTopic = 16;
#[doc = " @brief GPS details topic name. GPS details topic provides GPS state and other detail information. Please refer\n to ::T_DjiFcSubscriptionGpsDetail for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionGpsDetails"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_DETAILS: E_DjiFcSubscriptionTopic =
    17;
#[doc = " @brief GPS signal level topic name. This topic provides a measure of the quality of GPS signal. Please refer to\n ::T_DjiFcSubscriptionGpsSignalLevel for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionGpsSignalLevel"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_SIGNAL_LEVEL:
    E_DjiFcSubscriptionTopic = 18;
#[doc = " @brief RTK position topic name. Please refer to ::T_DjiFcSubscriptionRtkPosition for information about data structure.\n @details\n   | Axis | Accuracy                                         |\n|------|--------------------------------------------------|\n| x, y | ~2cm with fine alignment and fix condition       |\n| z    | ~3cm with fine alignment and fix condition       |\n @datastruct \\ref T_DjiFcSubscriptionRtkPosition"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RTK_POSITION:
    E_DjiFcSubscriptionTopic = 19;
#[doc = " @brief RTK velocity topic name. Please refer to ::T_DjiFcSubscriptionRtkVelocity for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionRtkVelocity"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RTK_VELOCITY:
    E_DjiFcSubscriptionTopic = 20;
#[doc = " @brief RTK yaw topic name. Please refer to ::T_DjiFcSubscriptionRtkYaw for information about data structure.\n @details The RTK yaw will provide the vector from ANT1 to ANT2 as configured in DJI Assistant 2. This\n means that the value of RTK yaw will be 90deg offset from the yaw of the aircraft.\n @datastruct \\ref T_DjiFcSubscriptionRtkYaw"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RTK_YAW: E_DjiFcSubscriptionTopic = 21;
#[doc = " @brief RTK position information topic name. RTK position information topic provides a state of RTK position\n solution. Please refer to ::T_DjiFcSubscriptionRtkPositionInfo for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionRtkPositionInfo"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RTK_POSITION_INFO:
    E_DjiFcSubscriptionTopic = 22;
#[doc = " @brief RTK yaw topic name. RTK yaw information topic provides a state of RTK yaw solution. Please refer to\n ::T_DjiFcSubscriptionRtkYawInfo for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionRtkYawInfo"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RTK_YAW_INFO:
    E_DjiFcSubscriptionTopic = 23;
#[doc = " @brief Provides aircraft's magnetometer reading, fused with IMU and GPS @ up to 100Hz\n @details This reading is the magnetic field recorded by the magnetometer in x,y,z axis, calibrated such that\n 1000 < |m| < 2000, and fused with IMU and GPS for robustness\n @sensors Magnetometer, IMU, GPS\n @units N/A\n @datastruct \\ref T_DjiFcSubscriptionCompass"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_COMPASS: E_DjiFcSubscriptionTopic = 24;
#[doc = " @brief Provides remote controller stick inputs @ up to 100Hz\n @details This topic will give you:\n - Stick inputs (R,P,Y,Thr)\n - Mode switch (P/A/F)\n - Landing gear switch (Up/Down)\n\n @datastruct \\ref T_DjiFcSubscriptionRC\n @also \\ref TOPIC_RC_WITH_FLAG_DATA"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RC: E_DjiFcSubscriptionTopic = 25;
#[doc = " @brief Provides gimbal pitch, roll, yaw @ up to 50Hz\n @details\n The reference frame for gimbal angles is a NED frame attached to the gimbal.\n This topic uses a data structure, Vector3f, that is too generic for the topic. The order of angles is :\n |Data Structure Element| Meaning|\n |----------------------|--------|\n |Vector3f.x            |pitch   |\n |Vector3f.y            |roll    |\n |Vector3f.z            |yaw     |\n\n @perf\n 0.1 deg accuracy in all axes\n\n @sensors Gimbal Encoder, IMU, Magnetometer\n @units deg\n @datastruct \\ref T_DjiFcSubscriptionGimbalAngles\n @also \\ref TOPIC_GIMBAL_STATUS, \\ref TOPIC_GIMBAL_CONTROL_MODE"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GIMBAL_ANGLES:
    E_DjiFcSubscriptionTopic = 26;
#[doc = " @brief Provides gimbal status and error codes @ up to 50Hz\n @details Please see the \\ref GimbalStatus struct for the details on what data you can receive.\n\n @datastruct \\ref T_DjiFcSubscriptionGimbalStatus\n @also \\ref TOPIC_GIMBAL_ANGLES, \\ref TOPIC_GIMBAL_CONTROL_MODE"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GIMBAL_STATUS:
    E_DjiFcSubscriptionTopic = 27;
#[doc = " @brief Flight status topic name. Please refer to ::T_DjiFcSubscriptionFlightStatus for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionFlightStatus"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_STATUS_FLIGHT:
    E_DjiFcSubscriptionTopic = 28;
#[doc = " @brief Provides a granular state representation for various tasks/flight modes @ up to 50Hz\n @details Typically, use this topic together with \\ref TOPIC_STATUS_FLIGHT to get a\n better understanding of the overall status of the aircraft.\n\n @datastruct \\ref T_DjiFcSubscriptionDisplaymode\n @also \\ref TOPIC_STATUS_FLIGHT"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_STATUS_DISPLAYMODE:
    E_DjiFcSubscriptionTopic = 29;
#[doc = " @brief Provides status for the landing gear state @ up to 50Hz\n\n @datastruct \\ref T_DjiFcSubscriptionLandinggear"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_STATUS_LANDINGGEAR:
    E_DjiFcSubscriptionTopic = 30;
#[doc = " @brief If motors failed to start, this topic provides reasons why. Available @ up to 50Hz\n @datastruct \\ref T_DjiFcSubscriptionMotorStartError\n \\note These enumerations show up in the ErrorCode class because they can also be returned as acknowledgements\n for APIs that start the motors, such as \\ref Control::takeoff \"Takeoff\" or \\ref Control::armMotors \"Arm\""]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_STATUS_MOTOR_START_ERROR:
    E_DjiFcSubscriptionTopic = 31;
#[doc = " @brief Battery information topic name. Please refer to ::T_DjiFcSubscriptionWholeBatteryInfo for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionWholeBatteryInfo"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_BATTERY_INFO:
    E_DjiFcSubscriptionTopic = 32;
#[doc = " @brief Provides states of the aircraft related to SDK/RC control\n @details The following information is available in this topic:\n |Data Structure Element| Meaning|\n |----------------------|--------|\n |controlMode           |The modes in which the aircraft is being controlled (control loops being applied on horizontal, vertical and yaw axes of the aircraft)|\n |deviceStatus          |Which device is controlling the motion of the aircraft: RC (Manual control), MSDK (Missions kicked off through mobile), OSDK (Missions kicked off through onboard/ low-level flight control)    |\n |flightStatus          |Has the OSDK been granted control authority? Since MSDK and RC have precedence, it is possible that deviceStatus shows RC or MSDK actually controlling the aircraft but this value is 1.     |\n |vrcStatus             |Deprecated|\n @datastruct \\ref T_DjiFcSubscriptionControlDevice"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_CONTROL_DEVICE:
    E_DjiFcSubscriptionTopic = 33;
#[doc = " @brief Provides IMU and quaternion data time-synced with a hardware clock signal @ up to 400Hz.\n @details This is the only data which can be synchronized with external software or hardware systems. If you want to\n fuse an external sensor's data with the aircraft's IMU, this data along with a hardware trigger from the A3/N3's\n expansion ports is how you would do it. You can see detailed documentation on how this process works in the [Hardware\n Sync Guide](https://developer.dji.com/onboard-sdk/documentation/guides/component-guide-hardware-sync.html).\n @sensors IMU, sensor fusion output\n @units\n |Data Structure Element| Units|\n |----------------------|--------|\n |Timestamp |2.5ms, 1ns (See \\ref SyncTimestamp)|\n |Quaternion |rad (after converting to rotation matrix)|\n |Acceleration |g|\n |Gyroscope |rad/sec|\n @datastruct \\ref T_DjiFcSubscriptionHardSync"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_HARD_SYNC: E_DjiFcSubscriptionTopic =
    34;
#[doc = " @brief Provides a measure of the quality of GPS signal, with a mechanism for guarding against unset homepoint @ up to 50Hz\n @details The level varies from 0 to 5, with 0 being the worst and 5 the best GPS signal. The key difference between\n this and TOPIC_GPS_SIGNAL_LEVEL is that this topic always returns 0 if the homepoint is not set. Once the home point is\n set, the behavior is exactly the same as TOPIC_GPS_SIGNAL_LEVEL.\n @sensors GPS\n @datastruct \\ref T_DjiFcSubscriptionGpsControlLevel\n @also \\ref TOPIC_GPS_SIGNAL_LEVEL"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GPS_CONTROL_LEVEL:
    E_DjiFcSubscriptionTopic = 35;
#[doc = " @brief Provides normalized remote controller stick input data, along with connection status @ up to 50Hz\n @note This topic was added in August 2018. Your aircraft may require a FW update to enable this feature.\n @details This topic will give you:\n - Stick inputs (R,P,Y,Thr)\n - Mode switch (P/A/F)\n - Landing gear switch (Up/Down)\n - Connection status for air system, ground system and MSDK apps. The connection status also includes a\n logicConnected element, which will change to false if either the air system or the ground system radios\n are disconnected for >3s.\n - Deadzones near the center of the stick positions are also handled in this topic.\n\n @datastruct \\ref T_DjiFcSubscriptionRCWithFlagData\n @also \\ref TOPIC_RC"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RC_WITH_FLAG_DATA:
    E_DjiFcSubscriptionTopic = 36;
#[doc = " @brief Provides raw data from the ESCs @ up to 50Hz\n @note This topic was added in August 2018. Your aircraft may require a FW update to enable this feature.\n @details This topic supports reporting data for up to 8 ESCs; note that only DJI Intelligent ESCs are supported\n for this reporting feature. Use this topic to get data on elements close to the hardware - e.g. motor speeds,\n ESC current and voltage, error flags at the ESC level etc.\n @datastruct \\ref T_DjiFcSubscriptionEscData"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_ESC_DATA: E_DjiFcSubscriptionTopic =
    37;
#[doc = " @brief Provides RTK connection status @ up to 50Hz\n @note This topic was added in August 2018. Your aircraft may require a FW update to enable this feature.\n @details This topic will update in real time whether the RTK GPS system is connected or not; typical uses\n include app-level logic to switch between GPS and RTK sources of positioning based on this flag.\n @datastruct \\ref T_DjiFcSubscriptionRTKConnectStatus"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_RTK_CONNECT_STATUS:
    E_DjiFcSubscriptionTopic = 38;
#[doc = " @brief Provides the mode in which the gimbal will interpret control commands @ up to 50Hz\n @note This topic was added in August 2018. Your aircraft may require a FW update to enable this feature.\n @details This topic will report the current control mode which can be set in the\n DJI Go app, MSDK apps, or through Onboard SDK gimbal control APIs (see \\ref Gimbal::AngleData \"AngleData\" struct\n for more information)\n @datastruct \\ref T_DjiFcSubscriptionGimbalControlMode"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_GIMBAL_CONTROL_MODE:
    E_DjiFcSubscriptionTopic = 39;
#[doc = " @brief Provides a number of flags which report different errors the aircraft may encounter in flight @ up to 50Hz\n @note This topic was added in August 2018. Your aircraft may require a FW update to enable this feature.\n @warning Most of the errors reported by this topic are cases where immediate action is required; you can use these\n as a baseline for implementing safety-related error-handling routines.\n @datastruct \\ref T_DjiFcSubscriptionFlightAnomaly"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_FLIGHT_ANOMALY:
    E_DjiFcSubscriptionTopic = 40;
#[doc = " @brief Provides aircraft's position in a Cartesian frame @ up to 50Hz, without the need for GPS\n @warning This topic does not follow a standard co-ordinate convention. Please read the details below for usage.\n @details This is the only topic which can provide positioning information without having a GPS fix; though this\n can be a big enabler please note the caveats of using this topic:\n - The topic will use an origin that does not have a global reference, and is not published to the SDK.\n - The topic uses a combination of VO and compass heading to identify the X-Y axes of its reference frame. This means\n that if your compass performance is not good in an environment, there is no guarantee the X-Y axes will point to\n North and East.\n - The actual directions of the X-Y axes are currently not published to the SDK.\n - If during a flight the compass performance were to change dramatically, the orientation of the X-Y axes may change\n to re-align with North-East. The aircraft's position in X and Y may exhibit discontinuities in these cases.\n - The reference frame is referred to as the Navigation Frame - Cartesian X,Y axes aligned with N,E directions on a best-effort\n basis, and Z aligned to D (down) direction.\n - A health flag for each axis provides some granularity on whether this data is valid or not.\n\n The key takeaway from these details is that this topic provides a best-effort attempt at providing position\n information in the absence of absolute references (GPS, compass etc.), without guarantees of consistency if\n environmental conditions change. So if your application is confined to a stable environment, or if you will\n have GPS and compass available at all times, this topic can still provide useful data that cannot be otherwise\n had. If using for control, make sure to have guards checking for the continuity of data.\n\n @note Since this topic relies on visual features and/or GPS, if your environment does not provide any of these\n sources of data, the quality of this topic will reduce significantly. VO data quality will reduce if you are too high\n above the ground. Make sure that the Vision Positioning System is enabled in DJI Go 4 before using this topic\n (by default it is enabled).\n @sensors IMU, VO, GPS(if available), RTK (if available), ultrasonic, magnetometer, barometer\n @units m\n @datastruct \\ref T_DjiFcSubscriptionPositionVO"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_POSITION_VO: E_DjiFcSubscriptionTopic =
    41;
#[doc = " @brief Provides obstacle info around the vehicle @ up to 100Hz\n @datastruct \\ref T_DjiFcSubscriptionAvoidData"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_AVOID_DATA: E_DjiFcSubscriptionTopic =
    42;
#[doc = " @brief Provides status of whether the home point was set or not\n @datastruct \\ref T_DjiFcSubscriptionHomePointSetStatus"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_HOME_POINT_SET_STATUS:
    E_DjiFcSubscriptionTopic = 43;
#[doc = " @brief Provides homepoint information, the valid of the home point infomation can ref to the\n topic DJI_FC_SUBSCRIPTION_TOPIC_HOME_POINT_SET_STATUS\n @datastruct \\ref T_DjiFcSubscriptionHomePointInfo"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_HOME_POINT_INFO:
    E_DjiFcSubscriptionTopic = 44;
#[doc = " @brief Provides three gimbal information, used for M300\n @datastruct \\ref T_DjiFcSubscriptionThreeGimbalData"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_THREE_GIMBAL_DATA:
    E_DjiFcSubscriptionTopic = 45;
#[doc = " @brief Battery information topic name. Please refer to ::T_DjiFcSubscriptionSingleBatteryInfo for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionSingleBatteryInfo"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_BATTERY_SINGLE_INFO_INDEX1:
    E_DjiFcSubscriptionTopic = 46;
#[doc = " @brief Battery information topic name. Please refer to ::T_DjiFcSubscriptionSingleBatteryInfo for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionSingleBatteryInfo"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_BATTERY_SINGLE_INFO_INDEX2:
    E_DjiFcSubscriptionTopic = 47;
#[doc = " @brief Please refer to ::T_DjiFcSubscriptionImuAttiNaviDataWithTimestamp for information about data structure.\n @datastruct \\ref T_DjiFcSubscriptionImuAttiNaviDataWithTimestamp"]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_IMU_ATTI_NAVI_DATA_WITH_TIMESTAMP:
    E_DjiFcSubscriptionTopic = 48;
#[doc = " Total number of topics that can be subscribed."]
pub const E_DjiFcSubscriptionTopic_DJI_FC_SUBSCRIPTION_TOPIC_TOTAL_NUMBER:
    E_DjiFcSubscriptionTopic = 49;
#[doc = " @brief Name of topics that can be subscribed. Topic is minimum data item subscribed."]
pub type E_DjiFcSubscriptionTopic = ::std::os::raw::c_uint;
#[doc = "< Data subscribed is healthy and can be used."]
pub const E_DjiFcSubscriptionDataHealthFlag_DJI_FC_SUBSCRIPTION_DATA_NOT_HEALTH:
    E_DjiFcSubscriptionDataHealthFlag = 0;
#[doc = "< Data subscribed is not healthy and recommend not to use it."]
pub const E_DjiFcSubscriptionDataHealthFlag_DJI_FC_SUBSCRIPTION_DATA_HEALTH:
    E_DjiFcSubscriptionDataHealthFlag = 1;
#[doc = " @brief Health state of data subscribed."]
pub type E_DjiFcSubscriptionDataHealthFlag = ::std::os::raw::c_uint;
#[doc = "< Position solution is not available."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_NOT_AVAILABLE : E_DjiFcSubscriptionPositionSolutionProperty = 0 ;
#[doc = "< Position has been fixed by the FIX POSITION command."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_FIX_POSITION : E_DjiFcSubscriptionPositionSolutionProperty = 1 ;
#[doc = "< Position has been fixed by the FIX HEIGHT/AUTO command."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_FIX_HEIGHT_AUTO : E_DjiFcSubscriptionPositionSolutionProperty = 2 ;
#[doc = "< Velocity computed using instantaneous Doppler."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_INSTANTANEOUS_DOPPLER_COMPUTE_VELOCITY : E_DjiFcSubscriptionPositionSolutionProperty = 8 ;
#[doc = "< Single point position solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_SINGLE_PNT_SOLUTION : E_DjiFcSubscriptionPositionSolutionProperty = 16 ;
#[doc = "< Pseudorange differential solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_PSEUDORANGE_DIFFERENTIAL_SOLUTION : E_DjiFcSubscriptionPositionSolutionProperty = 17 ;
#[doc = "< Solution calculated using corrections from an SBAS."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_SBAS_CORRECTION_CALCULATED : E_DjiFcSubscriptionPositionSolutionProperty = 18 ;
#[doc = "< Propagated by a Kalman filter without new observations."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_KALMAN_FILTER_WITHOUT_OBSERVATION_PROPAGATED : E_DjiFcSubscriptionPositionSolutionProperty = 19 ;
#[doc = "< OmniSTAR VBS position (L1 sub-metre)."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_OMNISTAR_VBS_POSITION : E_DjiFcSubscriptionPositionSolutionProperty = 20 ;
#[doc = "< Floating L1 ambiguity solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_FLOAT_L1_AMBIGUITY : E_DjiFcSubscriptionPositionSolutionProperty = 32 ;
#[doc = "< Floating ionospheric-free ambiguity solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_FLOAT_IONOSPHERIC_FREE_AMBIGUITY : E_DjiFcSubscriptionPositionSolutionProperty = 33 ;
#[doc = "< Float position solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_FLOAT_SOLUTION : E_DjiFcSubscriptionPositionSolutionProperty = 34 ;
#[doc = "< Integer L1 ambiguity solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_L1_AMBIGUITY_INT : E_DjiFcSubscriptionPositionSolutionProperty = 48 ;
#[doc = "< Integer wide-lane ambiguity solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_WIDE_LANE_AMBIGUITY_INT : E_DjiFcSubscriptionPositionSolutionProperty = 49 ;
#[doc = "< Narrow fixed point position solution."]
pub const E_DjiFcSubscriptionPositionSolutionProperty_DJI_FC_SUBSCRIPTION_POSITION_SOLUTION_PROPERTY_NARROW_INT : E_DjiFcSubscriptionPositionSolutionProperty = 50 ;
#[doc = " @brief Position solution property."]
pub type E_DjiFcSubscriptionPositionSolutionProperty = ::std::os::raw::c_uint;
#[doc = "< GPS position has not been fixed."]
pub const E_DjiFcSubscriptionGpsFixState_DJI_FC_SUBSCRIPTION_GPS_FIX_STATE_NO_FIX:
    E_DjiFcSubscriptionGpsFixState = 0;
#[doc = "< GPS position is dead reckoned only."]
pub const E_DjiFcSubscriptionGpsFixState_DJI_FC_SUBSCRIPTION_GPS_FIX_STATE_DEAD_RECKONING_ONLY:
    E_DjiFcSubscriptionGpsFixState = 1;
#[doc = "< The horizontal position with latitude/longitude (or northing/easting or X/Y) is fixed."]
pub const E_DjiFcSubscriptionGpsFixState_DJI_FC_SUBSCRIPTION_GPS_FIX_STATE_2D_FIX:
    E_DjiFcSubscriptionGpsFixState = 2;
#[doc = "< The horizontal and vertical position with latitude/longitude/altitude (northing/easting/altitude or X/Y/Z) is fixed."]
pub const E_DjiFcSubscriptionGpsFixState_DJI_FC_SUBSCRIPTION_GPS_FIX_STATE_3D_FIX:
    E_DjiFcSubscriptionGpsFixState = 3;
#[doc = "< Position is calculated by GPS and combined with dead reckoning."]
pub const E_DjiFcSubscriptionGpsFixState_DJI_FC_SUBSCRIPTION_GPS_FIX_STATE_GPS_PLUS_DEAD_RECKONING : E_DjiFcSubscriptionGpsFixState = 4 ;
#[doc = "< Only time is fixed."]
pub const E_DjiFcSubscriptionGpsFixState_DJI_FC_SUBSCRIPTION_GPS_FIX_STATE_TIME_ONLY_FIX:
    E_DjiFcSubscriptionGpsFixState = 5;
#[doc = " @brief GPS fix state."]
pub type E_DjiFcSubscriptionGpsFixState = ::std::os::raw::c_uint;
#[doc = "< Aircraft is on ground and motors are still."]
pub const E_DjiFcSubscriptionFlightStatus_DJI_FC_SUBSCRIPTION_FLIGHT_STATUS_STOPED:
    E_DjiFcSubscriptionFlightStatus = 0;
#[doc = "< Aircraft is on ground but motors are rotating."]
pub const E_DjiFcSubscriptionFlightStatus_DJI_FC_SUBSCRIPTION_FLIGHT_STATUS_ON_GROUND:
    E_DjiFcSubscriptionFlightStatus = 1;
#[doc = "< Aircraft is in air."]
pub const E_DjiFcSubscriptionFlightStatus_DJI_FC_SUBSCRIPTION_FLIGHT_STATUS_IN_AIR:
    E_DjiFcSubscriptionFlightStatus = 2;
#[doc = " @brief Flight status of aircraft."]
pub type E_DjiFcSubscriptionFlightStatus = ::std::os::raw::c_uint;
#[doc = " This mode requires the user to manually\n control the aircraft to remain stable in air."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_MANUAL_CTRL:
    E_DjiFcSubscriptionDisplayMode = 0;
#[doc = " In this mode, the aircraft can keep\n attitude stabilization and only use the\n barometer for positioning to control the altitude. <br>\n The aircraft can not autonomously locate and hover stably."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_ATTITUDE:
    E_DjiFcSubscriptionDisplayMode = 1;
#[doc = " In this mode, the aircraft can keep\n attitude stabilization and only use the\n barometer for positioning to control the altitude. <br>\n The aircraft can not autonomously locate and hover stably."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_2:
    E_DjiFcSubscriptionDisplayMode = 2;
#[doc = " In this mode, the aircraft can keep\n attitude stabilization and only use the\n barometer for positioning to control the altitude. <br>\n The aircraft can not autonomously locate and hover stably."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_3:
    E_DjiFcSubscriptionDisplayMode = 3;
#[doc = " In this mode, the aircraft can keep\n attitude stabilization and only use the\n barometer for positioning to control the altitude. <br>\n The aircraft can not autonomously locate and hover stably."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_4:
    E_DjiFcSubscriptionDisplayMode = 4;
#[doc = " In this mode, the aircraft can keep\n attitude stabilization and only use the\n barometer for positioning to control the altitude. <br>\n The aircraft can not autonomously locate and hover stably."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_5:
    E_DjiFcSubscriptionDisplayMode = 5;
#[doc = " The aircraft is in normal GPS mode. <br>\n In normal GPS mode, the aircraft can\n autonomously locate and hover stably. <br>\n  The sensitivity of the aircraft to the\n  command response is moderate."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_P_GPS:
    E_DjiFcSubscriptionDisplayMode = 6;
#[doc = " The aircraft is in normal GPS mode. <br>\n In normal GPS mode, the aircraft can\n autonomously locate and hover stably. <br>\n  The sensitivity of the aircraft to the\n  command response is moderate."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_7:
    E_DjiFcSubscriptionDisplayMode = 7;
#[doc = " The aircraft is in normal GPS mode. <br>\n In normal GPS mode, the aircraft can\n autonomously locate and hover stably. <br>\n  The sensitivity of the aircraft to the\n  command response is moderate."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_8:
    E_DjiFcSubscriptionDisplayMode = 8;
#[doc = " In hotpoint mode"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_HOTPOINT_MODE:
    E_DjiFcSubscriptionDisplayMode = 9;
#[doc = " In this mode, user can push the throttle\n stick to complete stable take-off."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_ASSISTED_TAKEOFF:
    E_DjiFcSubscriptionDisplayMode = 10;
#[doc = " In this mode, the aircraft will autonomously\n start motor, ascend and finally hover."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_AUTO_TAKEOFF:
    E_DjiFcSubscriptionDisplayMode = 11;
#[doc = " In this mode, the aircraft can land autonomously."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_AUTO_LANDING:
    E_DjiFcSubscriptionDisplayMode = 12;
#[doc = " In this mode, the aircraft can land autonomously."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_13:
    E_DjiFcSubscriptionDisplayMode = 13;
#[doc = " In this mode, the aircraft can land autonomously."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_14:
    E_DjiFcSubscriptionDisplayMode = 14;
#[doc = " In this mode, the aircraft can antonomously return the\n last recorded Home Point. <br>\n There are three types of this mode: Smart RTH(Return-to-Home),\n Low Batterry RTH, and Failsafe RTTH."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_NAVI_GO_HOME:
    E_DjiFcSubscriptionDisplayMode = 15;
#[doc = " In this mode, the aircraft can antonomously return the\n last recorded Home Point. <br>\n There are three types of this mode: Smart RTH(Return-to-Home),\n Low Batterry RTH, and Failsafe RTTH."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_16:
    E_DjiFcSubscriptionDisplayMode = 16;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_NAVI_SDK_CTRL:
    E_DjiFcSubscriptionDisplayMode = 17;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_18:
    E_DjiFcSubscriptionDisplayMode = 18;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_19:
    E_DjiFcSubscriptionDisplayMode = 19;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_20:
    E_DjiFcSubscriptionDisplayMode = 20;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_21:
    E_DjiFcSubscriptionDisplayMode = 21;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_22:
    E_DjiFcSubscriptionDisplayMode = 22;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_23:
    E_DjiFcSubscriptionDisplayMode = 23;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_24:
    E_DjiFcSubscriptionDisplayMode = 24;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_25:
    E_DjiFcSubscriptionDisplayMode = 25;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_26:
    E_DjiFcSubscriptionDisplayMode = 26;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_27:
    E_DjiFcSubscriptionDisplayMode = 27;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_28:
    E_DjiFcSubscriptionDisplayMode = 28;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_29:
    E_DjiFcSubscriptionDisplayMode = 29;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_30:
    E_DjiFcSubscriptionDisplayMode = 30;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_31:
    E_DjiFcSubscriptionDisplayMode = 31;
#[doc = " In this mode, the aircraft is controled by SDK API. <br>\n User can directly define the control mode of horizon\n and vertical directions and send control datas to aircraft."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_32:
    E_DjiFcSubscriptionDisplayMode = 32;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_FORCE_AUTO_LANDING:
    E_DjiFcSubscriptionDisplayMode = 33;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_34:
    E_DjiFcSubscriptionDisplayMode = 34;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_35:
    E_DjiFcSubscriptionDisplayMode = 35;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_36:
    E_DjiFcSubscriptionDisplayMode = 36;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_37:
    E_DjiFcSubscriptionDisplayMode = 37;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_38:
    E_DjiFcSubscriptionDisplayMode = 38;
#[doc = " drone is forced to land, might due to low battery"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_39:
    E_DjiFcSubscriptionDisplayMode = 39;
#[doc = " drone will search for the last position where the rc is not lost"]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_SEARCH_MODE:
    E_DjiFcSubscriptionDisplayMode = 40;
#[doc = " Mode for motor starting. <br>\n Every time user unlock the motor, this will be the first mode."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_ENGINE_START:
    E_DjiFcSubscriptionDisplayMode = 41;
#[doc = " Mode for motor starting. <br>\n Every time user unlock the motor, this will be the first mode."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_42:
    E_DjiFcSubscriptionDisplayMode = 42;
#[doc = " Mode for motor starting. <br>\n Every time user unlock the motor, this will be the first mode."]
pub const E_DjiFcSubscriptionDisplayMode_DJI_FC_SUBSCRIPTION_DISPLAY_MODE_RESERVED_43:
    E_DjiFcSubscriptionDisplayMode = 42;
#[doc = " @brief \"Mode\" of the vehicle's state machine, as displayed on DJI Go\n @details Available through Telemetry::TOPIC_STATUS_DISPLAYMODE"]
pub type E_DjiFcSubscriptionDisplayMode = ::std::os::raw::c_uint;
#[doc = "< The home point was not set yet."]
pub const E_DjiFcSubscriptionHomePointSetStatus_DJI_FC_SUBSCRIPTION_HOME_POINT_SET_STATUS_FAILED:
    E_DjiFcSubscriptionHomePointSetStatus = 0;
#[doc = "< The home point was set successfully."]
pub const E_DjiFcSubscriptionHomePointSetStatus_DJI_FC_SUBSCRIPTION_HOME_POINT_SET_STATUS_SUCCESS : E_DjiFcSubscriptionHomePointSetStatus = 1 ;
#[doc = " @brief Setting status of homepoint."]
pub type E_DjiFcSubscriptionHomePointSetStatus = ::std::os::raw::c_uint;
#[doc = "< Battery self-check is normal."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_NORMAL:
    E_DJIFcSubscriptionBatterySelfCheck = 0;
#[doc = "< Battery self-check NTC is abnormal."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_NTC_ABNORMAL : E_DJIFcSubscriptionBatterySelfCheck = 1 ;
#[doc = "< Battery self-check MOS is abnormal."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_MOS_ABNORMAL : E_DJIFcSubscriptionBatterySelfCheck = 2 ;
#[doc = "< Battery self-check sampling resistance is abnormal."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_R_ABNORMAL:
    E_DJIFcSubscriptionBatterySelfCheck = 3;
#[doc = "< Battery cell self-check is damaged."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_CELL_DAMAGE:
    E_DJIFcSubscriptionBatterySelfCheck = 4;
#[doc = "< Battery self-check is not calibrated."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_CAL_EXP:
    E_DJIFcSubscriptionBatterySelfCheck = 5;
#[doc = "< Battery self-check fuel gauge parameters is abnormal."]
pub const E_DJIFcSubscriptionBatterySelfCheck_DJI_FC_SUBSCRIPTION_BATTERY_SELF_CHECK_GAUGE_PARM_EXP : E_DJIFcSubscriptionBatterySelfCheck = 6 ;
#[doc = " @brief Smart battery self-check result."]
pub type E_DJIFcSubscriptionBatterySelfCheck = ::std::os::raw::c_uint;
#[doc = "< Battery closed reason is normal shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_NORMAL:
    E_DJIFcSubscriptionBatteryClosedReason = 0;
#[doc = "< Battery closed reason is forced by flight controller shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_FORCED:
    E_DJIFcSubscriptionBatteryClosedReason = 1;
#[doc = "< Battery closed reason is discharge short circuit shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_SCD:
    E_DJIFcSubscriptionBatteryClosedReason = 2;
#[doc = "< Battery closed reason is discharge overload shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_OLD:
    E_DJIFcSubscriptionBatteryClosedReason = 3;
#[doc = "< Battery closed reason is discharge over current shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_OCD:
    E_DJIFcSubscriptionBatteryClosedReason = 4;
#[doc = "< Battery closed reason is discharge under voltage shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_UVD:
    E_DJIFcSubscriptionBatteryClosedReason = 5;
#[doc = "< Battery closed reason is discharge over temperature shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_OTD:
    E_DJIFcSubscriptionBatteryClosedReason = 6;
#[doc = "< Battery closed reason is charging short circuit shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_SCC:
    E_DJIFcSubscriptionBatteryClosedReason = 16;
#[doc = "< Battery closed reason is charging over current shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_OCC:
    E_DJIFcSubscriptionBatteryClosedReason = 17;
#[doc = "< Battery closed reason is charging over voltage shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_OVC:
    E_DJIFcSubscriptionBatteryClosedReason = 18;
#[doc = "< Battery closed reason is charger over voltage shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_CHARGER_OVC:
    E_DJIFcSubscriptionBatteryClosedReason = 19;
#[doc = "< Battery closed reason is charging low temperature shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_LTC:
    E_DJIFcSubscriptionBatteryClosedReason = 20;
#[doc = "< Battery closed reason is charging high temperature shutdown."]
pub const E_DJIFcSubscriptionBatteryClosedReason_DJI_FC_SUBSCRIPTION_BATTERY_CLOSED_HTC:
    E_DJIFcSubscriptionBatteryClosedReason = 21;
#[doc = " @brief Smart battery closed reason."]
pub type E_DJIFcSubscriptionBatteryClosedReason = ::std::os::raw::c_uint;
#[doc = "< Battery SOH state is normal."]
pub const E_DJIFcSubscriptionBatterySohState_DJI_FC_SUBSCRIPTION_BATTERY_SOH_NORMAL:
    E_DJIFcSubscriptionBatterySohState = 0;
#[doc = "< Battery SOH state is alert."]
pub const E_DJIFcSubscriptionBatterySohState_DJI_FC_SUBSCRIPTION_BATTERY_SOH_ALERT:
    E_DJIFcSubscriptionBatterySohState = 1;
#[doc = "< Battery SOH state is safe."]
pub const E_DJIFcSubscriptionBatterySohState_DJI_FC_SUBSCRIPTION_BATTERY_SOH_SAFE:
    E_DJIFcSubscriptionBatterySohState = 2;
#[doc = " @brief Smart battery SOH state."]
pub type E_DJIFcSubscriptionBatterySohState = ::std::os::raw::c_uint;
#[doc = "< Battery is in no heat state."]
pub const E_DJIFcSubscriptionBatteryHeatState_DJI_FC_SUBSCRIPTION_BATTERY_NO_HEAT:
    E_DJIFcSubscriptionBatteryHeatState = 0;
#[doc = "< Battery is in heat state."]
pub const E_DJIFcSubscriptionBatteryHeatState_DJI_FC_SUBSCRIPTION_BATTERY_IN_HEAT:
    E_DJIFcSubscriptionBatteryHeatState = 1;
#[doc = "< Battery is in keep warm state."]
pub const E_DJIFcSubscriptionBatteryHeatState_DJI_FC_SUBSCRIPTION_BATTERY_KEEP_WARM:
    E_DJIFcSubscriptionBatteryHeatState = 2;
#[doc = " @brief Smart battery heart state."]
pub type E_DJIFcSubscriptionBatteryHeatState = ::std::os::raw::c_uint;
#[doc = "< Battery SOC state is normal."]
pub const E_DJIFcSubscriptionBatterySocState_DJI_FC_SUBSCRIPTION_BATTERY_SOC_NORMAL:
    E_DJIFcSubscriptionBatterySocState = 0;
#[doc = "< Battery SOC state is abnormal high."]
pub const E_DJIFcSubscriptionBatterySocState_DJI_FC_SUBSCRIPTION_BATTERY_SOC_ABNORMAL_HIGH:
    E_DJIFcSubscriptionBatterySocState = 1;
#[doc = "< Battery SOC state is jump down."]
pub const E_DJIFcSubscriptionBatterySocState_DJI_FC_SUBSCRIPTION_BATTERY_SOC_JUMP_DOWN:
    E_DJIFcSubscriptionBatterySocState = 2;
#[doc = "< Battery SOC state is jump up."]
pub const E_DJIFcSubscriptionBatterySocState_DJI_FC_SUBSCRIPTION_BATTERY_SOC_JUMP_UP:
    E_DJIFcSubscriptionBatterySocState = 3;
#[doc = "< Battery SOC state is invalid."]
pub const E_DJIFcSubscriptionBatterySocState_DJI_FC_SUBSCRIPTION_BATTERY_SOC_INVALID:
    E_DJIFcSubscriptionBatterySocState = 4;
#[doc = " @brief Smart battery SOC state."]
pub type E_DJIFcSubscriptionBatterySocState = ::std::os::raw::c_uint;
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_UNKNOWN:
    E_DJIFcSubscriptionControlMode = 0;
#[doc = "< Horizontal mode is angle, vertical mode is velocity, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_ANG_VER_VEL_YAW_ANG : E_DJIFcSubscriptionControlMode = 1 ;
#[doc = "< Horizontal mode is angle, vertical mode is velocity, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_ANG_VER_VEL_YAW_RAT : E_DJIFcSubscriptionControlMode = 2 ;
#[doc = "< Horizontal mode is velocity, vertical mode is velocity, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_VEL_VER_VEL_YAW_ANG : E_DJIFcSubscriptionControlMode = 3 ;
#[doc = "< Horizontal mode is velocity, vertical mode is velocity, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_VEL_VER_VEL_YAW_RAT : E_DJIFcSubscriptionControlMode = 4 ;
#[doc = "< Horizontal mode is position, vertical mode is velocity, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_POS_VER_VEL_YAW_ANG : E_DJIFcSubscriptionControlMode = 5 ;
#[doc = "< Horizontal mode is position, vertical mode is velocity, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_POS_VER_VEL_YAW_RAT : E_DJIFcSubscriptionControlMode = 6 ;
#[doc = "< Horizontal mode is angle, vertical mode is position, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_ANG_VER_POS_YAW_ANG : E_DJIFcSubscriptionControlMode = 7 ;
#[doc = "< Horizontal mode is angle, vertical mode is position, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_ANG_VER_POS_YAW_RAT : E_DJIFcSubscriptionControlMode = 8 ;
#[doc = "< Horizontal mode is velocity, vertical mode is position, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_VEL_VER_POS_YAW_ANG : E_DJIFcSubscriptionControlMode = 9 ;
#[doc = "< Horizontal mode is velocity, vertical mode is position, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_VEL_VER_POS_YAW_RAT : E_DJIFcSubscriptionControlMode = 10 ;
#[doc = "< Horizontal mode is position, vertical mode is position, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_POS_VER_POS_YAW_ANG : E_DJIFcSubscriptionControlMode = 11 ;
#[doc = "< Horizontal mode is position, vertical mode is position, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_POS_VER_POS_YAW_RAT : E_DJIFcSubscriptionControlMode = 12 ;
#[doc = "< Horizontal mode is angle, vertical mode is thrust, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_ANG_VER_THR_YAW_ANG : E_DJIFcSubscriptionControlMode = 13 ;
#[doc = "< Horizontal mode is angle, vertical mode is thrust, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_ANG_VER_THR_YAW_RAT : E_DJIFcSubscriptionControlMode = 14 ;
#[doc = "< Horizontal mode is velocity, vertical mode is thrust, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_VEL_VER_THR_YAW_ANG : E_DJIFcSubscriptionControlMode = 15 ;
#[doc = "< Horizontal mode is velocity, vertical mode is thrust, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_VEL_VER_THR_YAW_RAT : E_DJIFcSubscriptionControlMode = 16 ;
#[doc = "< Horizontal mode is position, vertical mode is thrust, yaw mode is angle."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_POS_VER_THR_YAW_ANG : E_DJIFcSubscriptionControlMode = 17 ;
#[doc = "< Horizontal mode is position, vertical mode is thrust, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_POS_VER_THR_YAW_RAT : E_DJIFcSubscriptionControlMode = 18 ;
#[doc = "< Horizontal mode is angle-rate, vertical mode is velocity, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_AEL_VER_VEL_YAW_RAT : E_DJIFcSubscriptionControlMode = 19 ;
#[doc = "< Horizontal mode is angle-rate, vertical mode is thrust, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_AEL_VER_POS_YAW_RAT : E_DJIFcSubscriptionControlMode = 20 ;
#[doc = "< Horizontal mode is angle-rate, vertical mode is velocity, yaw mode is rate."]
pub const E_DJIFcSubscriptionControlMode_DJI_FC_SUBSCRIPTION_CONTROL_MODE_HOR_AEL_VER_THR_YAW_RAT : E_DJIFcSubscriptionControlMode = 21 ;
#[doc = " @brief Flight control mode."]
pub type E_DJIFcSubscriptionControlMode = ::std::os::raw::c_uint;
#[doc = "< Authority is in remote control"]
pub const E_DJIFcSubscriptionControlAuthority_DJI_FC_SUBSCRIPTION_CONTROL_AUTHORITY_RC:
    E_DJIFcSubscriptionControlAuthority = 0;
#[doc = "< Authority is in MSDK"]
pub const E_DJIFcSubscriptionControlAuthority_DJI_FC_SUBSCRIPTION_CONTROL_AUTHORITY_MSDK:
    E_DJIFcSubscriptionControlAuthority = 1;
#[doc = "< Authority is in PSDK"]
pub const E_DJIFcSubscriptionControlAuthority_DJI_FC_SUBSCRIPTION_CONTROL_AUTHORITY_PSDK:
    E_DJIFcSubscriptionControlAuthority = 4;
#[doc = "< Authority is in dock"]
pub const E_DJIFcSubscriptionControlAuthority_DJI_FC_SUBSCRIPTION_CONTROL_AUTHORITY_DOCK:
    E_DJIFcSubscriptionControlAuthority = 5;
#[doc = " @brief Flight control authority."]
pub type E_DJIFcSubscriptionControlAuthority = ::std::os::raw::c_uint;
#[doc = "< Reason unknown"]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_UNKNOWN : E_DJIFcSubscriptionAuthorityChangeReason = 0 ;
#[doc = "< Contro authority changed by MSDK request."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_MSDK_REQUEST : E_DJIFcSubscriptionAuthorityChangeReason = 1 ;
#[doc = "< Contro authority changed by user request."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_USER_REQUEST : E_DJIFcSubscriptionAuthorityChangeReason = 2 ;
#[doc = "< Contro authority changed by PSDK request."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_PSDK_REQUEST : E_DJIFcSubscriptionAuthorityChangeReason = 3 ;
#[doc = "< Contro authority changed for remote control lost."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_RC_LOST : E_DJIFcSubscriptionAuthorityChangeReason = 4 ;
#[doc = "< Contro authority changed for remote control not in P mode."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_RC_NOT_P_MODE : E_DJIFcSubscriptionAuthorityChangeReason = 5 ;
#[doc = "< Contro authority changed for remote control switching mode."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_RC_SWITCH : E_DJIFcSubscriptionAuthorityChangeReason = 6 ;
#[doc = "< Contro authority changed for remote control stop key paused."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_RC_PAUSE_STOP : E_DJIFcSubscriptionAuthorityChangeReason = 7 ;
#[doc = "< Contro authority changed for remote control go-home key paused."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_RC_ONE_KEY_GO_HOME : E_DJIFcSubscriptionAuthorityChangeReason = 8 ;
#[doc = "< Contro authority changed for remote control go-home key paused."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_BATTERY_LOW_GO_HOME : E_DJIFcSubscriptionAuthorityChangeReason = 9 ;
#[doc = "< Contro authority changed for going home caused by low batter power."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_BATTERY_SUPER_LOW_LANDING : E_DJIFcSubscriptionAuthorityChangeReason = 10 ;
#[doc = "< Contro authority changed for PSDK lost."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_PSDK_LOST : E_DJIFcSubscriptionAuthorityChangeReason = 11 ;
#[doc = "< Contro authority changed for nearing boundary."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_NEAR_BOUNDARY : E_DJIFcSubscriptionAuthorityChangeReason = 13 ;
#[doc = "< Contro authority changed by airport request."]
pub const E_DJIFcSubscriptionAuthorityChangeReason_DJI_FC_SUBSCRIPTION_AUTHORITY_CHANGE_REASON_AIRPORT_REQUEST : E_DJIFcSubscriptionAuthorityChangeReason = 14 ;
#[doc = " @brief Flight control authority change reason."]
pub type E_DJIFcSubscriptionAuthorityChangeReason = ::std::os::raw::c_uint;
#[doc = " @brief Quaternion topic data structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct Quaternion {
    #[doc = "< w, rad (when converted to a rotation matrix or Euler angles)."]
    pub q0: dji_f32_t,
    #[doc = "< x, rad (when converted to a rotation matrix or Euler angles)."]
    pub q1: dji_f32_t,
    #[doc = "< y, rad (when converted to a rotation matrix or Euler angles)."]
    pub q2: dji_f32_t,
    #[doc = "< z, rad (when converted to a rotation matrix or Euler angles)."]
    pub q3: dji_f32_t,
}
#[doc = " @brief Quaternion topic data structure."]
pub type T_DjiFcSubscriptionQuaternion = Quaternion;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ACCELERATION_GROUND topic data structure."]
pub type T_DjiFcSubscriptionAccelerationGround = T_DjiVector3f;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ACCELERATION_BODY topic data structure."]
pub type T_DjiFcSubscriptionAccelerationBody = T_DjiVector3f;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ACCELERATION_RAW topic data structure."]
pub type T_DjiFcSubscriptionAccelerationRaw = T_DjiVector3f;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_VELOCITY topic data structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct Velocity {
    #[doc = " Velocity of aircraft."]
    pub data: T_DjiVector3f,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl Velocity {
    #[inline]
    pub fn health(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_health(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserve(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserve(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(health: u8, reserve: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let health: u8 = unsafe { ::std::mem::transmute(health) };
            health as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserve: u8 = unsafe { ::std::mem::transmute(reserve) };
            reserve as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_VELOCITY topic data structure."]
pub type T_DjiFcSubscriptionVelocity = Velocity;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ANGULAR_RATE_FUSIONED topic data structure."]
pub type T_DjiFcSubscriptionAngularRateFusioned = T_DjiVector3f;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ANGULAR_RATE_RAW topic data structure."]
pub type T_DjiFcSubscriptionAngularRateRaw = T_DjiVector3f;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ANGULAR_RATE_RAW topic data structure."]
pub type T_DjiFcSubscriptionAltitudeFused = dji_f32_t;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ALTITUDE_BAROMETER topic data structure."]
pub type T_DjiFcSubscriptionAltitudeBarometer = dji_f32_t;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_ALTITUDE_OF_HOMEPOINT topic data structure."]
pub type T_DjiFcSubscriptionAltitudeOfHomePoint = dji_f32_t;
#[doc = " @brief DJI_FC_SUBSCRIPTION_TOPIC_HEIGHT_FUSION topic data structure."]
pub type T_DjiFcSubscriptionHeightFusion = dji_f32_t;
#[doc = " @brief Relative height above ground topic data structure, unit: m."]
pub type T_DjiFcSubscriptionHeightRelative = dji_f32_t;
#[doc = " @brief Fused position topic data structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct PositionFused {
    #[doc = "< Longitude, unit: rad."]
    pub longitude: dji_f64_t,
    #[doc = "< Latitude, unit: rad."]
    pub latitude: dji_f64_t,
    #[doc = "< Altitude, WGS 84 reference ellipsoid, unit: m."]
    pub altitude: dji_f32_t,
    #[doc = "< Number of visible satellites."]
    pub visibleSatelliteNumber: u16,
}
#[doc = " @brief Fused position topic data structure."]
pub type T_DjiFcSubscriptionPositionFused = PositionFused;
#[doc = " @brief GPS date topic data structure, format: yyyymmdd."]
pub type T_DjiFcSubscriptionGpsDate = u32;
#[doc = " @brief GPS time topic data structure, format: hhmmss."]
pub type T_DjiFcSubscriptionGpsTime = u32;
#[doc = " @brief GPS position topic data structure. x = Longitude, y = Latitude, z = Altitude, unit: deg*10<SUP>-7</SUP>\n (Lat,Lon), mm (Alt)"]
pub type T_DjiFcSubscriptionGpsPosition = T_DjiVector3d;
#[doc = " @brief GPS velocity topic data structure, unit: cm/s."]
pub type T_DjiFcSubscriptionGpsVelocity = T_DjiVector3f;
#[doc = " @brief GPS details topic data structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct GpsDetail {
    #[doc = "< Horizontal dilution of precision, unit: 0.01, eg: 100 = 1.00, <1: ideal, 1-2: excellent, 2-5: good, 5-10: moderate, 10-20: fair, >20: poor."]
    pub hdop: dji_f32_t,
    #[doc = "< Position dilution of precision, unit: 0.01, eg: 100 = 1.00, <1: ideal, 1-2: excellent, 2-5: good, 5-10: moderate, 10-20: fair, >20: poor."]
    pub pdop: dji_f32_t,
    #[doc = "< GPS fix state, and can be any value of ::E_DjiFcSubscriptionGpsFixState. Value other than ::E_DjiFcSubscriptionGpsFixState is invalid."]
    pub fixState: dji_f32_t,
    #[doc = "< Vertical position accuracy (mm), the smaller, the better."]
    pub vacc: dji_f32_t,
    #[doc = "< Horizontal position accuracy (mm), the smaller, the better."]
    pub hacc: dji_f32_t,
    #[doc = "< Speed accuracy (cm/s), the smaller, the better."]
    pub sacc: dji_f32_t,
    #[doc = "< Number of GPS satellites used for fixing position."]
    pub gpsSatelliteNumberUsed: u32,
    #[doc = "< Number of GLONASS satellites used for fixing position."]
    pub glonassSatelliteNumberUsed: u32,
    #[doc = "< Total number of satellites used for fixing position."]
    pub totalSatelliteNumberUsed: u16,
    #[doc = "< Accumulated times of sending GPS data."]
    pub gpsCounter: u16,
}
#[doc = " @brief GPS details topic data structure."]
pub type T_DjiFcSubscriptionGpsDetails = GpsDetail;
#[doc = " @brief GPS signal level topic data structure. Signal level of GPS. The level varies from 0 to 5, with 0 being the\n worst and 5 the best GPS signal."]
pub type T_DjiFcSubscriptionGpsSignalLevel = u8;
#[doc = " @brief RTK position topic data structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct PositionData {
    #[doc = "< Longitude, unit: deg."]
    pub longitude: dji_f64_t,
    #[doc = "< Latitude, unit: deg."]
    pub latitude: dji_f64_t,
    #[doc = "< Height above mean sea level, unit: m."]
    pub hfsl: dji_f32_t,
}
#[doc = " @brief RTK position topic data structure."]
pub type T_DjiFcSubscriptionRtkPosition = PositionData;
#[doc = " @brief RTK velocity topic data structure, unit: cm/s."]
pub type T_DjiFcSubscriptionRtkVelocity = T_DjiVector3f;
#[doc = " @brief RTK yaw topic data structure, unit: deg."]
pub type T_DjiFcSubscriptionRtkYaw = i16;
#[doc = " @brief RTK position information topic data structure. Specifies RTK position solution state, it can be any value of\n ::E_DjiFcSubscriptionPositionSolutionProperty."]
pub type T_DjiFcSubscriptionRtkPositionInfo = u8;
#[doc = " @brief RTK yaw information topic data structure. Specifies RTK yaw solution state, it can be any value of\n ::E_DjiFcSubscriptionPositionSolutionProperty."]
pub type T_DjiFcSubscriptionRtkYawInfo = u8;
#[doc = " @brief struct for data broadcast, return magnetometer reading\n\n @note returned value is calibrated mag data,\n 1000 < |mag| < 2000 for normal operation"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct Mag {
    pub x: i16,
    pub y: i16,
    pub z: i16,
}
#[doc = " @brief struct for data broadcast, return magnetometer reading\n\n @note returned value is calibrated mag data,\n 1000 < |mag| < 2000 for normal operation"]
pub type T_DjiFcSubscriptionCompass = Mag;
#[doc = " @brief struct for data broadcast and data subscription, return RC reading"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct RC {
    #[doc = "< [-10000,10000]"]
    pub roll: i16,
    #[doc = "< [-10000,10000]"]
    pub pitch: i16,
    #[doc = "< [-10000,10000]"]
    pub yaw: i16,
    #[doc = "< [-10000,10000]"]
    pub throttle: i16,
    #[doc = "< [-10000,10000] */\n/*!< M100 [P: -8000, A: 0, F: 8000]"]
    pub mode: i16,
    #[doc = "< [-10000,10000] */\n/*!< M100 [Up: -10000, Down: -4545]"]
    pub gear: i16,
}
#[doc = " @brief struct for data broadcast and data subscription, return RC reading"]
pub type T_DjiFcSubscriptionRC = RC;
#[doc = " @brief Represents a vector using floating-point coordinates."]
pub type T_DjiFcSubscriptionGimbalAngles = T_DjiVector3f;
#[doc = " @brief struct for TOPIC_GIMBAL_STATUS"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct GimbalStatus {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl GimbalStatus {
    #[inline]
    pub fn mountStatus(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mountStatus(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isBusy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_isBusy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pitchLimited(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pitchLimited(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rollLimited(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rollLimited(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yawLimited(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_yawLimited(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn calibrating(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_calibrating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prevCalibrationgResult(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prevCalibrationgResult(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn installedDirection(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_installedDirection(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled_mvo(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disabled_mvo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gear_show_unable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gear_show_unable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gyroFalut(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gyroFalut(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escPitchStatus(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escPitchStatus(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escRollStatus(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escRollStatus(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escYawStatus(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escYawStatus(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn droneDataRecv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_droneDataRecv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn initUnfinished(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initUnfinished(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FWUpdating(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FWUpdating(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mountStatus: u32,
        isBusy: u32,
        pitchLimited: u32,
        rollLimited: u32,
        yawLimited: u32,
        calibrating: u32,
        prevCalibrationgResult: u32,
        installedDirection: u32,
        disabled_mvo: u32,
        gear_show_unable: u32,
        gyroFalut: u32,
        escPitchStatus: u32,
        escRollStatus: u32,
        escYawStatus: u32,
        droneDataRecv: u32,
        initUnfinished: u32,
        FWUpdating: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mountStatus: u32 = unsafe { ::std::mem::transmute(mountStatus) };
            mountStatus as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let isBusy: u32 = unsafe { ::std::mem::transmute(isBusy) };
            isBusy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pitchLimited: u32 = unsafe { ::std::mem::transmute(pitchLimited) };
            pitchLimited as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rollLimited: u32 = unsafe { ::std::mem::transmute(rollLimited) };
            rollLimited as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let yawLimited: u32 = unsafe { ::std::mem::transmute(yawLimited) };
            yawLimited as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let calibrating: u32 = unsafe { ::std::mem::transmute(calibrating) };
            calibrating as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let prevCalibrationgResult: u32 =
                unsafe { ::std::mem::transmute(prevCalibrationgResult) };
            prevCalibrationgResult as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let installedDirection: u32 = unsafe { ::std::mem::transmute(installedDirection) };
            installedDirection as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let disabled_mvo: u32 = unsafe { ::std::mem::transmute(disabled_mvo) };
            disabled_mvo as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let gear_show_unable: u32 = unsafe { ::std::mem::transmute(gear_show_unable) };
            gear_show_unable as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let gyroFalut: u32 = unsafe { ::std::mem::transmute(gyroFalut) };
            gyroFalut as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let escPitchStatus: u32 = unsafe { ::std::mem::transmute(escPitchStatus) };
            escPitchStatus as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let escRollStatus: u32 = unsafe { ::std::mem::transmute(escRollStatus) };
            escRollStatus as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let escYawStatus: u32 = unsafe { ::std::mem::transmute(escYawStatus) };
            escYawStatus as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let droneDataRecv: u32 = unsafe { ::std::mem::transmute(droneDataRecv) };
            droneDataRecv as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let initUnfinished: u32 = unsafe { ::std::mem::transmute(initUnfinished) };
            initUnfinished as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let FWUpdating: u32 = unsafe { ::std::mem::transmute(FWUpdating) };
            FWUpdating as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct for TOPIC_GIMBAL_STATUS"]
pub type T_DjiFcSubscriptionGimbalStatus = GimbalStatus;
#[doc = " @brief Flight status information topic data structure. It can be any value of ::E_DjiFcSubscriptionFlightStatus."]
pub type T_DjiFcSubscriptionFlightStatus = u8;
pub type T_DjiFcSubscriptionDisplaymode = u8;
pub type T_DjiFcSubscriptionLandinggear = u8;
pub type T_DjiFcSubscriptionMotorStartError = u16;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFcSubscriptionSingleBatteryState {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl T_DjiFcSubscriptionSingleBatteryState {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn cellBreak(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cellBreak(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn selfCheckError(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_selfCheckError(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn batteryClosedReason(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_batteryClosedReason(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn batSOHState(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_batSOHState(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn maxCycleLimit(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_maxCycleLimit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lessBattery(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_lessBattery(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn batteryCommunicationAbnormal(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_batteryCommunicationAbnormal(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hasCellBreak(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hasCellBreak(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn isBatteryEmbed(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_isBatteryEmbed(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn heatState(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_heatState(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn socState(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_socState(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32,
        cellBreak: u32,
        selfCheckError: u32,
        reserved1: u32,
        batteryClosedReason: u32,
        reserved2: u8,
        batSOHState: u8,
        maxCycleLimit: u8,
        reserved3: u8,
        lessBattery: u16,
        batteryCommunicationAbnormal: u16,
        reserved4: u16,
        hasCellBreak: u16,
        reserved5: u16,
        isBatteryEmbed: u16,
        heatState: u16,
        socState: u16,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let cellBreak: u32 = unsafe { ::std::mem::transmute(cellBreak) };
            cellBreak as u64
        });
        __bindgen_bitfield_unit.set(17usize, 3u8, {
            let selfCheckError: u32 = unsafe { ::std::mem::transmute(selfCheckError) };
            selfCheckError as u64
        });
        __bindgen_bitfield_unit.set(20usize, 7u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let batteryClosedReason: u32 = unsafe { ::std::mem::transmute(batteryClosedReason) };
            batteryClosedReason as u64
        });
        __bindgen_bitfield_unit.set(32usize, 6u8, {
            let reserved2: u8 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(38usize, 2u8, {
            let batSOHState: u8 = unsafe { ::std::mem::transmute(batSOHState) };
            batSOHState as u64
        });
        __bindgen_bitfield_unit.set(40usize, 6u8, {
            let maxCycleLimit: u8 = unsafe { ::std::mem::transmute(maxCycleLimit) };
            maxCycleLimit as u64
        });
        __bindgen_bitfield_unit.set(46usize, 2u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let lessBattery: u16 = unsafe { ::std::mem::transmute(lessBattery) };
            lessBattery as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let batteryCommunicationAbnormal: u16 =
                unsafe { ::std::mem::transmute(batteryCommunicationAbnormal) };
            batteryCommunicationAbnormal as u64
        });
        __bindgen_bitfield_unit.set(50usize, 3u8, {
            let reserved4: u16 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let hasCellBreak: u16 = unsafe { ::std::mem::transmute(hasCellBreak) };
            hasCellBreak as u64
        });
        __bindgen_bitfield_unit.set(54usize, 4u8, {
            let reserved5: u16 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let isBatteryEmbed: u16 = unsafe { ::std::mem::transmute(isBatteryEmbed) };
            isBatteryEmbed as u64
        });
        __bindgen_bitfield_unit.set(59usize, 2u8, {
            let heatState: u16 = unsafe { ::std::mem::transmute(heatState) };
            heatState as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let socState: u16 = unsafe { ::std::mem::transmute(socState) };
            socState as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Battery information topic data structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct BatteryWholeInfo {
    #[doc = "< Battery capacity, unit: mAh."]
    pub capacity: u32,
    #[doc = "< Battery voltage, unit: mV."]
    pub voltage: i32,
    #[doc = "< Battery current, unit: mA."]
    pub current: i32,
    #[doc = "< Battery capacity percentage, unit: 1%."]
    pub percentage: u8,
}
#[doc = " @brief Battery information topic data structure."]
pub type T_DjiFcSubscriptionWholeBatteryInfo = BatteryWholeInfo;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct BatterySingleInfo {
    pub reserve: u8,
    pub batteryIndex: u8,
    #[doc = "< uint: mV."]
    pub currentVoltage: i32,
    #[doc = "< uint: mA."]
    pub currentElectric: i32,
    #[doc = "< uint: mAh."]
    pub fullCapacity: u32,
    #[doc = "< uint: mAh."]
    pub remainedCapacity: u32,
    #[doc = "< uint: 0.1℃."]
    pub batteryTemperature: i16,
    pub cellCount: u8,
    #[doc = "< uint: %."]
    pub batteryCapacityPercent: u8,
    pub batteryState: T_DjiFcSubscriptionSingleBatteryState,
    pub reserve1: u8,
    pub reserve2: u8,
    #[doc = "< Relative power percentage."]
    pub SOP: u8,
}
pub type T_DjiFcSubscriptionSingleBatteryInfo = BatterySingleInfo;
#[doc = " @brief struct for TOPIC_CONTROL_DEVICE and data broadcast, return SDK info"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDKCtrlInfo {
    pub __bindgen_anon_1: SDKCtrlInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDKCtrlInfo__bindgen_ty_1 {
    pub __bindgen_anon_1: SDKCtrlInfo__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: SDKCtrlInfo__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SDKCtrlInfo__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< enum-type: E_DJIFcSubscriptionControlMode."]
    pub controlMode: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl SDKCtrlInfo__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn deviceStatus(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_deviceStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flightStatus(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flightStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vrcStatus(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vrcStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        deviceStatus: u8,
        flightStatus: u8,
        vrcStatus: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let deviceStatus: u8 = unsafe { ::std::mem::transmute(deviceStatus) };
            deviceStatus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flightStatus: u8 = unsafe { ::std::mem::transmute(flightStatus) };
            flightStatus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let vrcStatus: u8 = unsafe { ::std::mem::transmute(vrcStatus) };
            vrcStatus as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SDKCtrlInfo__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< enum-type: E_DJIFcSubscriptionControlAuthority."]
    pub controlAuthority: u8,
    #[doc = "< enum-type: E_DJIFcSubscriptionAuthorityChangeReason."]
    pub controlAuthorityChangeReason: u8,
}
impl Default for SDKCtrlInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SDKCtrlInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief struct for TOPIC_CONTROL_DEVICE and data broadcast, return SDK info"]
pub type T_DjiFcSubscriptionControlDevice = SDKCtrlInfo;
#[doc = " @brief sub struct for TOPIC_HARD_SYNC"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct SyncTimestamp {
    #[doc = "< clock time in multiples of 2.5ms. Sync timer runs at\n400Hz, this field increments in integer steps"]
    pub time2p5ms: u32,
    #[doc = "< nanosecond time offset from the 2.5ms pulse"]
    pub time1ns: u32,
    #[doc = "< clock time in multiple of 2.5ms elapsed since the\nhardware sync started"]
    pub resetTime2p5ms: u32,
    #[doc = "< This is the tag field you filled out when using the\nsetSyncFreq API above; use it to identify the packets that\nhave sync data. This is useful when you call the\nsetSyncFreq API with freqInHz = 0, so you get a single\npulse that can be uniquely identified with a tag - allowing\nyou to create your own pulse train with uniquely\nidentifiable pulses."]
    pub index: u16,
    #[doc = "< This is true when the packet corresponds to a hardware\npulse and false otherwise. This is useful because you can\nrequest the software packet to be sent at a higher frequency\nthat the hardware line."]
    pub flag: u8,
}
#[doc = " @brief struct for TOPIC_HARD_SYNC"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct HardSyncData {
    #[doc = "< time stamp for the incoming data"]
    pub ts: SyncTimestamp,
    #[doc = "< quaternion"]
    pub q: Quaternion,
    #[doc = "< accelerometer reading unit: g"]
    pub a: T_DjiVector3f,
    #[doc = "< gyro reading unit: rad/sec"]
    pub w: T_DjiVector3f,
}
#[doc = " @brief struct for TOPIC_HARD_SYNC"]
pub type T_DjiFcSubscriptionHardSync = HardSyncData;
pub type T_DjiFcSubscriptionGpsControlLevel = u8;
#[doc = " @brief struct for TOPIC_RC_WITH_FLAG_DATA"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct RCWithFlagData {
    #[doc = "< down = -0.999, middle = 0.000, up   =0.999"]
    pub pitch: dji_f32_t,
    #[doc = "< left = -0.999, middle = 0.000, right=0.999"]
    pub roll: dji_f32_t,
    #[doc = "< left = -0.999, middle = 0.000, right=0.999"]
    pub yaw: dji_f32_t,
    #[doc = "< down = -0.999, middle = 0.000, up   =0.999"]
    pub throttle: dji_f32_t,
    pub flag: RCWithFlagData__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct RCWithFlagData__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl RCWithFlagData__bindgen_ty_1 {
    #[inline]
    pub fn logicConnected(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_logicConnected(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skyConnected(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skyConnected(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn groundConnected(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_groundConnected(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn appConnected(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_appConnected(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        logicConnected: u8,
        skyConnected: u8,
        groundConnected: u8,
        appConnected: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let logicConnected: u8 = unsafe { ::std::mem::transmute(logicConnected) };
            logicConnected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skyConnected: u8 = unsafe { ::std::mem::transmute(skyConnected) };
            skyConnected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let groundConnected: u8 = unsafe { ::std::mem::transmute(groundConnected) };
            groundConnected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let appConnected: u8 = unsafe { ::std::mem::transmute(appConnected) };
            appConnected as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct for TOPIC_RC_WITH_FLAG_DATA"]
pub type T_DjiFcSubscriptionRCWithFlagData = RCWithFlagData;
#[doc = " @brief struct for status of each individual esc"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ESCStatusIndividual {
    #[doc = "< ESC current, unit: mA"]
    pub current: i16,
    #[doc = "< ESC speed, unit: rpm"]
    pub speed: i16,
    #[doc = "< Input power from battery to ESC, unit: mV"]
    pub voltage: u16,
    #[doc = "< ESC temperature, unit: degree C"]
    pub temperature: i16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl ESCStatusIndividual {
    #[inline]
    pub fn stall(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_stall(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn empty(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_empty(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unbalanced(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_unbalanced(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escDisconnected(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_escDisconnected(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temperatureHigh(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_temperatureHigh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        stall: u16,
        empty: u16,
        unbalanced: u16,
        escDisconnected: u16,
        temperatureHigh: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let stall: u16 = unsafe { ::std::mem::transmute(stall) };
            stall as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let empty: u16 = unsafe { ::std::mem::transmute(empty) };
            empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let unbalanced: u16 = unsafe { ::std::mem::transmute(unbalanced) };
            unbalanced as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let escDisconnected: u16 = unsafe { ::std::mem::transmute(escDisconnected) };
            escDisconnected as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let temperatureHigh: u16 = unsafe { ::std::mem::transmute(temperatureHigh) };
            temperatureHigh as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct for TOPIC_ESC_DATA"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct EscData {
    pub esc: [ESCStatusIndividual; 8usize],
}
#[doc = " @brief struct for TOPIC_ESC_DATA"]
pub type T_DjiFcSubscriptionEscData = EscData;
#[doc = " @brief struct indicating RTK GPS Connection"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct RTKConnectStatus {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl RTKConnectStatus {
    #[inline]
    pub fn rtkConnected(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rtkConnected(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserve(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserve(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rtkConnected: u16, reserve: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rtkConnected: u16 = unsafe { ::std::mem::transmute(rtkConnected) };
            rtkConnected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let reserve: u16 = unsafe { ::std::mem::transmute(reserve) };
            reserve as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct indicating RTK GPS Connection"]
pub type T_DjiFcSubscriptionRTKConnectStatus = RTKConnectStatus;
pub type T_DjiFcSubscriptionGimbalControlMode = u8;
#[doc = " @brief struct for TOPIC_FLIGHT_ANOMALY"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct FlightAnomaly {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl FlightAnomaly {
    #[inline]
    pub fn impactInAir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_impactInAir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn randomFly(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_randomFly(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn heightCtrlFail(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_heightCtrlFail(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rollPitchCtrlFail(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rollPitchCtrlFail(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yawCtrlFail(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_yawCtrlFail(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aircraftIsFalling(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aircraftIsFalling(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strongWindLevel1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strongWindLevel1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn strongWindLevel2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_strongWindLevel2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compassInstallationError(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compassInstallationError(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn imuInstallationError(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_imuInstallationError(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn escTemperatureHigh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_escTemperatureHigh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn atLeastOneEscDisconnected(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_atLeastOneEscDisconnected(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpsYawError(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpsYawError(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        impactInAir: u32,
        randomFly: u32,
        heightCtrlFail: u32,
        rollPitchCtrlFail: u32,
        yawCtrlFail: u32,
        aircraftIsFalling: u32,
        strongWindLevel1: u32,
        strongWindLevel2: u32,
        compassInstallationError: u32,
        imuInstallationError: u32,
        escTemperatureHigh: u32,
        atLeastOneEscDisconnected: u32,
        gpsYawError: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let impactInAir: u32 = unsafe { ::std::mem::transmute(impactInAir) };
            impactInAir as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let randomFly: u32 = unsafe { ::std::mem::transmute(randomFly) };
            randomFly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let heightCtrlFail: u32 = unsafe { ::std::mem::transmute(heightCtrlFail) };
            heightCtrlFail as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rollPitchCtrlFail: u32 = unsafe { ::std::mem::transmute(rollPitchCtrlFail) };
            rollPitchCtrlFail as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let yawCtrlFail: u32 = unsafe { ::std::mem::transmute(yawCtrlFail) };
            yawCtrlFail as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let aircraftIsFalling: u32 = unsafe { ::std::mem::transmute(aircraftIsFalling) };
            aircraftIsFalling as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let strongWindLevel1: u32 = unsafe { ::std::mem::transmute(strongWindLevel1) };
            strongWindLevel1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let strongWindLevel2: u32 = unsafe { ::std::mem::transmute(strongWindLevel2) };
            strongWindLevel2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let compassInstallationError: u32 =
                unsafe { ::std::mem::transmute(compassInstallationError) };
            compassInstallationError as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let imuInstallationError: u32 = unsafe { ::std::mem::transmute(imuInstallationError) };
            imuInstallationError as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let escTemperatureHigh: u32 = unsafe { ::std::mem::transmute(escTemperatureHigh) };
            escTemperatureHigh as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let atLeastOneEscDisconnected: u32 =
                unsafe { ::std::mem::transmute(atLeastOneEscDisconnected) };
            atLeastOneEscDisconnected as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let gpsYawError: u32 = unsafe { ::std::mem::transmute(gpsYawError) };
            gpsYawError as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct for TOPIC_FLIGHT_ANOMALY"]
pub type T_DjiFcSubscriptionFlightAnomaly = FlightAnomaly;
#[doc = " @brief struct for TOPIC_POSITION_VO"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct PositionVO {
    #[doc = "< North (best effort), unit: m"]
    pub x: dji_f32_t,
    #[doc = "< East (best effort),  unit: m"]
    pub y: dji_f32_t,
    #[doc = "< Down,  unit: m"]
    pub z: dji_f32_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl PositionVO {
    #[inline]
    pub fn xHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_xHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_yHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xHealth: u8,
        yHealth: u8,
        zHealth: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let xHealth: u8 = unsafe { ::std::mem::transmute(xHealth) };
            xHealth as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let yHealth: u8 = unsafe { ::std::mem::transmute(yHealth) };
            yHealth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let zHealth: u8 = unsafe { ::std::mem::transmute(zHealth) };
            zHealth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct for TOPIC_POSITION_VO"]
pub type T_DjiFcSubscriptionPositionVO = PositionVO;
#[doc = " @brief struct for data broadcast and subscription, return obstacle info around the vehicle\n"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct RelativePosition {
    #[doc = "< distance from obstacle (m)"]
    pub down: dji_f32_t,
    #[doc = "< distance from obstacle (m)"]
    pub front: dji_f32_t,
    #[doc = "< distance from obstacle (m)"]
    pub right: dji_f32_t,
    #[doc = "< distance from obstacle (m)"]
    pub back: dji_f32_t,
    #[doc = "< distance from obstacle (m)"]
    pub left: dji_f32_t,
    #[doc = "< distance from obstacle (m)"]
    pub up: dji_f32_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl RelativePosition {
    #[inline]
    pub fn downHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_downHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frontHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frontHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rightHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rightHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn backHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_backHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn leftHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_leftHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn upHealth(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_upHealth(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        downHealth: u8,
        frontHealth: u8,
        rightHealth: u8,
        backHealth: u8,
        leftHealth: u8,
        upHealth: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let downHealth: u8 = unsafe { ::std::mem::transmute(downHealth) };
            downHealth as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let frontHealth: u8 = unsafe { ::std::mem::transmute(frontHealth) };
            frontHealth as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rightHealth: u8 = unsafe { ::std::mem::transmute(rightHealth) };
            rightHealth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let backHealth: u8 = unsafe { ::std::mem::transmute(backHealth) };
            backHealth as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let leftHealth: u8 = unsafe { ::std::mem::transmute(leftHealth) };
            leftHealth as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let upHealth: u8 = unsafe { ::std::mem::transmute(upHealth) };
            upHealth as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief struct for data broadcast and subscription, return obstacle info around the vehicle\n"]
pub type T_DjiFcSubscriptionAvoidData = RelativePosition;
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_HOME_POINT_SET_STATUS. Specifies homepoint was set or not,\n it can be any value of ::E_DjiFcSubscriptionHomePointSetStatus."]
pub type T_DjiFcSubscriptionHomePointSetStatus = u8;
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_HOME_POINT_INFO. Specifies homepoint."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct HomeLocationData {
    #[doc = "< unit: rad"]
    pub latitude: dji_f64_t,
    #[doc = "< unit: rad"]
    pub longitude: dji_f64_t,
}
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_HOME_POINT_INFO. Specifies homepoint."]
pub type T_DjiFcSubscriptionHomePointInfo = HomeLocationData;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct GimbalSingleData {
    pub roll: dji_f32_t,
    pub pitch: dji_f32_t,
    pub yaw: dji_f32_t,
}
pub type GimbalAnglesData = GimbalSingleData;
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_THREE_GIMBAL_DATA. Used in M300"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct GimbalThreeData {
    pub anglesData: [GimbalAnglesData; 3usize],
}
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_THREE_GIMBAL_DATA. Used in M300"]
pub type T_DjiFcSubscriptionThreeGimbalData = GimbalThreeData;
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_IMU_ATTI_NAVI_DATA_WITH_TIMESTAMP. Used in M300"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct ImuAttiNaviDataWithTimestamp {
    pub version: u16,
    pub flag: u16,
    pub pn_x: dji_f32_t,
    pub pn_y: dji_f32_t,
    pub pn_z: dji_f32_t,
    pub vn_x: dji_f32_t,
    pub vn_y: dji_f32_t,
    pub vn_z: dji_f32_t,
    pub an_x: dji_f32_t,
    pub an_y: dji_f32_t,
    pub an_z: dji_f32_t,
    pub q: [dji_f32_t; 4usize],
    pub resv: u16,
    pub cnt: u16,
    pub timestamp: u32,
}
#[doc = " @brief Struct for the topic DJI_FC_SUBSCRIPTION_TOPIC_IMU_ATTI_NAVI_DATA_WITH_TIMESTAMP. Used in M300"]
pub type T_DjiFcSubscriptionImuAttiNaviDataWithTimestamp = ImuAttiNaviDataWithTimestamp;
extern "C" {
    #[doc = " @brief Initialise data subscription module in blocking mode. This function has to be called before subscribing any\n data, to initialize run environment of data subscription module, if need to subscribe data from aircraft.\n @note Max execution time of this function is slightly larger than 500ms.\n @note This function has to be called in user task, rather than main() function, and after scheduler being started.\n @return Execution result."]
    pub fn DjiFcSubscription_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialize data subscription module. When data subscription will no longer be used, can call this function\n to deinitialize the data subscription module. Deinitialization function will help to release all system resource data\n subscription has occupied.\n @return Execution result."]
    pub fn DjiFcSubscription_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Subscribe a topic in blocking mode. Before subscribing any data from aircraft, DjiFcSubscription_Init()\n function has to be called.\n @details User can subscribe a topic by specifying topic name, push frequency and callback function used to receive\n data of topic (if needed). After subscribing successfully, the user can call\n DjiFcSubscription_GetLatestValueOfTopic() function to get the latest data of the topic have been\n subscribed and the corresponding timestamp when aircraft sends the data out, and the callback function will be called to\n push data of the topic and corresponding timestamp if the callback function is specified.\n @note Max execution time of this function is slightly larger than 1200ms.\n @note Topic to be subscribed can not have been subscribed, that is, one topic can not be subscribed repeatedly.\n @note User must ensure that types of subscription frequency of all topics have been subscribed is less than or\n equal to 4. Otherwise, the subscribing topic will fail.\n @note User must ensure that the data length sum of all topics of the same subscription frequency is less than or equal to 242.\n @param topic: topic name to be subscribed.\n @param frequency: subscription frequency of topic to be subscribed. Subscription frequency can not beyond max\n frequency limitation of the topic and must be the value of enum E_DjiFcSubscriptionTopicFreq. And, subscription\n frequency has to be larger than 0. Users can find max frequency of topics in data subscription part of documentation\n on developer website (developer.dji.com).\n @param callback: callback function used to receive data of topic to be subscribed. If the callback function is not needed,\n this item can be set as NULL.\n @return Execution result."]
    pub fn DjiFcSubscription_SubscribeTopic(
        topic: E_DjiFcSubscriptionTopic,
        frequency: E_DjiDataSubscriptionTopicFreq,
        callback: DjiReceiveDataOfTopicCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Unsubscribe a topic in blocking mode. Before unsubscribing any data from aircraft, DjiFcSubscription_Init()\n and DjiFcSubscription_SubscribeTopic() function has to be called,\n @details User can unsubscribe a topic by specifying topic name, but the topic must be unsubscribed in the order of subscription.\n @note Topic to be unsubscribed must have been subscribed.\n @note Topic to be unsubscribed must be in the order of subscription, similar to a queue, subscription is similar to enqueue,\n unsubscription is similar to dequeue.\n @param topic: topic name to be unsubscribed.\n @return Execution result."]
    pub fn DjiFcSubscription_UnSubscribeTopic(topic: E_DjiFcSubscriptionTopic) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the latest data value and timestamp in aircraft time system when sending the data from aircraft of specified\n topic. If the specified topic has not been subscribed successfully, this function will return the error code.\n @note After calling this function, user need transfer type of data pointer that pointer to data of topic to\n corresponding data structure pointer for getting every item of the topic conveniently.\n @param topicName: topic name to be gotten value.\n @param data: pointer to memory space used to store data of the topic. The memory space used to store data of topic\n have to have been allocated correctly and should ensure its size is equal to data structure size corresponding to\n the topic, otherwise, this function will not be able to return data and timestamp (return error code).\n @param dataSizeOfTopic: the size of memory space used to store data of topic. Normally, this size is equal to data\n structure size corresponding to the topic. If this size is not equal to the size of the memory space, may cause memory\n overflow event\n @param timestamp: pointer to memory space used to store timestamps. The memory space used to store timestamps\n have to have been allocated correctly, and should ensure its size is equal to data structure size of timestamp,\n otherwise, this function will not be able to return data and timestamp (return error code) or even cause memory\n overflow event. If the user does not need timestamp information, can fill in NULL. Use flight controller power-on\n timestamp on M300 RTK. Use payload local timestamp on M30/M30T.\n @return Execution result."]
    pub fn DjiFcSubscription_GetLatestValueOfTopic(
        topic: E_DjiFcSubscriptionTopic,
        data: *mut u8,
        dataSizeOfTopic: u16,
        timestamp: *mut T_DjiDataTimestamp,
    ) -> T_DjiReturnCode;
}
pub type E_DjiFlightControllerGoHomeAltitude = u16;
#[doc = "< Aircraft will execute hover action when RC is lost."]
pub const E_DjiFlightControllerRCLostAction_DJI_FLIGHT_CONTROLLER_RC_LOST_ACTION_HOVER:
    E_DjiFlightControllerRCLostAction = 0;
#[doc = "< Aircraft will execute land action when RC is lost."]
pub const E_DjiFlightControllerRCLostAction_DJI_FLIGHT_CONTROLLER_RC_LOST_ACTION_LANDING:
    E_DjiFlightControllerRCLostAction = 1;
#[doc = "< Aircraft will execute go-home action when RC is lost."]
pub const E_DjiFlightControllerRCLostAction_DJI_FLIGHT_CONTROLLER_RC_LOST_ACTION_GOHOME:
    E_DjiFlightControllerRCLostAction = 2;
#[doc = " @brief The aircraft's actions when RC is lost."]
pub type E_DjiFlightControllerRCLostAction = ::std::os::raw::c_uint;
#[doc = "< 0: The aircraft will use GPS data instead of RTK data to execute\n actions which requires location information(waypoint, go home...)"]
pub const E_DjiFlightControllerRtkPositionEnableStatus_DJI_FLIGHT_CONTROLLER_DISABLE_RTK_POSITION : E_DjiFlightControllerRtkPositionEnableStatus = 0 ;
#[doc = "< 1:The aircraft will use RTK data instead of GPS data to execute\n actions which requires location information(waypoint, go home...)"]
pub const E_DjiFlightControllerRtkPositionEnableStatus_DJI_FLIGHT_CONTROLLER_ENABLE_RTK_POSITION:
    E_DjiFlightControllerRtkPositionEnableStatus = 1;
#[doc = " @brief Enable/Disable RTK position enum"]
pub type E_DjiFlightControllerRtkPositionEnableStatus = ::std::os::raw::c_uint;
#[doc = "< 0: The aircraft will not perform obstacle sensing in\n the specified direction"]
pub const E_DjiFlightControllerObstacleAvoidanceEnableStatus_DJI_FLIGHT_CONTROLLER_DISABLE_OBSTACLE_AVOIDANCE : E_DjiFlightControllerObstacleAvoidanceEnableStatus = 0 ;
#[doc = "< 0: The aircraft will perform obstacle sensing in the\n specified direction"]
pub const E_DjiFlightControllerObstacleAvoidanceEnableStatus_DJI_FLIGHT_CONTROLLER_ENABLE_OBSTACLE_AVOIDANCE : E_DjiFlightControllerObstacleAvoidanceEnableStatus = 1 ;
#[doc = " @brief Enable/Disable obstacle sensing enum"]
pub type E_DjiFlightControllerObstacleAvoidanceEnableStatus = ::std::os::raw::c_uint;
#[doc = "< Execute emergency-stop-motor action"]
pub const E_DjiFlightControllerEmergencyStopMotor_DJI_FLIGHT_CONTROLLER_ENABLE_EMERGENCY_STOP_MOTOR : E_DjiFlightControllerEmergencyStopMotor = 1 ;
#[doc = " @brief Enable/Disable emergency stop motor function enum\n @note Enable emergency-stop-motor function is very dangerous in the air. It will make the aircraft crash!!!"]
pub type E_DjiFlightControllerEmergencyStopMotor = ::std::os::raw::c_uint;
#[doc = "< Obtain joystick permission"]
pub const E_DjiFlightControllerJoystickCtrlAuthorityAction_DJI_FLIGHT_CONTROLLER_RELEASE_JOYSTICK_CTRL_AUTHORITY : E_DjiFlightControllerJoystickCtrlAuthorityAction = 0 ;
#[doc = "< Release joystick permission"]
pub const E_DjiFlightControllerJoystickCtrlAuthorityAction_DJI_FLIGHT_CONTROLLER_OBTAIN_JOYSTICK_CTRL_AUTHORITY : E_DjiFlightControllerJoystickCtrlAuthorityAction = 1 ;
#[doc = " @brief Obtain/Release joystick control permission command enum\n @note You have obtained joystick control permission successfully before using joystick."]
pub type E_DjiFlightControllerJoystickCtrlAuthorityAction = ::std::os::raw::c_uint;
#[doc = "< RC could control aircraft with joystick."]
pub const E_DjiFlightControllerJoystickCtrlAuthority_DJI_FLIGHT_CONTROLLER_JOYSTICK_CTRL_AUTHORITY_RC : E_DjiFlightControllerJoystickCtrlAuthority = 0 ;
#[doc = "< MSDK could control aircraft with joystick."]
pub const E_DjiFlightControllerJoystickCtrlAuthority_DJI_FLIGHT_CONTROLLER_JOYSTICK_CTRL_AUTHORITY_MSDK : E_DjiFlightControllerJoystickCtrlAuthority = 1 ;
#[doc = "< Special Internal modules could control aircraft\n with joystick."]
pub const E_DjiFlightControllerJoystickCtrlAuthority_DJI_FLIGHT_CONTROLLER_JOYSTICK_CTRL_AUTHORITY_INTERNAL : E_DjiFlightControllerJoystickCtrlAuthority = 2 ;
#[doc = "< PSDK could control aircraft with joystick."]
pub const E_DjiFlightControllerJoystickCtrlAuthority_DJI_FLIGHT_CONTROLLER_JOYSTICK_CTRL_AUTHORITY_OSDK : E_DjiFlightControllerJoystickCtrlAuthority = 4 ;
#[doc = " @brief The aircraft's joystick control permission owner enum"]
pub type E_DjiFlightControllerJoystickCtrlAuthority = ::std::os::raw::c_uint;
#[doc = "< MSDK gets the joystick control permission."]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_MSDK_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 1 ;
#[doc = "< A specific internal modules gets the joystick control permission."]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_INTERNAL_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 2 ;
#[doc = "< PSDK gets the joystick control permission."]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_OSDK_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 3 ;
#[doc = "< Reset the joystick control permission to RC when executing RC lost action"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_RC_LOST_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 4 ;
#[doc = "< Reset the joystick control permission to RC when RC is not in P mode"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_RC_NOT_P_MODE_RESET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 5 ;
#[doc = "< Set the joystick control permission to RC when RC switches control mode(T/APS)"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_RC_SWITCH_MODE_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 6 ;
#[doc = "< Reset the joystick control permission to RC when RC pauses"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_RC_PAUSE_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 7 ;
#[doc = "< Reset the joystick control permission to RC when RC requests to go home"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_RC_REQUEST_GO_HOME_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 8 ;
#[doc = "< Reset the joystick control permission to RC when aircraft is executing low-battery-go-home"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_LOW_BATTERY_GO_HOME_RESET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 9 ;
#[doc = "< Reset the joystick control permission to RC when aircraft is executing low-battery-landing"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_LOW_BATTERY_LANDING_RESET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 10 ;
#[doc = "< Reset the joystick control permission to RC when PSDK is lost"]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_OSDK_LOST_GET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 11 ;
#[doc = "< Reset the joystick control permission to RC when aircraft is near boundary."]
pub const E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent_DJI_FLIGHT_CONTROLLER_NERA_FLIGHT_BOUNDARY_RESET_JOYSTICK_CTRL_AUTH_EVENT : E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = 12 ;
#[doc = " @brief The aircraft's joystick control permission switch reason enum"]
pub type E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent = ::std::os::raw::c_uint;
#[doc = " @brief The aircraft's joystick control permission switch event info enum"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFlightControllerJoystickCtrlAuthorityEventInfo {
    #[doc = "< The aircraft's joystick control permission owner"]
    pub curJoystickCtrlAuthority: E_DjiFlightControllerJoystickCtrlAuthority,
    #[doc = "< The aircraft's joystick control permission switch reason"]
    pub joystickCtrlAuthoritySwitchEvent: E_DjiFlightControllerJoystickCtrlAuthoritySwitchEvent,
}
impl Default for T_DjiFlightControllerJoystickCtrlAuthorityEventInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Prototype of callback function used to get joystick control permission switch event info.\n @return Execution result."]
pub type JoystickCtrlAuthorityEventCbFunc = ::std::option::Option<
    unsafe extern "C" fn(
        eventData: T_DjiFlightControllerJoystickCtrlAuthorityEventInfo,
    ) -> T_DjiReturnCode,
>;
#[doc = " @brief Prototype of callback function used to get the trigger FTS event.\n @return Execution result."]
pub type TriggerFtsEventCallback = ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>;
#[doc = " @brief Control pitch & roll & angle of the aircraft.\n @note Need to be referenced to either the ground or body frame by E_DjiFlightControllerHorizontalCoordinate setting.\n Limit: -35 degree to 35 degree"]
pub const E_DjiFlightControllerHorizontalControlMode_DJI_FLIGHT_CONTROLLER_HORIZONTAL_ANGLE_CONTROL_MODE : E_DjiFlightControllerHorizontalControlMode = 0 ;
#[doc = " @brief Set the control mode to control horizontal vehicle velocities.\n @note Need to be referenced to either the ground or body frame by E_DjiFlightControllerHorizontalCoordinate setting\n Limit: -30m/s to 30 m/s"]
pub const E_DjiFlightControllerHorizontalControlMode_DJI_FLIGHT_CONTROLLER_HORIZONTAL_VELOCITY_CONTROL_MODE : E_DjiFlightControllerHorizontalControlMode = 1 ;
#[doc = " @brief Set the control mode to control position offsets of pitch & roll directions.\n @note Need to be referenced to either the ground or body frame by E_DjiFlightControllerHorizontalCoordinate setting\n Limit: N/A"]
pub const E_DjiFlightControllerHorizontalControlMode_DJI_FLIGHT_CONTROLLER_HORIZONTAL_POSITION_CONTROL_MODE : E_DjiFlightControllerHorizontalControlMode = 2 ;
#[doc = " @brief Set the control mode to control rate of change of the vehicle's attitude.\n @note Need to be referenced to either the ground or body frame by E_DjiFlightControllerHorizontalCoordinate setting\n Limit: -150deg/s to 150.0 deg/s"]
pub const E_DjiFlightControllerHorizontalControlMode_DJI_FLIGHT_CONTROLLER_HORIZONTAL_ANGULAR_RATE_CONTROL_MODE : E_DjiFlightControllerHorizontalControlMode = 3 ;
#[doc = " @brief Horizon control mode in joystick mode enum\n @note Only when the GPS signal is good (health_flag >=3)，horizontal position control (DJI_FLIGHT_CONTROLLER_HORIZONTAL_POSITION_CONTROL_MODE)\n related control modes can be used. Only when GPS signal is good (health_flag >=3)，or advanced sensing system is working properly with Autopilot，\n horizontal velocity control（DJI_FLIGHT_CONTROLLER_HORIZONTAL_VELOCITY_CONTROL_MODE) related control modes can be used."]
pub type E_DjiFlightControllerHorizontalControlMode = ::std::os::raw::c_uint;
#[doc = " @brief Set the control mode to control the vertical speed of aircraft, setting the upward as positive/\n @note Limit: -5 m/s to 5 m/s"]
pub const E_DjiFlightControllerVerticalControlMode_DJI_FLIGHT_CONTROLLER_VERTICAL_VELOCITY_CONTROL_MODE : E_DjiFlightControllerVerticalControlMode = 0 ;
#[doc = " @brief Set the control mode to control the height of aircraft\n @note Limit: 0 m to 120 m"]
pub const E_DjiFlightControllerVerticalControlMode_DJI_FLIGHT_CONTROLLER_VERTICAL_POSITION_CONTROL_MODE : E_DjiFlightControllerVerticalControlMode = 1 ;
#[doc = " @brief Set the control mode to directly control the thrust\n @note Range: 0 % to 100 %"]
pub const E_DjiFlightControllerVerticalControlMode_DJI_FLIGHT_CONTROLLER_VERTICAL_THRUST_CONTROL_MODE : E_DjiFlightControllerVerticalControlMode = 2 ;
#[doc = " @brief Vertical control mode enum in joystick mode\n @note We don not recommend using VERTICAL_POSITION control mode indoors when the aircraft's flying height exceeds 3 meters.\n This is because barometer can be inaccurate indoors, and the vertical controller may fail to keep the height of the aircraft."]
pub type E_DjiFlightControllerVerticalControlMode = ::std::os::raw::c_uint;
#[doc = " @brief Set the control mode to control yaw angle.\n @note Yaw angle is referenced to the ground frame. In this control mode, Ground frame is enforced in Autopilot."]
pub const E_DjiFlightControllerYawControlMode_DJI_FLIGHT_CONTROLLER_YAW_ANGLE_CONTROL_MODE:
    E_DjiFlightControllerYawControlMode = 0;
#[doc = " @brief Set the control-mode to control yaw angular velocity\n @note Same reference frame as YAW_ANGLE.\n Limit: -150 deg/s to 150 deg/s"]
pub const E_DjiFlightControllerYawControlMode_DJI_FLIGHT_CONTROLLER_YAW_ANGLE_RATE_CONTROL_MODE:
    E_DjiFlightControllerYawControlMode = 1;
#[doc = " @brief Yaw control mode enum in joystick mode"]
pub type E_DjiFlightControllerYawControlMode = ::std::os::raw::c_uint;
#[doc = "< Set the x-y of ground frame as the horizontal frame (NEU)"]
pub const E_DjiFlightControllerHorizontalCoordinate_DJI_FLIGHT_CONTROLLER_HORIZONTAL_GROUND_COORDINATE : E_DjiFlightControllerHorizontalCoordinate = 0 ;
#[doc = "< Set the x-y of body frame as the horizontal frame (FRU)"]
pub const E_DjiFlightControllerHorizontalCoordinate_DJI_FLIGHT_CONTROLLER_HORIZONTAL_BODY_COORDINATE : E_DjiFlightControllerHorizontalCoordinate = 1 ;
#[doc = " @brief Horizontal coordinate enum in joystick mode"]
pub type E_DjiFlightControllerHorizontalCoordinate = ::std::os::raw::c_uint;
#[doc = "< Disable the stable mode"]
pub const E_DjiFlightControllerStableControlMode_DJI_FLIGHT_CONTROLLER_STABLE_CONTROL_MODE_DISABLE : E_DjiFlightControllerStableControlMode = 0 ;
#[doc = "< Enable the stable mode"]
pub const E_DjiFlightControllerStableControlMode_DJI_FLIGHT_CONTROLLER_STABLE_CONTROL_MODE_ENABLE : E_DjiFlightControllerStableControlMode = 1 ;
#[doc = " @brief Stable mode enum in joystick mode\n @note Only works in horizontal velocity control mode. In velocity stable mode, aircraft will brake and hover at one position once\n the input command is zero. In velocity non-stable mode, aircraft will follow the velocity command and not hover when the command is zero.\n That means aircraft will drift with the wind."]
pub type E_DjiFlightControllerStableControlMode = ::std::os::raw::c_uint;
pub const E_DjiFlightControllerRCLostActionEnableStatus_DJI_FLIGHT_CONTROLLER_ENABLE_RC_LOST_ACTION : E_DjiFlightControllerRCLostActionEnableStatus = 0 ;
pub const E_DjiFlightControllerRCLostActionEnableStatus_DJI_FLIGHT_CONTROLLER_DISABLE_RC_LOST_ACTION : E_DjiFlightControllerRCLostActionEnableStatus = 1 ;
pub type E_DjiFlightControllerRCLostActionEnableStatus = ::std::os::raw::c_uint;
#[doc = " @brief Joystick mode.\n @note You need to set joystick mode first before start to send joystick command to aircraft."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFlightControllerJoystickMode {
    #[doc = "< See reference of E_DjiFlightControllerHorizontalControlMode"]
    pub horizontalControlMode: E_DjiFlightControllerHorizontalControlMode,
    #[doc = "< See reference of E_DjiFlightControllerVerticalControlMode"]
    pub verticalControlMode: E_DjiFlightControllerVerticalControlMode,
    #[doc = "< See reference of E_DjiFlightControllerYawControlMode"]
    pub yawControlMode: E_DjiFlightControllerYawControlMode,
    #[doc = "< See reference of E_DjiFlightControllerHorizontalCoordinate"]
    pub horizontalCoordinate: E_DjiFlightControllerHorizontalCoordinate,
    #[doc = "< See reference of E_DjiFlightControllerStableControlMode"]
    pub stableControlMode: E_DjiFlightControllerStableControlMode,
}
impl Default for T_DjiFlightControllerJoystickMode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiFlightControllerJoystickCommand {
    #[doc = "< Controls the x axis."]
    pub x: dji_f32_t,
    #[doc = "< Controls the y axis."]
    pub y: dji_f32_t,
    #[doc = "< Controls the z axis, setting upward as positive."]
    pub z: dji_f32_t,
    #[doc = "< Yaw position/velocity control w.r.t. the ground frame."]
    pub yaw: dji_f32_t,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiFlightControllerHomeLocation {
    #[doc = "< unit: rad"]
    pub latitude: dji_f64_t,
    #[doc = "< unit: rad"]
    pub longitude: dji_f64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFlightControllerGeneralInfo {
    pub serialNum: [::std::os::raw::c_char; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiFlightControllerRidInfo {
    #[doc = "< unit: rad"]
    pub latitude: dji_f64_t,
    #[doc = "< unit: rad"]
    pub longitude: dji_f64_t,
    pub altitude: u16,
}
extern "C" {
    #[doc = " @brief Initialise flight controller module\n @param ridInfo: Must report the correct RID information before using PSDK to control the aircraft.\n @return Execution result."]
    pub fn DjiFlightController_Init(ridInfo: T_DjiFlightControllerRidInfo) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief DeInitialise flight controller module.\n @return Execution result."]
    pub fn DjiFlightController_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable RTK position function.\n @details Enabling RTK means that RTK data will be used instead of GPS during flight.\n @param rtkEnableStatus: refer to \"E_DjiFlightControllerRtkPositionEnableStatus\", inheriting from Pilot.\n @return Execution result."]
    pub fn DjiFlightController_SetRtkPositionEnableStatus(
        rtkEnableStatus: E_DjiFlightControllerRtkPositionEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get RTK enable status.\n @note Enabling RTK means that RTK data will be used during intelligent flight.\n @param rtkEnableStatus: refer to \"E_DjiFlightControllerRtkPositionEnableStatus\", inheriting from Pilot.\n @return Execution result."]
    pub fn DjiFlightController_GetRtkPositionEnableStatus(
        rtkEnableStatus: *mut E_DjiFlightControllerRtkPositionEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set RC lost action.\n @note Valid when RC and PSDK are both lost. It only supports M30.\n @param rcLostAction: actions when RC is lost.(hover/landing/go home).It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_SetRCLostAction(
        rcLostAction: E_DjiFlightControllerRCLostAction,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get RC lost action(hover/landing/gohome).\n @note Valid when RC and PSDK are both lost. It only supports M30.\n @param rcLostAction: see reference of E_DjiFlightControllerRCLostAction.It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_GetRCLostAction(
        rcLostAction: *mut E_DjiFlightControllerRCLostAction,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable horizontal visual(forwards,backwards,left,right) obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param horizontalObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_SetHorizontalVisualObstacleAvoidanceEnableStatus(
        horizontalObstacleAvoidanceEnableStatus: E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the switch status of horizontal visual(forwards,backwards,left,right) obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param horizontalObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_GetHorizontalVisualObstacleAvoidanceEnableStatus(
        horizontalObstacleAvoidanceEnableStatus : * mut E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable horizontal radar obstacle sensing.\n @note It will be valid only if you install CSM radar successfully.For detailed parameters of obstacle sensing,\n it is recommended to read the official user manual in https://www.dji.com.\n @param horizontalObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_SetHorizontalRadarObstacleAvoidanceEnableStatus(
        horizontalObstacleAvoidanceEnableStatus: E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the switch status of horizontal radar obstacle sensing.\n @note It will be valid only if you install CSM radar successfully.For detailed parameters of obstacle sensing,\n it is recommended to read the official user manual in https://www.dji.com/uk/matrice-300/downloads.\n @param horizontalObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_GetHorizontalRadarObstacleAvoidanceEnableStatus(
        horizontalObstacleAvoidanceEnableStatus : * mut E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable upwards visual obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param upwardsObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_SetUpwardsVisualObstacleAvoidanceEnableStatus(
        upwardsObstacleAvoidanceEnableStatus: E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the switch status of upwards visual obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param upwardsObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_GetUpwardsVisualObstacleAvoidanceEnableStatus(
        upwardsObstacleAvoidanceEnableStatus : * mut E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable upwards radar obstacle sensing.\n @note It will be valid only if you install CSM radar successfully.For detailed parameters of obstacle sensing,\n it is recommended to read the official user manual in https://www.dji.com.\n @param upwardsObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_SetUpwardsRadarObstacleAvoidanceEnableStatus(
        upwardsObstacleAvoidanceEnableStatus: E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the switch status of upwards radar obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param upwardsObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_GetUpwardsRadarObstacleAvoidanceEnableStatus(
        upwardsObstacleAvoidanceEnableStatus : * mut E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable/Disable downwards visual obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param downwardsObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_SetDownwardsVisualObstacleAvoidanceEnableStatus(
        downwardsObstacleAvoidanceEnableStatus: E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the switch status of downwards visual obstacle sensing.\n @note For detailed parameters of obstacle sensing, it is recommended to read the official user manual in\n https://www.dji.com.\n @param downwardsObstacleAvoidanceEnableStatus: see reference of E_DjiFlightControllerObstacleAvoidanceEnableStatus.\n It inherits from Pilot's param.\n @return Execution result."]
    pub fn DjiFlightController_GetDownwardsVisualObstacleAvoidanceEnableStatus(
        downwardsObstacleAvoidanceEnableStatus : * mut E_DjiFlightControllerObstacleAvoidanceEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Arrest flying means emergency braking\n @note When the aircraft is on the ground, it will stop motors and display \"hms description\" on App. when the aircraft is\n in the air, it will continue flying and display \"hms description\" on App only.\n If you use this interface, you need to use \"DjiFlightController_CancelArrestFlying\" to quit arrest-flying status, then\n then the aircraft can fly again.\n @return Execution result."]
    pub fn DjiFlightController_ArrestFlying() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Quit status of arrest-flying.\n @note The aircraft need to quit status of arrest-flying to continue flying after arresting flying.\n @return Execution result."]
    pub fn DjiFlightController_CancelArrestFlying() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Turn on motors when the aircraft is on the ground.\n @return Execution result."]
    pub fn DjiFlightController_TurnOnMotors() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Turn off motors when the aircraft is on the ground.\n @return Execution result."]
    pub fn DjiFlightController_TurnOffMotors() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Emergency stop motor in any case.\n @note If you want to turn on motor after emergency stopping motor, you need to use the interface to send disable\n command to quit lock-motor status.\n @param cmd: see reference of E_DjiFlightControllerEmergencyStopMotor\n @param debugMsg:inject debug message to flight control FW for logging, size limit: 10 bytes\n @return Execution result."]
    pub fn DjiFlightController_EmergencyStopMotor(
        cmd: E_DjiFlightControllerEmergencyStopMotor,
        debugMsg: *mut ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request taking off action when the aircraft is on the ground.\n @return Execution result."]
    pub fn DjiFlightController_StartTakeoff() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request landing action when the aircraft is in the air.\n @return Execution result."]
    pub fn DjiFlightController_StartLanding() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request cancelling landing action when the aircraft is landing\n @return Execution result."]
    pub fn DjiFlightController_CancelLanding() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Confirm the landing when the aircraft is 0.7 m above the ground.\n @note When the clearance between the aircraft and the ground is less than 0.7m, the aircraft will pause landing and\n wait for user's confirmation. This API is for confirm landing. If the ground is not suitable for landing, user\n must use RC to control it landing manually or force landing.\n @return Execution result."]
    pub fn DjiFlightController_StartConfirmLanding() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Force landing in any case.\n @note This API will ignore the smart landing function. When using this API, it will landing directly (would not stop\n at 0.7m and wait user's command). Attention: it may make the aircraft crash!!!\n @return Execution result."]
    pub fn DjiFlightController_StartForceLanding() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set customized GPS(not RTK) home location.\n @note Set customized home location failed reason may as follows:\n 1. The distance between new home location and last home location is larger than MAX_FLY_RADIUS(20 km).\n 2. Record initial home location failed after start aircraft.\n @param homeLocation: homeLocation include latitude and longitude\n @return Execution result."]
    pub fn DjiFlightController_SetHomeLocationUsingGPSCoordinates(
        homeLocation: T_DjiFlightControllerHomeLocation,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set home location using current aircraft GPS (not RTK) location.\n @note Set home location failed reasons may as follows:\n 1. Aircraft's gps level can't reach the condition of recording home location.\n 2. Record initial home location failed after start aircraft.\n @return Execution result."]
    pub fn DjiFlightController_SetHomeLocationUsingCurrentAircraftLocation() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set go home altitude.\n @note If aircraft's current altitude is higher than the setting value of go home altitude, aircraft will go home\n using current altitude. Otherwise, it will climb to setting of go home altitude ,and then execute go home action.\n Go home altitude setting is 20-1500 m.\n @param altitude: go home altitude, unit: meter\n @return Execution result."]
    pub fn DjiFlightController_SetGoHomeAltitude(
        altitude: E_DjiFlightControllerGoHomeAltitude,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get go home altitude.\n @param altitude: go home altitude, unit: meter\n @return Execution result."]
    pub fn DjiFlightController_GetGoHomeAltitude(
        altitude: *mut E_DjiFlightControllerGoHomeAltitude,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get country code.\n @param countryCode: Pointer of buffer to return country code. The country code indicates the current country or\n region where the aircraft is located. Please refer to the ISO 3166-1 code table for the specific meaning of the\n country code.\n @return Execution result."]
    pub fn DjiFlightController_GetCountryCode(countryCode: *mut u16) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request go home action when the aircraft is in the air\n @return Execution result."]
    pub fn DjiFlightController_StartGoHome() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request cancel go home action when the aircraft is going home\n @return Execution result."]
    pub fn DjiFlightController_CancelGoHome() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Obtain aircraft's joystick control permission.\n @note 1.You have to obtain joystick control permission successfully before you using joystick to control aircraft.\n 2. RC must be in p-mode.\n @return Execution result."]
    pub fn DjiFlightController_ObtainJoystickCtrlAuthority() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Release aircraft's joystick control permission.\n @note RC must be in p-mode.\n @return Execution result."]
    pub fn DjiFlightController_ReleaseJoystickCtrlAuthority() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Subscribe to joystick control permission switch event with a callback function.\n @note it will be triggered once the joystick control permission switch event occurs.\n @return Execution result."]
    pub fn DjiFlightController_RegJoystickCtrlAuthorityEventCallback(
        callback: JoystickCtrlAuthorityEventCbFunc,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set expected joystick mode before requesting joystick.\n @param joystickMode: include horizontal/vertical/yaw control mode, stable control mode."]
    pub fn DjiFlightController_SetJoystickMode(joystickMode: T_DjiFlightControllerJoystickMode);
}
extern "C" {
    #[doc = " @brief Request execute joystick action.\n @param joystickCommand: include x/y/z/yaw.\n @return Execution result."]
    pub fn DjiFlightController_ExecuteJoystickAction(
        joystickCommand: T_DjiFlightControllerJoystickCommand,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request emergency brake action.\n @return Execution result."]
    pub fn DjiFlightController_ExecuteEmergencyBrakeAction() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request cancel emergency brake action.\n @note It is only support on M30.If you use DjiFlightController_ExecuteEmergencyBrakeAction(), you need to use\n \"DjiFlightController_CancelEmergencyBrakeAction()\" to allow aircraft to execute aircraft action again.\n @return Execution result."]
    pub fn DjiFlightController_CancelEmergencyBrakeAction() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get general info of the aircraft.\n @param generalInfo: the struct stored the serial num which contains a array of chars var in case the user gives an\n illegal length character pointer\n @return Execution result."]
    pub fn DjiFlightController_GetGeneralInfo(
        generalInfo: *mut T_DjiFlightControllerGeneralInfo,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief The command decides whether execute RC lost action or not when PSDK is running\n @note  This setting only affects the behavior of the aircraft when the RC lost and the PSDK is connected.\n         if the command is enable, the aircraft will not execute RC lost action when RC is lost but PSDK is running;\n         if the command is disable, the aircraft will execute RC lost action when RC is lost but PSDK is running\n         the aircraft will execute RC lost action when RC is lost and PSDK is lost whatever the command is.\n         default command is disable.\n @param executeRCLostActionOrNotWhenOnboardOn  enable:1;disable:0\n @return T_DjiReturnCode error code"]
    pub fn DjiFlightController_SetRCLostActionEnableStatus(
        command: E_DjiFlightControllerRCLostActionEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief get RC lost action enable status(enable or disable)\n  @param command executeRCLostActionOrNotWhenOnboardOn, enable:1;disable:0\n  @return  T_DjiReturnCode error code"]
    pub fn DjiFlightController_GetEnableRCLostActionStatus(
        command: *mut E_DjiFlightControllerRCLostActionEnableStatus,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function for the trigger FTS event.\n @note The timing of the trigger of the callback function of the FTS is determined by the aircraft, and the trigger\n       execution action of the FTS needs to be implemented in the callback function and the correct return value\n        must be returned, otherwise the aircraft will always be triggered.\n @param callback: the callback for the trigger FTS event.\n @return Execution result."]
    pub fn DjiFlightController_RegTriggerFtsEventCallback(
        callback: TriggerFtsEventCallback,
    ) -> T_DjiReturnCode;
}
#[doc = "< Calibration have been completed and the result is successful."]
pub const E_DjiGimbalCalibrationStage_DJI_GIMBAL_CALIBRATION_STAGE_COMPLETE:
    E_DjiGimbalCalibrationStage = 0;
#[doc = "< Gimbal is calibrating."]
pub const E_DjiGimbalCalibrationStage_DJI_GIMBAL_CALIBRATION_STAGE_PROCRESSING:
    E_DjiGimbalCalibrationStage = 1;
#[doc = "< Calibration have been completed and the result is failure."]
pub const E_DjiGimbalCalibrationStage_DJI_GIMBAL_CALIBRATION_STAGE_FAILED:
    E_DjiGimbalCalibrationStage = 3;
#[doc = " @brief Gimbal calibration stage and result."]
pub type E_DjiGimbalCalibrationStage = ::std::os::raw::c_uint;
#[doc = "< Pitch axis."]
pub const E_DjiGimbalAxis_DJI_GIMBAL_AXIS_PITCH: E_DjiGimbalAxis = 0;
#[doc = "< Roll axis."]
pub const E_DjiGimbalAxis_DJI_GIMBAL_AXIS_ROLL: E_DjiGimbalAxis = 1;
#[doc = "< Yaw axis."]
pub const E_DjiGimbalAxis_DJI_GIMBAL_AXIS_YAW: E_DjiGimbalAxis = 2;
#[doc = " @brief Axis of gimbal."]
pub type E_DjiGimbalAxis = ::std::os::raw::c_uint;
#[doc = " Only reset yaw axis of gimbal. Reset angle of yaw axis to the sum of yaw axis angle of aircraft and fine tune angle\n of yaw axis of gimbal."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_YAW: E_DjiGimbalResetMode = 1;
#[doc = " Reset yaw axis and pitch axis of gimbal. Reset angle of yaw axis to sum of yaw axis angle of aircraft and fine tune\n angle of yaw axis of gimbal, and reset pitch axis angle to the fine tune angle."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_PITCH_AND_YAW: E_DjiGimbalResetMode = 3;
#[doc = " Reset only pitch axis of gimbal."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_PITCH_ONLY: E_DjiGimbalResetMode = 4;
#[doc = " Reset only roll axis of gimbal."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_ROLL_ONLY: E_DjiGimbalResetMode = 5;
#[doc = " Reset only yaw axis of gimbal."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_YAW_ONLY: E_DjiGimbalResetMode = 6;
#[doc = " Reset yaw axis and pitch axis of gimbal. Reset angle of yaw axis to sum of yaw axis angle of aircraft and fine tune\n angle of yaw axis of gimbal, and reset pitch axis angle to sum of -90 degree and fine tune angle if gimbal\n downward, sum of 90 degree and fine tune angle if upward."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_PITCH_DOWNWARD_UPWARD_AND_YAW:
    E_DjiGimbalResetMode = 11;
#[doc = " Reset pitch axis of gimbal. Reset pitch axis angle to sum of -90 degree and fine tune angle if gimbal downward,\n sum of 90 degree and fine tune angle if upward."]
pub const E_DjiGimbalResetMode_DJI_GIMBAL_RESET_MODE_PITCH_DOWNWARD_UPWARD: E_DjiGimbalResetMode =
    12;
#[doc = " @brief Reset mode of gimbal."]
pub type E_DjiGimbalResetMode = ::std::os::raw::c_uint;
#[doc = " @brief Smooth factor of gimbal controller."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalControllerSmoothFactor {
    #[doc = "< Smooth factor of pitch axis, range from 0 to 30."]
    pub pitch: u8,
    #[doc = "< Smooth factor of yaw axis, range from 0 to 30."]
    pub yaw: u8,
}
#[doc = " @brief Max speed percentage of every axis of gimbal."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalControllerMaxSpeedPercentage {
    #[doc = "< Max speed percentage of pitch axis, range from 1 to 100."]
    pub pitch: u8,
    #[doc = "< Max speed percentage of yaw axis, range from 1 to 100."]
    pub yaw: u8,
}
#[doc = " @brief Data structure describes gimbal system state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalSystemState {
    #[doc = "< Specifies whether gimbal is resetting now or not."]
    pub resettingFlag: bool,
    #[doc = "< Specifies whether gimbal is upward or not."]
    pub mountedUpward: bool,
    #[doc = "< Specifies whether gimbal is stuck or not."]
    pub blockingFlag: bool,
    #[doc = "< Specifies whether extended angle range of gimbal pitch axis is enabled or not."]
    pub pitchRangeExtensionEnabledFlag: bool,
    #[doc = "< Gimbal mode."]
    pub gimbalMode: E_DjiGimbalMode,
    #[doc = "< Fine tune angles, unit: 0.1 degree."]
    pub fineTuneAngle: T_DjiAttitude3d,
    #[doc = "< Smooth factor of gimbal controller."]
    pub smoothFactor: T_DjiGimbalControllerSmoothFactor,
    #[doc = "< Max speed percentage of gimbal controller."]
    pub maxSpeedPercentage: T_DjiGimbalControllerMaxSpeedPercentage,
}
impl Default for T_DjiGimbalSystemState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Reach limit flag."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalReachLimitFlag {
    #[doc = "< Specifies whether gimbal has reached angle limit of pitch axis, if true, reached the limit."]
    pub pitch: bool,
    #[doc = "< Specifies whether gimbal has reached angle limit of roll axis, if true, reached the limit."]
    pub roll: bool,
    #[doc = "< Specifies whether gimbal has reached angle limit of yaw axis, if true, reached the limit."]
    pub yaw: bool,
}
#[doc = " @brief Gimbal attitude related information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalAttitudeInformation {
    #[doc = "< Gimbal attitude in the ground coordinate, unit: 0.1 degree."]
    pub attitude: T_DjiAttitude3d,
    #[doc = "< Reach limit flag, being set when the joint angles of gimbal reach limits."]
    pub reachLimitFlag: T_DjiGimbalReachLimitFlag,
}
#[doc = " @brief Gimbal calibration state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalCalibrationState {
    #[doc = "< Specifies whether gimbal is calibrating now or not."]
    pub calibratingFlag: bool,
    #[doc = "< Result of the last calibration, and true specifies success."]
    pub lastCalibrationResult: bool,
    #[doc = "< Progress percentage of current calibration. If gimbal is calibrating now and fill in real progress percentage, if not, fill in zero. The item ranges from 0 to 100."]
    pub currentCalibrationProgress: u8,
    #[doc = "< Current calibration stage and result. If gimbal is calibrating now and fill in ::DJI_GIMBAL_CALIBRATION_STAGE_PROCRESSING, if not, fill in result of the last calibration."]
    pub currentCalibrationStage: E_DjiGimbalCalibrationStage,
}
impl Default for T_DjiGimbalCalibrationState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Gimbal rotation command property."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiGimbalRotationProperty {
    #[doc = "< Specifies whether ignore rotation command of some axis, including pitch, roll and yaw."]
    pub rotationValueInvalidFlag: T_DjiGimbalRotationProperty__bindgen_ty_1,
    pub __bindgen_anon_1: T_DjiGimbalRotationProperty__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalRotationProperty__bindgen_ty_1 {
    #[doc = "< Specifies whether ignore rotation command of pitch axis, and true specifies ignoring."]
    pub pitch: bool,
    #[doc = "< Specifies whether ignore rotation command of roll axis, and true specifies ignoring."]
    pub roll: bool,
    #[doc = "< Specifies whether ignore rotation command of yaw axis, and true specifies ignoring."]
    pub yaw: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DjiGimbalRotationProperty__bindgen_ty_2 {
    #[doc = "< Property of relative angle rotation command."]
    pub relativeAngleRotation: T_DjiGimbalRotationProperty__bindgen_ty_2__bindgen_ty_1,
    #[doc = "< Property of absolute angle rotation command."]
    pub absoluteAngleRotation: T_DjiGimbalRotationProperty__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalRotationProperty__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< Action time during which gimbal move to target angles, unit: 0.01s."]
    pub actionTime: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalRotationProperty__bindgen_ty_2__bindgen_ty_2 {
    #[doc = "< Action time during which gimbal move to target angles, unit: 0.01s."]
    pub actionTime: u16,
    #[doc = " Joint angle valid flag, specifying whether\n T_DjiGimbalRotationProperty::absoluteAngleRotation::jointAngle is valid when absolute angle control."]
    pub jointAngleValid: bool,
    #[doc = " Joint angles of gimbal, unit: 0.1 degree. If\n T_DjiGimbalRotationProperty::absoluteAngleRotation::jointAngleValid is false, specifying here joint\n angles are invalid, and please ignore the joint angles. If joint angles are valid, users should ensure\n that target joint angles of gimbal is approximately the same as the specified value."]
    pub jointAngle: T_DjiAttitude3d,
}
impl Default for T_DjiGimbalRotationProperty__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DjiGimbalRotationProperty {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Common handler function prototypes of gimbal, that is, some common callback function prototypes of gimbal.\n @warning User can not execute blocking style operations or functions in callback function, because that will block DJI\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiGimbalCommonHandler {
    #[doc = " @brief Prototype of callback function used to report system state of gimbal.\n @param systemState: pointer to memory space used to store gimbal system state.\n @return Execution result."]
    pub GetSystemState: ::std::option::Option<
        unsafe extern "C" fn(systemState: *mut T_DjiGimbalSystemState) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to report attitude information of gimbal.\n @param attitudeInformation: pointer to memory space used to store gimbal attitude information.\n @return Execution result."]
    pub GetAttitudeInformation: ::std::option::Option<
        unsafe extern "C" fn(
            attitudeInformation: *mut T_DjiGimbalAttitudeInformation,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to report calibration state of gimbal.\n @param calibrationState: pointer to memory space used to store gimbal calibration state.\n @return Execution result."]
    pub GetCalibrationState: ::std::option::Option<
        unsafe extern "C" fn(calibrationState: *mut T_DjiGimbalCalibrationState) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to rotate gimbal. Rotation callback function will be called when\n other modules control gimbal.\n @warning User should control execution time of the callback function to be short, because this callback function\n may be called at very high frequency in some scenarios, just like 200Hz.\n @param rotationMode: mode of rotation command.\n @param rotationProperty: property of rotation command.\n @param rotationValue: value of rotation command, unit: 0.1 degree (if rotation mode is\n ::DJI_GIMBAL_ROTATION_MODE_RELATIVE_ANGLE or ::DJI_GIMBAL_ROTATION_MODE_ABSOLUTE_ANGLE), 0.1 degree/s\n (if rotation mode is ::DJI_GIMBAL_ROTATION_MODE_SPEED).\n @return Execution result."]
    pub Rotate: ::std::option::Option<
        unsafe extern "C" fn(
            rotationMode: E_DjiGimbalRotationMode,
            rotationProperty: T_DjiGimbalRotationProperty,
            rotationValue: T_DjiAttitude3d,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to start calibrating gimbal.\n @note Maximum allowable time of gimbal calibration is 120s. If gimbal has not completed calibration during\n 120s, DJI Pilot believe calibration failed.\n @return Execution result."]
    pub StartCalibrate: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Set smooth factor for gimbal controller, using to smooth control.\n @param smoothingFactor: smooth factor. The larger the value, the smaller the acceleration of gimbal. Recommended\n calculation formula is \"acc = 10000 * (0.8 ^ (1 + x)) deg/s^2\", x is smooth factor. Range from 0 to 30.\n @param axis: axis to be set.\n @return Execution result."]
    pub SetControllerSmoothFactor: ::std::option::Option<
        unsafe extern "C" fn(smoothingFactor: u8, axis: E_DjiGimbalAxis) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to enable or disable extended pitch axis angle range.\n @details Switching the gimbal limit euler angle of pitch axis to the extended limit angle or the default limit\n angle.\n @param enabledFlag: flag specified whether enable or disable extended pitch axis angle range.\n @return Execution result."]
    pub SetPitchRangeExtensionEnabled:
        ::std::option::Option<unsafe extern "C" fn(enabledFlag: bool) -> T_DjiReturnCode>,
    #[doc = " @brief Set max speed percentage for gimbal controller.\n @param maxSpeedPercentage: max speed value. Recommended calculation formula is \"spd = default_max_spd * x / 100\",\n x is default max speed value. Range from 1 to 100.\n @param axis: axis to be set.\n @return Execution result."]
    pub SetControllerMaxSpeedPercentage: ::std::option::Option<
        unsafe extern "C" fn(maxSpeedPercentage: u8, axis: E_DjiGimbalAxis) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Restore factory settings of gimbal, including fine tune angle, pitch angle extension enable flag and max\n speed etc.\n @return Execution result."]
    pub RestoreFactorySettings: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to set gimbal work mode.\n @param mode: gimbal work mode.\n @return Execution result."]
    pub SetMode:
        ::std::option::Option<unsafe extern "C" fn(mode: E_DjiGimbalMode) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to reset gimbal.\n @note Reset command will interrupt rotation process.\n @param mode: Reset mode.\n @return Execution result."]
    pub Reset:
        ::std::option::Option<unsafe extern "C" fn(mode: E_DjiGimbalResetMode) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to fine tune angle of gimbal.\n @param fineTuneAngle: fine tune angle, unit: 0.1 degree. Angle value of greater than 0 specifies rotation\n towards the positive direction of body coordinate.\n @return Execution result."]
    pub FineTuneAngle: ::std::option::Option<
        unsafe extern "C" fn(fineTuneAngle: T_DjiAttitude3d) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to report rotation speed of gimbal.\n @note The callback function will be called at 50 Hz. Developers should ensure that, the average rotation speed\n of gimbal within 20 ms after the callback function is called is approximately equal to the reported rotation\n speed.\n @param rotationSpeed: pointer to memory space used to store rotation speed, in body coordinate, unit:\n 0.1 degree/s.\n @return Execution result."]
    pub GetRotationSpeed: ::std::option::Option<
        unsafe extern "C" fn(rotationSpeed: *mut T_DjiAttitude3d) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to report joint angle of gimbal.\n @param jointAngle: pointer to memory space used to store joint angles, unit: 0.1 degree.\n @return Execution result."]
    pub GetJointAngle: ::std::option::Option<
        unsafe extern "C" fn(jointAngle: *mut T_DjiAttitude3d) -> T_DjiReturnCode,
    >,
}
extern "C" {
    #[doc = " @brief Initialise gimbal module, and user should call this function before using gimbal features.\n @return Execution result."]
    pub fn DjiGimbal_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialise gimbal module.\n @return Execution result."]
    pub fn DjiGimbal_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register common handler functions/callback functions of gimbal. After registering, callback functions will be\n called automatically.\n @param commonHandler: pointer to common handler functions of gimbal.\n @return Execution result."]
    pub fn DjiGimbal_RegCommonHandler(
        commonHandler: *const T_DjiGimbalCommonHandler,
    ) -> T_DjiReturnCode;
}
#[doc = " @brief Gimbal manager rotation command property."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiGimbalManagerRotation {
    #[doc = "< Rotation gimbal mode."]
    pub rotationMode: E_DjiGimbalRotationMode,
    #[doc = "< Pitch angle in degree, unit: deg"]
    pub pitch: dji_f32_t,
    #[doc = "< Roll angle in degree, unit: deg"]
    pub roll: dji_f32_t,
    #[doc = "< Yaw angle in degree, unit: deg"]
    pub yaw: dji_f32_t,
    #[doc = "< Expected execution time for gimbal rotation, in seconds."]
    pub time: dji_f64_t,
}
impl Default for T_DjiGimbalManagerRotation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialize the gimbal manager module.\n @note This interface must be initialized after DjiCore_Init.\n @return Execution result."]
    pub fn DjiGimbalManager_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief DeInitialize the gimbal manager module.\n @return Execution result."]
    pub fn DjiGimbalManager_Deinit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set the work mode of the gimbal.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @param mode: gimbal work mode, input limit see enum E_DjiGimbalMode\n @return Execution result."]
    pub fn DjiGimbalManager_SetMode(
        mountPosition: E_DjiMountPosition,
        mode: E_DjiGimbalMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Reset the pitch and yaw of the gimbal.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @param mode: reset mode, input limit see enum E_DjiGimbalResetMode\n @return Execution result."]
    pub fn DjiGimbalManager_Reset(
        mountPosition: E_DjiMountPosition,
        resetMode: E_DjiGimbalResetMode,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Rotate the angle of the gimbal.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @param rotation: the rotation parameters to be executed on the target gimbal, including the rotation mode, target\n angle value and executed time, refer to T_DjiGimbalManagerRotation\n @return Execution result."]
    pub fn DjiGimbalManager_Rotate(
        mountPosition: E_DjiMountPosition,
        rotation: T_DjiGimbalManagerRotation,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Prototype of callback function used to enable or disable extended pitch axis angle range.\n @note Switching the gimbal limit euler angle of pitch axis to the extended limit angle or the default limit\n angle.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @param enabledFlag: flag specifying whether to enable or disable the extended pitch axis angle range..\n @return Execution result."]
    pub fn DjiGimbalManager_SetPitchRangeExtensionEnabled(
        mountPosition: E_DjiMountPosition,
        enabledFlag: bool,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set max speed percentage for gimbal controller.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @param axis: axis to be set.\n @param maxSpeedPercentage: max speed value. Recommended calculation formula is \"spd = default_max_spd * x / 100\",\n where 'x' is the default maximum speed value. Range from 1 to 100.\n @return Execution result."]
    pub fn DjiGimbalManager_SetControllerMaxSpeedPercentage(
        mountPosition: E_DjiMountPosition,
        axis: E_DjiGimbalAxis,
        maxSpeedPercentage: u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set smooth factor for gimbal controller, using for smooth control.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @param axis: axis to be set.\n @param smoothingFactor: smooth factor. A larger value results in slower gimbal acceleration. Recommended\n calculation formula is \"acc = 10000 * (0.8 ^ (1 + x)) deg/s^2\", x is smooth factor. Range from 0 to 30.\n @return Execution result."]
    pub fn DjiGimbalManager_SetControllerSmoothFactor(
        mountPosition: E_DjiMountPosition,
        axis: E_DjiGimbalAxis,
        smoothingFactor: u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Restore factory settings of gimbal, including fine tune angle, pitch angle extension enable flag and max\n speed etc.\n @param mountPosition: gimbal mount position, input limit see enum E_DjiMountPosition\n @return Execution result."]
    pub fn DjiGimbalManager_RestoreFactorySettings(
        mountPosition: E_DjiMountPosition,
    ) -> T_DjiReturnCode;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiDataChannelBandwidthProportionOfHighspeedChannel {
    #[doc = "< Bandwidth proportion of data stream, range from 0 to 100."]
    pub dataStream: u8,
    #[doc = "< Bandwidth proportion of video stream, range from 0 to 100."]
    pub videoStream: u8,
    #[doc = "< Bandwidth proportion of download stream, range from 0 to 100."]
    pub downloadStream: u8,
}
extern "C" {
    #[doc = " @brief Set bandwidth proportion for the data stream, video stream and download stream of high-speed channel.\n @details Self-defined bandwidth distribution mechanism allows that user can control bandwidth limitation\n freely. System multiplies total bandwidth limitation of the high-speed channel by a proportion of the corresponding stream to\n get realtime bandwidth limitation of the specified stream. Realtime bandwidth limitation of data and video stream can be\n gotten by PsdkDataTransmission_GetDataStreamState() and PsdkPayloadCamera_GetVideoStreamState() interfaces. Total\n bandwidth of the high-speed channel is determined by the environment in which the system located and loading of system. If\n user does not set bandwidth proportion for each stream, the default proportion is 33% (data stream), 33% (video\n stream) and 34% (download stream).\n @note The bandwidth proportion will be effective after a while, the max value is 1s. If you want use this interface, should calling\n PsdkPlatform_RegHalNetworkHandler interface firstly, otherwise this interface will not work.\n @param bandwidthProportion: bandwidth proportion of each stream of high-speed channel. The Sum of bandwidth proportion\n must equal 100.\n @return Execution result."]
    pub fn DjiHighSpeedDataChannel_SetBandwidthProportion(
        bandwidthProportion: T_DjiDataChannelBandwidthProportionOfHighspeedChannel,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the network remote address for sending data stream.\n @note The interface is used to get the network remote address for sending data stream. You can get this info for another\n heterogeneous system to do somethings. This interface should be used after calling PsdkCore_Init function.\n @param ipAddr: the remote ip address for sending data stream.\n @param port: the remote port for sending data stream.\n @return Execution result."]
    pub fn DjiHighSpeedDataChannel_GetDataStreamRemoteAddress(
        ipAddr: *mut ::std::os::raw::c_char,
        port: *mut u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Send data to mobile end via data stream of the data channel.\n @note This function can be used only in Linux operating system.\n @note Must ensure actual bandwidth is less than bandwidth limitation of corresponding channel or stream, please\n refer to developer documentation and state of channel/stream for details related to bandwidth limitation. User can\n get state of \"dataStream\" channel via PsdkDataTransmission_GetDataStreamState() function. If actual bandwidth\n exceeds the limitation or busy state is set, the user should stop transmitting data or decrease amount of data to be\n sent. Otherwise, data may be discarded.\n @param data: pointer to data to be sent.\n @param len: length of data to be sent via data stream, and it must be less than or equal to 65000, unit: byte.\n @return Execution result."]
    pub fn DjiHighSpeedDataChannel_SendDataStreamData(data: *const u8, len: u16)
        -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get data transmission state of \"dataStream\" channel. User can use the state as base for controlling data\n transmission of data stream. This function exists and can be used only in Linux operation system.\n @param state: pointer to \"dataStream\" channel state.\n @return Execution result."]
    pub fn DjiHighSpeedDataChannel_GetDataStreamState(
        state: *mut T_DjiDataChannelState,
    ) -> T_DjiReturnCode;
}
pub const E_DjiHmsErrorLevel_DJI_HMS_ERROR_LEVEL_NONE: E_DjiHmsErrorLevel = 0;
pub const E_DjiHmsErrorLevel_DJI_HMS_ERROR_LEVEL_HINT: E_DjiHmsErrorLevel = 1;
pub const E_DjiHmsErrorLevel_DJI_HMS_ERROR_LEVEL_WARN: E_DjiHmsErrorLevel = 2;
pub const E_DjiHmsErrorLevel_DJI_HMS_ERROR_LEVEL_CRITICAL: E_DjiHmsErrorLevel = 3;
pub const E_DjiHmsErrorLevel_DJI_HMS_ERROR_LEVEL_FATAL: E_DjiHmsErrorLevel = 4;
pub type E_DjiHmsErrorLevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHmsFileBinaryArray {
    #[doc = "< The file name of the hms text config file"]
    pub fileName: *mut ::std::os::raw::c_char,
    #[doc = "< The file size of the hms text config file, uint : byte"]
    pub fileSize: u32,
    #[doc = "< The binary C array of the hms text config file"]
    pub fileBinaryArray: *const u8,
}
impl Default for T_DjiHmsFileBinaryArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHmsBinaryArrayConfig {
    #[doc = "< Binary array count."]
    pub binaryArrayCount: u16,
    #[doc = "< Pointer to binary array list"]
    pub fileBinaryArrayList: *mut T_DjiHmsFileBinaryArray,
}
impl Default for T_DjiHmsBinaryArrayConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Initialise hms customization module, and user should call this function\n before using hms customization features.\n @return Execution result."]
    pub fn DjiHmsCustomization_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief DeInitialize hms manager module.\n @return Execution result."]
    pub fn DjiHmsCustomization_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Inject custom hms error code to APP.\n @note: For the same hms error code, a single call is enough, no need to call repeatedly.\n @param errorCode: hms error code, value range: [0x1E020000 ~ 0x1E02FFFF].\n @param errorLevel: hms error level, see reference of E_DjiHmsErrorLevel.\n @return Execution result."]
    pub fn DjiHmsCustomization_InjectHmsErrorCode(
        errorCode: u32,
        errorLevel: E_DjiHmsErrorLevel,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Eliminate custom hms error code to APP.\n @note: For the same hms error code, a single call is enough, no need to call repeatedly.\n @param errorCode: hms error code, value range: [0x1E020000 ~ 0x1E02FFFF].\n @return Execution result."]
    pub fn DjiHmsCustomization_EliminateHmsErrorCode(errorCode: u32) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register default hms text configuration file by directory path.\n @param configDirPath: the hms text configuration by directory path.\n @return Execution result."]
    pub fn DjiHmsCustomization_RegDefaultHmsTextConfigByDirPath(
        configDirPath: *const ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register hms text configuration file by directory path.\n @note Different hms text configurations for several language require the same hms config.\n @param appLanguage: mobile app language type.\n @param configDirPath: the hms text configuration by directory path.\n @return Execution result."]
    pub fn DjiHmsCustomization_RegHmsTextConfigByDirPath(
        appLanguage: E_DjiMobileAppLanguage,
        configDirPath: *const ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register default hms text configuration config by binary array.\n @note In RTOS, most likely there is no file system. The hms text config file content can use C array express. Use this\n function and DjiHms_RegDefaultHmsTextConfigByBinaryArray set hms text configuration. When the language is not cover in\n your setting by DjiHms_RegHmsTextConfigByBinaryArray, the hms text configuration uses setting by this function.\n @param binaryArrayConfig: the binary array config for hms text configuration.\n @return Execution result."]
    pub fn DjiHmsCustomization_RegDefaultHmsTextConfigByBinaryArray(
        binaryArrayConfig: *const T_DjiHmsBinaryArrayConfig,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register hms text config by binary array configuration.\n @note Different hms text configurations for several language require the same hms config.\n @param appLanguage: mobile app language type.\n @param binaryArrayConfig: the binary array config for hms text configuration.\n @return Execution result."]
    pub fn DjiHmsCustomization_RegHmsTextConfigByBinaryArray(
        appLanguage: E_DjiMobileAppLanguage,
        binaryArrayConfig: *const T_DjiHmsBinaryArrayConfig,
    ) -> T_DjiReturnCode;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHmsInfo {
    pub errorCode: u32,
    pub componentIndex: u8,
    pub errorLevel: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHmsInfoTable {
    pub hmsInfo: *mut T_DjiHmsInfo,
    pub hmsInfoNum: u32,
}
impl Default for T_DjiHmsInfoTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type DjiHmsInfoCallback =
    ::std::option::Option<unsafe extern "C" fn(hmsInfoTable: T_DjiHmsInfoTable) -> T_DjiReturnCode>;
extern "C" {
    #[doc = " @brief Initialise hms manager module, and user should call this function\n before using hms manager features.\n @return Execution result."]
    pub fn DjiHmsManager_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief DeInitialize hms manager module.\n @return Execution result."]
    pub fn DjiHmsManager_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback to get hms info.\n @note: Data is pushed with a frequency of 1Hz.\n @param callback: see reference of DjiHmsInfoCallback.\n @return Execution result."]
    pub fn DjiHmsManager_RegHmsInfoCallback(callback: DjiHmsInfoCallback) -> T_DjiReturnCode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiHmsErrCodeInfo {
    pub alarmId: u32,
    #[doc = " error code"]
    pub groundAlarmInfo: *const ::std::os::raw::c_char,
    #[doc = " alarm information when the flight is on the ground"]
    pub flyAlarmInfo: *const ::std::os::raw::c_char,
}
impl Default for T_DjiHmsErrCodeInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Note: This api header file will not be maintained in the future, please refer to the latest hms error code file in\n the hms sample."]
    #[link_name = "\u{1}__ZL17hmsErrCodeInfoTbl"]
    pub static hmsErrCodeInfoTbl: [T_DjiHmsErrCodeInfo; 677usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiInterestPointMissionState {
    pub curSpeed: dji_f32_t,
    pub radius: dji_f32_t,
    pub state: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiInterestPointSettings {
    pub latitude: dji_f64_t,
    pub longitude: dji_f64_t,
    pub speed: dji_f32_t,
}
pub type InterestPointMissionStateCallback = ::std::option::Option<
    unsafe extern "C" fn(missionState: T_DjiInterestPointMissionState) -> T_DjiReturnCode,
>;
extern "C" {
    pub fn DjiInterestPoint_Init() -> T_DjiReturnCode;
}
extern "C" {
    pub fn DjiInterestPoint_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    pub fn DjiInterestPoint_Start(settings: T_DjiInterestPointSettings) -> T_DjiReturnCode;
}
extern "C" {
    pub fn DjiInterestPoint_Stop() -> T_DjiReturnCode;
}
extern "C" {
    pub fn DjiInterestPoint_SetSpeed(speed: dji_f32_t) -> T_DjiReturnCode;
}
extern "C" {
    pub fn DjiInterestPoint_RegMissionStateCallback(
        callback: InterestPointMissionStateCallback,
    ) -> T_DjiReturnCode;
}
pub const E_DjiLiveViewCameraPosition_DJI_LIVEVIEW_CAMERA_POSITION_NO_1:
    E_DjiLiveViewCameraPosition = 1;
pub const E_DjiLiveViewCameraPosition_DJI_LIVEVIEW_CAMERA_POSITION_NO_2:
    E_DjiLiveViewCameraPosition = 2;
pub const E_DjiLiveViewCameraPosition_DJI_LIVEVIEW_CAMERA_POSITION_NO_3:
    E_DjiLiveViewCameraPosition = 3;
pub const E_DjiLiveViewCameraPosition_DJI_LIVEVIEW_CAMERA_POSITION_FPV:
    E_DjiLiveViewCameraPosition = 7;
#[doc = " @brief Liveview camera mount position."]
pub type E_DjiLiveViewCameraPosition = ::std::os::raw::c_uint;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_DEFAULT: E_DjiLiveViewCameraSource =
    0;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20_WIDE: E_DjiLiveViewCameraSource =
    1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20_ZOOM: E_DjiLiveViewCameraSource =
    2;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20T_WIDE:
    E_DjiLiveViewCameraSource = 1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20T_ZOOM:
    E_DjiLiveViewCameraSource = 2;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20T_IR: E_DjiLiveViewCameraSource =
    3;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20N_WIDE:
    E_DjiLiveViewCameraSource = 1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20N_ZOOM:
    E_DjiLiveViewCameraSource = 2;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_H20N_IR: E_DjiLiveViewCameraSource =
    3;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M30_ZOOM: E_DjiLiveViewCameraSource =
    1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M30_WIDE: E_DjiLiveViewCameraSource =
    2;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M30T_ZOOM:
    E_DjiLiveViewCameraSource = 1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M30T_WIDE:
    E_DjiLiveViewCameraSource = 2;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M30T_IR: E_DjiLiveViewCameraSource =
    3;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M3E_VIS: E_DjiLiveViewCameraSource =
    1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M3T_VIS: E_DjiLiveViewCameraSource =
    1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M3T_IR: E_DjiLiveViewCameraSource =
    2;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M3D_VIS: E_DjiLiveViewCameraSource =
    1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M3TD_VIS: E_DjiLiveViewCameraSource =
    1;
pub const E_DjiLiveViewCameraSource_DJI_LIVEVIEW_CAMERA_SOURCE_M3TD_IR: E_DjiLiveViewCameraSource =
    2;
#[doc = " @brief Liveview camera stream source."]
pub type E_DjiLiveViewCameraSource = ::std::os::raw::c_uint;
#[doc = " @brief Liveview camera h264 stream callback."]
pub type DjiLiveview_H264Callback = ::std::option::Option<
    unsafe extern "C" fn(position: E_DjiLiveViewCameraPosition, buf: *const u8, len: u32),
>;
extern "C" {
    #[doc = " @brief Initialize the liveview module.\n @note Must be called after DjiCore_Init.\n @return Execution result."]
    pub fn DjiLiveview_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialize the liveview module.\n @return Execution result."]
    pub fn DjiLiveview_Deinit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Start the FPV or camera H264 stream from the specified position.\n @param position: Camera position for the H264 stream output.\n @param source: sub-camera source for the H264 stream output.\n @param callback: Callback function in a callback thread when a new h264 frame is received\n @return Execution result."]
    pub fn DjiLiveview_StartH264Stream(
        position: E_DjiLiveViewCameraPosition,
        source: E_DjiLiveViewCameraSource,
        callback: DjiLiveview_H264Callback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Stop the FPV or Camera H264 Stream from the specified position.\n @param position: Camera position for the H264 stream output.\n @param source: sub-camera source for the H264 stream output.\n @return Execution result."]
    pub fn DjiLiveview_StopH264Stream(
        position: E_DjiLiveViewCameraPosition,
        source: E_DjiLiveViewCameraSource,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Request the intraframe Frame of camera H264 stream from the specified position.\n @param position: Camera position for the H264 stream output.\n @param source: sub-camera source for the H264 stream output.\n @return Execution result."]
    pub fn DjiLiveview_RequestIntraframeFrameData(
        position: E_DjiLiveViewCameraPosition,
        source: E_DjiLiveViewCameraSource,
    ) -> T_DjiReturnCode;
}
#[doc = " @brief The console method that needs to be registered.\n @note  Before registering the console method, you need to test the methods that need to be registered to ensure\n        that they can be used normally."]
pub type ConsoleFunc =
    ::std::option::Option<unsafe extern "C" fn(data: *const u8, dataLen: u16) -> T_DjiReturnCode>;
#[doc = "< Logger console error level. The method and level of the console are\nassociated with each other. If the level of the registered console\nmethod is lower than this level, the level interface will not be\nprinted successfully."]
pub const E_DjiLoggerConsoleLogLevel_DJI_LOGGER_CONSOLE_LOG_LEVEL_ERROR:
    E_DjiLoggerConsoleLogLevel = 0;
#[doc = "< Logger console warning level.The method and level of the console are\nassociated with each other. If the level of the registered console\nmethod is lower than this level, the level interface will not be\nprinted successfully."]
pub const E_DjiLoggerConsoleLogLevel_DJI_LOGGER_CONSOLE_LOG_LEVEL_WARN: E_DjiLoggerConsoleLogLevel =
    1;
#[doc = "< Logger console info level. The method and level of the console are\nassociated with each other. If the level of the registered console\nmethod is lower than this level, the level interface will not be\nprinted successfully."]
pub const E_DjiLoggerConsoleLogLevel_DJI_LOGGER_CONSOLE_LOG_LEVEL_INFO: E_DjiLoggerConsoleLogLevel =
    2;
#[doc = "< Logger console debug level. The method and level of the console are\nassociated with each other. If the level of the registered console\nmethod is lower than this level, the level interface will not be\nprinted successfully."]
pub const E_DjiLoggerConsoleLogLevel_DJI_LOGGER_CONSOLE_LOG_LEVEL_DEBUG:
    E_DjiLoggerConsoleLogLevel = 3;
#[doc = " @brief Logger console level."]
pub type E_DjiLoggerConsoleLogLevel = ::std::os::raw::c_uint;
#[doc = " @brief Logger console content."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiLoggerConsole {
    pub func: ConsoleFunc,
    pub consoleLevel: u8,
    pub isSupportColor: bool,
}
extern "C" {
    #[doc = " @brief Add the console function and level for Payload SDK.\n @note When registering the console, you need to provide the method of the console and the level corresponding to\n the method. Log levels from high to low are Debug, Info, Warn, and Error, the log function module can print all\n logs not higher than the specified level. Maximum support for registering eight different console methods at the\n same time.Before registering the console method, you should test the registration method ensure that all the method\n are normally. If you registered multiple methods at the same time, all the methods will be print.\n @param console: pointer to the console function.\n @return Execution result."]
    pub fn DjiLogger_AddConsole(console: *mut T_DjiLoggerConsole) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Remove the console function and level for Payload SDK.\n @param console: pointer to the console function.\n @return Execution result."]
    pub fn DjiLogger_RemoveConsole(console: *mut T_DjiLoggerConsole) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Print out the selected level log of the specified format by the registration method.\n @note The registered method is printed according to the corresponding level. If the level of the console is lower\n than the level at which the log needs to be printed, it will not be printed successfully.\n @param fmt: pointer to the format string that needs print out.\n @param ...: Variable parameters, consistent with the use of the system interface print out."]
    pub fn DjiLogger_UserLogOutput(
        level: E_DjiLoggerConsoleLogLevel,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[doc = " @brief Prototype of callback function used to receive data that come from selected channel address.\n @warning User can not execute blocking style operations or functions in callback function, because that will block\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param data: pointer to data.\n @param len: length of data.\n @return Execution result."]
pub type DjiLowSpeedDataChannelRecvDataCallback =
    ::std::option::Option<unsafe extern "C" fn(data: *const u8, len: u16) -> T_DjiReturnCode>;
extern "C" {
    #[doc = " @brief Initialize the low speed data channel module.\n @note The interface initialization needs to be after DjiCore_Init.\n @return Execution result."]
    pub fn DjiLowSpeedDataChannel_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialize the low speed data channel module.\n @return Execution result."]
    pub fn DjiLowSpeedDataChannel_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Send data to selected channel address end via command channel.\n @warning If actual bandwidth is below limitation, data can be sent to the endpoint directly. If exceeds the limitation,\n firstly data will be stored to buffer of the flow controller and be sent to endpoint after a period (an integer multiple of\n 1s, the exact time depends on bandwidth limitation and buffer size). If the buffer is full, data be will discarded. The\n capacity of flow controller buffer is 512 bytes.\n @note Must ensure actual bandwidth is less than bandwidth limitation of corresponding channel or stream, please\n refer to developer documentation or state of channel/stream for details related to bandwidth limitation. User can\n get state of \"sendDataChannel\" command channel via DjiLowSpeedDataChannel_GetSendDataState() function. If actual\n bandwidth exceeds the limitation or busy state is set, the user should stop transmitting data or decrease amount of data\n to be sent.\n @note Max size of data package sent to selected channel address end on a physical link of command channel is 128.\n If the length of data to be sent is greater than 128, data to be sent will be divided into multiple packages to send,\n and the user will also receive multiple data packages on the selected channel address end.\n @param channelAddress: the channel address of the low speed channel\n @param data: pointer to data to be sent.\n @param len: length of data to be sent, unit: byte.\n @return Execution result."]
    pub fn DjiLowSpeedDataChannel_SendData(
        channelAddress: E_DjiChannelAddress,
        data: *const u8,
        len: u8,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get data transmission state of \"sendToOsdk\" command channel. User can use the state as base for controlling data\n transmission between selected channel address and onboard computer.\n @param channelAddress: the channel address of the low speed channel\n @param state: pointer to low speed channel state.\n @return Execution result."]
    pub fn DjiLowSpeedDataChannel_GetSendDataState(
        channelAddress: E_DjiChannelAddress,
        state: *mut T_DjiDataChannelState,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to receive data from selected channel address. After registering this callback\n function, callback function will be called automatically when system receive data from selected channel address.\n @param channelAddress: the channel address of the low speed channel\n @param callback: pointer to callback function.\n @return Execution result."]
    pub fn DjiLowSpeedDataChannel_RegRecvDataCallback(
        channelAddress: E_DjiChannelAddress,
        callback: DjiLowSpeedDataChannelRecvDataCallback,
    ) -> T_DjiReturnCode;
}
#[doc = " @brief Mop channel handle."]
pub type T_DjiMopChannelHandle = *mut ::std::os::raw::c_void;
#[doc = "< Reliable transmission type."]
pub const E_DjiMopChannelTransType_DJI_MOP_CHANNEL_TRANS_RELIABLE: E_DjiMopChannelTransType = 0;
#[doc = "< Unreliable transmission type."]
pub const E_DjiMopChannelTransType_DJI_MOP_CHANNEL_TRANS_UNRELIABLE: E_DjiMopChannelTransType = 1;
#[doc = " @brief Mop channel transmission type."]
pub type E_DjiMopChannelTransType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Initialize the mop channel for operation about mop channel handle later.\n @note This interface needs to be called before calling other mop channel interfaces. Please make sure the network port\n is connected properly before calling this interface. Mop channel feature currently only supports linux platform.\n @return Execution result."]
    pub fn DjiMopChannel_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Create the mop channel handle by specified transmission type.\n @note After calling this interface, you should follow below cases:\n 1. When mop channel handle created successfully, you need bind channel id to this created mop channel handle and\n accept other client device connections, such as MSDK or OSDK device;\n 2. When mop channel accept successfully, you can use send or receive data interface to write or read data by accepted\n output channel handle;\n 3. When the mop channel handle do not used, you can use close or destroy interface to release the resource;\n @param channelHandle: pointer to the created mop channel.\n @param transType: the transmission type for mop channel ::E_DjiMopChannelTransType.\n @return Execution result."]
    pub fn DjiMopChannel_Create(
        channelHandle: *mut T_DjiMopChannelHandle,
        transType: E_DjiMopChannelTransType,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Destroy the created mop channel and release the resource that referenced by the channel handle.\n @note After calling this interface, we can not do any operation about this channel handle expect create channel handle.\n @param channelHandle: pointer to the created mop channel.\n @return Execution result."]
    pub fn DjiMopChannel_Destroy(channelHandle: T_DjiMopChannelHandle) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Bind the channel id to the created mop channel handle.\n @note When mop channel handle created successfully, you can bind channel id to this created mop handle and calling\n interface ::DjiMopChannel_Accept, then other client device can use this binded channel id to connect created mop handle.\n @param channelHandle: pointer to the created mop channel handle.\n @param channelId: the channel id of mop handle for accepting client device connection.\n @return Execution result."]
    pub fn DjiMopChannel_Bind(
        channelHandle: T_DjiMopChannelHandle,
        channelId: u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Accept the connection by binded channel id for created mop channel.\n @note The mop accept channel extracts the connection request on the queue of pennding connections for listening channel\n handle ::channelHandle. Create a new connected channel handle and return to user ::outChannelHandle by referrng to a new\n connection. Payload can be a server that allow multiple client connections by binded channel id.\n @param channelHandle: pointer to the created mop channel.\n @param outChannelHandle: pointer to the accepted output mop channel.\n @return Execution result."]
    pub fn DjiMopChannel_Accept(
        channelHandle: T_DjiMopChannelHandle,
        outChannelHandle: *mut T_DjiMopChannelHandle,
    ) -> T_DjiReturnCode;
}
extern "C" {
    pub fn DjiMopChannel_Connect(
        channelHandle: T_DjiMopChannelHandle,
        channelAddress: E_DjiChannelAddress,
        channelId: u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Close the created mop channel.\n @note After calling this interface, we can not do any operation about this channel handle expect destroy channel handle.\n @param channelHandle: pointer to the created mop channel.\n @return Execution result."]
    pub fn DjiMopChannel_Close(channelHandle: T_DjiMopChannelHandle) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Send data by the accepted output mop channel.\n @note This interface should be called after successfully calling the interface ::DjiMopChannel_Accept. It is recommended\n to send more bytes of data at a time to improve read and write efficiency. Need to determine whether the send is\n successful according to the return code and the actual sent data length.\n @param channelHandle: pointer to accepted output mop handle ::outChannelHandle by calling interface ::DjiMopChannel_Accept.\n @param data: pointer to data to be sent.\n @param len: length of data to be sent via accepted output mop handle, unit: byte.\n @param realLen: pointer to real length of data that already sent.\n @return Execution result."]
    pub fn DjiMopChannel_SendData(
        channelHandle: T_DjiMopChannelHandle,
        data: *mut u8,
        len: u32,
        realLen: *mut u32,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Receive data from the accepted output mop channel.\n @note This interface should be called after successfully calling the interface ::DjiMopChannel_Accept. It is recommended\n to receive more bytes of data at a time to improve read and write efficiency. Need to determine whether the receive\n is successful according to the return code and the actual received data length.\n @param channelHandle: pointer to accepted output mop handle ::outChannelHandle by calling interface ::DjiMopChannel_Accept.\n @param data: pointer to data to store the received data.\n @param len: length of data to be received via accepted output mop handle, unit: byte.\n @param realLen: pointer to real length of data that already received.\n @return Execution result."]
    pub fn DjiMopChannel_RecvData(
        channelHandle: T_DjiMopChannelHandle,
        data: *mut u8,
        len: u32,
        realLen: *mut u32,
    ) -> T_DjiReturnCode;
}
#[doc = "< Shoot photo work mode."]
pub const E_DjiCameraMode_DJI_CAMERA_MODE_SHOOT_PHOTO: E_DjiCameraMode = 0;
#[doc = "< Record video work mode."]
pub const E_DjiCameraMode_DJI_CAMERA_MODE_RECORD_VIDEO: E_DjiCameraMode = 1;
#[doc = "< Media playback work mode."]
pub const E_DjiCameraMode_DJI_CAMERA_MODE_PLAYBACK: E_DjiCameraMode = 2;
#[doc = " @brief Camera work mode."]
pub type E_DjiCameraMode = ::std::os::raw::c_uint;
#[doc = "< Single photographing mode."]
pub const E_DjiCameraShootPhotoMode_DJI_CAMERA_SHOOT_PHOTO_MODE_SINGLE: E_DjiCameraShootPhotoMode =
    1;
#[doc = "< Burst photographing mode."]
pub const E_DjiCameraShootPhotoMode_DJI_CAMERA_SHOOT_PHOTO_MODE_BURST: E_DjiCameraShootPhotoMode =
    4;
#[doc = "< Interval photographing mode."]
pub const E_DjiCameraShootPhotoMode_DJI_CAMERA_SHOOT_PHOTO_MODE_INTERVAL:
    E_DjiCameraShootPhotoMode = 6;
#[doc = " @brief Camera shoot photo mode."]
pub type E_DjiCameraShootPhotoMode = ::std::os::raw::c_uint;
#[doc = "< Photographing in idle state."]
pub const E_DjiCameraShootingState_DJI_CAMERA_SHOOTING_PHOTO_IDLE: E_DjiCameraShootingState = 0;
#[doc = "< Photographing in single photograph state ."]
pub const E_DjiCameraShootingState_DJI_CAMERA_SHOOTING_SINGLE_PHOTO: E_DjiCameraShootingState = 1;
#[doc = "< Photographing in burst photograph state."]
pub const E_DjiCameraShootingState_DJI_CAMERA_SHOOTING_BURST_PHOTO: E_DjiCameraShootingState = 2;
#[doc = "< Photographing in interval photograph state."]
pub const E_DjiCameraShootingState_DJI_CAMERA_SHOOTING_INTERVAL_PHOTO: E_DjiCameraShootingState = 6;
#[doc = " @brief Camera shooting state when photographing."]
pub type E_DjiCameraShootingState = ::std::os::raw::c_uint;
#[doc = "< Center metering mode."]
pub const E_DjiCameraMeteringMode_DJI_CAMERA_METERING_MODE_CENTER: E_DjiCameraMeteringMode = 0;
#[doc = "< Average metering mode."]
pub const E_DjiCameraMeteringMode_DJI_CAMERA_METERING_MODE_AVERAGE: E_DjiCameraMeteringMode = 1;
#[doc = "< Spot metering mode."]
pub const E_DjiCameraMeteringMode_DJI_CAMERA_METERING_MODE_SPOT: E_DjiCameraMeteringMode = 2;
#[doc = " @brief Camera metering mode."]
pub type E_DjiCameraMeteringMode = ::std::os::raw::c_uint;
#[doc = "< Manual focus mode."]
pub const E_DjiCameraFocusMode_DJI_CAMERA_FOCUS_MODE_MANUAL: E_DjiCameraFocusMode = 0;
#[doc = "< Auto focus mode."]
pub const E_DjiCameraFocusMode_DJI_CAMERA_FOCUS_MODE_AUTO: E_DjiCameraFocusMode = 1;
#[doc = " @brief Camera focus mode."]
pub type E_DjiCameraFocusMode = ::std::os::raw::c_uint;
#[doc = "< Play playbacking mode."]
pub const E_DjiCameraPlaybackMode_DJI_CAMERA_PLAYBACK_MODE_PLAY: E_DjiCameraPlaybackMode = 2;
#[doc = "< Pause playbacking mode."]
pub const E_DjiCameraPlaybackMode_DJI_CAMERA_PLAYBACK_MODE_PAUSE: E_DjiCameraPlaybackMode = 3;
#[doc = "< Stop playbacking mode."]
pub const E_DjiCameraPlaybackMode_DJI_CAMERA_PLAYBACK_MODE_STOP: E_DjiCameraPlaybackMode = 7;
#[doc = " @brief Camera playback mode in playback process."]
pub type E_DjiCameraPlaybackMode = ::std::os::raw::c_uint;
#[doc = "< The camera's video frame rate is 24fps (frames per second)"]
pub const E_DjiCameraVideoFrameRate_DJI_CAMERA_VIDEO_FRAME_RATE_24_FPS: E_DjiCameraVideoFrameRate =
    13;
#[doc = "< The camera's video frame rate is 25fps (frames per second)"]
pub const E_DjiCameraVideoFrameRate_DJI_CAMERA_VIDEO_FRAME_RATE_25_FPS: E_DjiCameraVideoFrameRate =
    2;
#[doc = "< The camera's video frame rate is 30fps (frames per second)"]
pub const E_DjiCameraVideoFrameRate_DJI_CAMERA_VIDEO_FRAME_RATE_30_FPS: E_DjiCameraVideoFrameRate =
    14;
#[doc = "< The camera's video frame rate is unknown (frames per second)"]
pub const E_DjiCameraVideoFrameRate_DJI_CAMERA_VIDEO_FRAME_RATE_UNKNOWN: E_DjiCameraVideoFrameRate =
    0;
#[doc = " @brief Camera supported video frames when working in playback mode."]
pub type E_DjiCameraVideoFrameRate = ::std::os::raw::c_uint;
#[doc = "< /The camera's video resolution is 640x480."]
pub const E_DjiCameraVideoResolution_DJI_CAMERA_VIDEO_RESOLUTION_640x480:
    E_DjiCameraVideoResolution = 0;
#[doc = "< /The camera's video resolution is 1280x720."]
pub const E_DjiCameraVideoResolution_DJI_CAMERA_VIDEO_RESOLUTION_1280x720:
    E_DjiCameraVideoResolution = 4;
#[doc = "< /The camera's video resolution is 1920x1080."]
pub const E_DjiCameraVideoResolution_DJI_CAMERA_VIDEO_RESOLUTION_1920x1080:
    E_DjiCameraVideoResolution = 10;
#[doc = "< /The camera's video resolution is 2048x1080."]
pub const E_DjiCameraVideoResolution_DJI_CAMERA_VIDEO_RESOLUTION_2048x1080:
    E_DjiCameraVideoResolution = 37;
#[doc = "< /The camera's video resolution is 3840x2160."]
pub const E_DjiCameraVideoResolution_DJI_CAMERA_VIDEO_RESOLUTION_3840x2160:
    E_DjiCameraVideoResolution = 41;
#[doc = "< /The camera's video resolution is unknown."]
pub const E_DjiCameraVideoResolution_DJI_CAMERA_VIDEO_RESOLUTION_UNKNOWN:
    E_DjiCameraVideoResolution = 255;
#[doc = " @brief Camera supported video resolutions when working in playback mode."]
pub type E_DjiCameraVideoResolution = ::std::os::raw::c_uint;
#[doc = "< Camera is not in tap zoom process."]
pub const E_DjiCameraTapZoomState_DJI_CAMERA_TAP_ZOOM_STATE_IDLE: E_DjiCameraTapZoomState = 0;
#[doc = "< Camera is zooming in."]
pub const E_DjiCameraTapZoomState_DJI_CAMERA_TAP_ZOOM_STATE_ZOOM_IN: E_DjiCameraTapZoomState = 1;
#[doc = "< Camera is zooming out."]
pub const E_DjiCameraTapZoomState_DJI_CAMERA_TAP_ZOOM_STATE_ZOOM_OUT: E_DjiCameraTapZoomState = 2;
#[doc = "< Camera has reached zoom limit."]
pub const E_DjiCameraTapZoomState_DJI_CAMERA_TAP_ZOOM_STATE_ZOOM_LIMITED: E_DjiCameraTapZoomState =
    3;
#[doc = " @brief Camera zoom state in tap zoom process."]
pub type E_DjiCameraTapZoomState = ::std::os::raw::c_uint;
#[doc = " Camera video stream by h264 custom format, which needs to comply with the user document Custom-H264 video stream format standard.\n When using this format to send a video stream, the bit rate of the video stream needs must not exceed the real-time bandwidth\n limit of the channel that feedback by interface #DjiPayloadCamera_GetVideoStreamState."]
pub const E_DjiCameraVideoStreamType_DJI_CAMERA_VIDEO_STREAM_TYPE_H264_CUSTOM_FORMAT:
    E_DjiCameraVideoStreamType = 0;
#[doc = " Camera video stream by h264 DJI format, which needs to comply with the user document DJI-H264 video stream format standard.\n When using this format to send a video stream, the video stream will be recoded by aircraft. No need to dynamically adjust\n the bit rate to ensure the quality of transmission. But the bit rate of video stream can not exceed 8Mbps."]
pub const E_DjiCameraVideoStreamType_DJI_CAMERA_VIDEO_STREAM_TYPE_H264_DJI_FORMAT:
    E_DjiCameraVideoStreamType = 1;
#[doc = " @brief Camera video stream type."]
pub type E_DjiCameraVideoStreamType = ::std::os::raw::c_uint;
#[doc = " @brief Camera sdcard state."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraSDCardState {
    #[doc = "< Specifies if the SD card is inserted in the camera. This parameter is boolean type."]
    pub isInserted: bool,
    #[doc = "< Specifies if the SD card is verified as genuine. This parameter is boolean type."]
    pub isVerified: bool,
    #[doc = "< Specifies if the SD card is initializing. This parameter is boolean type."]
    pub isInitializing: bool,
    #[doc = "< Specifies if the SD card is read only type. This parameter is boolean type."]
    pub isReadOnly: bool,
    #[doc = "< Specifies if the SD card is in formatting process. This parameter is boolean type."]
    pub isFormatting: bool,
    #[doc = "< Specifies if the SD card's capacity is full. This parameter is boolean type."]
    pub isFull: bool,
    #[doc = "< Specifies if the SD card is invalid formatted. This parameter is boolean type."]
    pub isInvalidFormat: bool,
    #[doc = "< Specifies if the SD card has error. This parameter is boolean type."]
    pub hasError: bool,
    #[doc = "< SD card total capacity, unit: MB."]
    pub totalSpaceInMB: u32,
    #[doc = "< SD card remaining capacity, unit: MB."]
    pub remainSpaceInMB: u32,
    #[doc = "< Available capture photo count."]
    pub availableCaptureCount: u32,
    #[doc = "< Available video recording second time, unit: s."]
    pub availableRecordingTimeInSeconds: u32,
}
#[doc = " @brief Camera metering target when in spot metering mode."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraSpotMeteringTarget {
    #[doc = "< Specifies column coordinate. This parameter is between 0 and 11."]
    pub col: u8,
    #[doc = "< Specifies row coordinate. This parameter is between 0 and 7."]
    pub row: u8,
}
#[doc = " @brief Camera system state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraSystemState {
    #[doc = "< Specifies the camera current work mode, #E_DjiCameraMode."]
    pub cameraMode: E_DjiCameraMode,
    #[doc = "< Specifies the camera state of shooting, #E_DjiCameraShootingState."]
    pub shootingState: E_DjiCameraShootingState,
    #[doc = "< Specifies if the camera is in storing status. This parameter is boolean type."]
    pub isStoring: bool,
    #[doc = "< Specifies if the camera is in interval shooting start status. This parameter is boolean type."]
    pub isShootingIntervalStart: bool,
    #[doc = "< Specifies the current interval shoot countdown time, the value is decreasing,\n when the value equals to zero trigger the interval take photo, uint:s."]
    pub currentPhotoShootingIntervalTimeInSeconds: u16,
    #[doc = "< Specifies the current interval photo count, the value is decreasing step by one from\n the setted count when interval taking photo"]
    pub currentPhotoShootingIntervalCount: u16,
    #[doc = "< Specifies if the camera is in recording status. This parameter is boolean type."]
    pub isRecording: bool,
    #[doc = "< Specifies the current recording process time, uint:s."]
    pub currentVideoRecordingTimeInSeconds: u16,
    #[doc = "< Specifies if the camera is in overheating status. This parameter is boolean type."]
    pub isOverheating: bool,
    #[doc = "< Specifies if the camera in error status. This parameter is boolean type."]
    pub hasError: bool,
}
impl Default for T_DjiCameraSystemState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Camera focus assistant settings."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraFocusAssistantSettings {
    #[doc = "< Specifies if the lens focus assistant is enabled for manual focusing. This parameter is boolean type."]
    pub isEnabledMF: bool,
    #[doc = "< Specifies if the lens focus assistant is enabled for auto focusing. This parameter is boolean type."]
    pub isEnabledAF: bool,
}
#[doc = " @brief Camera playback status."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraPlaybackStatus {
    #[doc = "< Specifies the duration of video media file, #E_DjiCameraPlaybackMode."]
    pub playbackMode: E_DjiCameraPlaybackMode,
    #[doc = "< Specifies the current play process of video media file. This parameter is between 0 and 100."]
    pub videoPlayProcess: u8,
    #[doc = "< Specifies the total duration of video media file, uint:ms."]
    pub videoLengthMs: u32,
    #[doc = "< Specifies the current play position of video media file, uint:ms."]
    pub playPosMs: u32,
}
impl Default for T_DjiCameraPlaybackStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Camera focus assistant settings."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraMediaFileAttr {
    #[doc = "< Specifies the playback duration of video media file, uint:s."]
    pub attrVideoDuration: u16,
    #[doc = "< Specifies the frame rate of video media file, uint:fps."]
    pub attrVideoFrameRate: u16,
    #[doc = "< Specifies the resolution of video media file, uint:px."]
    pub attrVideoResolution: u16,
}
#[doc = " @brief Camera media file info."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraMediaFileInfo {
    #[doc = "< Specifies the type of media file, #E_DjiCameraMediaFileType."]
    pub type_: E_DjiCameraMediaFileType,
    #[doc = "< Specifies the attributes of media file."]
    pub mediaFileAttr: T_DjiCameraMediaFileAttr,
    #[doc = "< Specifies the size of media file, uint:byte."]
    pub fileSize: u32,
}
impl Default for T_DjiCameraMediaFileInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Camera tap zoom state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraTapZoomState {
    #[doc = "< Camera zoom state."]
    pub zoomState: E_DjiCameraTapZoomState,
    #[doc = "< Flag that specifies whether gimbal is moving for tap zoom."]
    pub isGimbalMoving: bool,
}
impl Default for T_DjiCameraTapZoomState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Camera common features handler.\n @warning User can not execute blocking style operations or functions in callback function, because that will block dji\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraCommonHandler {
    #[doc = " @brief Prototype of callback function used to get camera system state.\n @param systemState: pointer to memory space used to store camera system state.\n @return Execution result."]
    pub GetSystemState: ::std::option::Option<
        unsafe extern "C" fn(systemState: *mut T_DjiCameraSystemState) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera work mode.\n @note Sets the camera's work mode to taking pictures, video, playback. Please note that you cannot change the mode\n when a certain taskHandle is executing, such as taking photo(s), recording video, or downloading and saving files. Also\n supported by thermal imaging camera.\n @param mode: camera work mode.\n @return Execution result."]
    pub SetMode:
        ::std::option::Option<unsafe extern "C" fn(mode: E_DjiCameraMode) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera current work mode.\n @param mode: pointer to memory space used to store camera work mode.\n @return Execution result."]
    pub GetMode:
        ::std::option::Option<unsafe extern "C" fn(mode: *mut E_DjiCameraMode) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to start record video.\n @return Execution result."]
    pub StartRecordVideo: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to stop record video.\n @return Execution result."]
    pub StopRecordVideo: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to start shoot photo.\n @return Execution result."]
    pub StartShootPhoto: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to stop shoot photo.\n @return Execution result."]
    pub StopShootPhoto: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to set camera shoot photo mode.\n @param mode: camera shoot photo mode.\n @return Execution result."]
    pub SetShootPhotoMode: ::std::option::Option<
        unsafe extern "C" fn(mode: E_DjiCameraShootPhotoMode) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera current shoot photo mode.\n @param mode: pointer to memory space used to store camera shoot photo mode.\n @return Execution result."]
    pub GetShootPhotoMode: ::std::option::Option<
        unsafe extern "C" fn(mode: *mut E_DjiCameraShootPhotoMode) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera shoot burst count.\n @param burstCount: camera shoot burst count.\n @return Execution result."]
    pub SetPhotoBurstCount: ::std::option::Option<
        unsafe extern "C" fn(burstCount: E_DjiCameraBurstCount) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera current burst count.\n @param burstCount: pointer to memory space used to store camera shoot burst count.\n @return Execution result."]
    pub GetPhotoBurstCount: ::std::option::Option<
        unsafe extern "C" fn(burstCount: *mut E_DjiCameraBurstCount) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera shoot time interval settings.\n @note The value range of interval photograph count is [2, 255]. If 255 is selected, then the camera will continue\n to take pictures until StopShootPhoto is called.\n @param settings: camera shoot time interval settings.\n @return Execution result."]
    pub SetPhotoTimeIntervalSettings: ::std::option::Option<
        unsafe extern "C" fn(settings: T_DjiCameraPhotoTimeIntervalSettings) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera shoot time interval settings.\n @param settings: pointer to memory space used to store camera shoot time interval settings.\n @return Execution result."]
    pub GetPhotoTimeIntervalSettings: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut T_DjiCameraPhotoTimeIntervalSettings,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera current SDCard state.\n @param sdCardState: pointer to memory space used to store camera SDCard state.\n @return Execution result."]
    pub GetSDCardState: ::std::option::Option<
        unsafe extern "C" fn(sdCardState: *mut T_DjiCameraSDCardState) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to format the SDCard inserted.\n @return Execution result."]
    pub FormatSDCard: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
}
#[doc = " @brief Camera metering feature handler.\n @warning User can not execute blocking style operations or functions in callback function, because that will block dji\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraExposureMeteringHandler {
    #[doc = " @brief Prototype of callback function used to set camera metering mode.\n @param mode: camera metering mode.\n @return Execution result."]
    pub SetMeteringMode: ::std::option::Option<
        unsafe extern "C" fn(mode: E_DjiCameraMeteringMode) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera current metering mode.\n @param mode: pointer to memory space used to store camera metering mode.\n @return Execution result."]
    pub GetMeteringMode: ::std::option::Option<
        unsafe extern "C" fn(mode: *mut E_DjiCameraMeteringMode) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera spot metering target area.\n @param target: camera spot metering target area.\n @return Execution result."]
    pub SetSpotMeteringTarget: ::std::option::Option<
        unsafe extern "C" fn(target: T_DjiCameraSpotMeteringTarget) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera spot metering target area.\n @param target: pointer to memory space used to store camera spot metering target area.\n @return Execution result."]
    pub GetSpotMeteringTarget: ::std::option::Option<
        unsafe extern "C" fn(target: *mut T_DjiCameraSpotMeteringTarget) -> T_DjiReturnCode,
    >,
}
#[doc = " @brief Camera focus feature handler.\n @warning User can not execute blocking style operations or functions in callback function, because that will block dji\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraFocusHandler {
    #[doc = " @brief Prototype of callback function used to set camera focus mode.\n @param mode: camera focus mode.\n @return Execution result."]
    pub SetFocusMode:
        ::std::option::Option<unsafe extern "C" fn(mode: E_DjiCameraFocusMode) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera current focus mode.\n @param mode: pointer to memory space used to store camera focus mode.\n @return Execution result."]
    pub GetFocusMode: ::std::option::Option<
        unsafe extern "C" fn(mode: *mut E_DjiCameraFocusMode) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera focus target area.\n @param target: camera focus target area.\n @return Execution result."]
    pub SetFocusTarget: ::std::option::Option<
        unsafe extern "C" fn(target: T_DjiCameraPointInScreen) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera focus target area.\n @param target: pointer to memory space used to store camera focus target area.\n @return Execution result."]
    pub GetFocusTarget: ::std::option::Option<
        unsafe extern "C" fn(target: *mut T_DjiCameraPointInScreen) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera focus assistant settings.\n @param settings: camera focus assistant settings.\n @return Execution result."]
    pub SetFocusAssistantSettings: ::std::option::Option<
        unsafe extern "C" fn(settings: T_DjiCameraFocusAssistantSettings) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera focus assistant settings.\n @param settings: pointer to memory space used to store camera focus assistant settings.\n @return Execution result."]
    pub GetFocusAssistantSettings: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut T_DjiCameraFocusAssistantSettings) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set camera focus ring value.\n @param value: camera focus ring value.\n @return Execution result."]
    pub SetFocusRingValue:
        ::std::option::Option<unsafe extern "C" fn(value: u32) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera focus ring value.\n @param value: pointer to memory space used to store camera focus ring value.\n @return Execution result."]
    pub GetFocusRingValue:
        ::std::option::Option<unsafe extern "C" fn(value: *mut u32) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera focus upper bound ring value.\n @param value: pointer to memory space used to store camera focus upper bound value.\n @return Execution result."]
    pub GetFocusRingValueUpperBound:
        ::std::option::Option<unsafe extern "C" fn(value: *mut u32) -> T_DjiReturnCode>,
}
#[doc = " @brief Camera digital zoom feature handler.\n @warning User can not execute blocking style operations or functions in callback function, because that will block dji\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraDigitalZoomHandler {
    #[doc = " @brief Prototype of callback function used to set camera digital zoom factor.\n @param factor: camera digital zoom factor.\n @return Execution result."]
    pub SetDigitalZoomFactor:
        ::std::option::Option<unsafe extern "C" fn(factor: dji_f32_t) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera current digital zoom factor.\n @param factor: pointer to memory space used to store camera current digital zoom factor.\n @return Execution result."]
    pub GetDigitalZoomFactor:
        ::std::option::Option<unsafe extern "C" fn(factor: *mut dji_f32_t) -> T_DjiReturnCode>,
}
#[doc = " @brief Camera optical zoom feature handler.\n @warning User can not execute blocking style operations or functions in callback function, because that will block dji\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraOpticalZoomHandler {
    #[doc = " @brief Prototype of callback function used to set camera optical zoom focal length.\n @param focalLength: camera optical zoom focal length.\n @return Execution result."]
    pub SetOpticalZoomFocalLength:
        ::std::option::Option<unsafe extern "C" fn(focalLength: u32) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera optical zoom focal length.\n @param focalLength: pointer to memory space used to store camera optical zoom focal length.\n @return Execution result."]
    pub GetOpticalZoomFocalLength:
        ::std::option::Option<unsafe extern "C" fn(focalLength: *mut u32) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera optical zoom factor.\n @param factor: pointer to memory space used to store camera optical zoom factor.\n @return Execution result."]
    pub GetOpticalZoomFactor:
        ::std::option::Option<unsafe extern "C" fn(factor: *mut dji_f32_t) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get camera optical zoom specifies.\n @param spec: pointer to memory space used to store camera optical zoom specifies.\n @return Execution result."]
    pub GetOpticalZoomSpec: ::std::option::Option<
        unsafe extern "C" fn(spec: *mut T_DjiCameraOpticalZoomSpec) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to start continuous optical zoom.\n @param direction: camera zoom direction.\n @param speed: camera zoom speed.\n @return Execution result."]
    pub StartContinuousOpticalZoom: ::std::option::Option<
        unsafe extern "C" fn(
            direction: E_DjiCameraZoomDirection,
            speed: E_DjiCameraZoomSpeed,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to stop continuous optical zoom.\n @return Execution result."]
    pub StopContinuousOpticalZoom: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
}
#[doc = " @brief Prototype of handler functions for media file download and playback.\n @warning User can not execute blocking style operations or functions in callback function, because that will block dji\n root thread, causing problems such as slow system response, payload disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraMediaDownloadPlaybackHandler {
    #[doc = " @brief Prototype of callback function used to get camera media file path.\n @warning The maximum length of path that users can pass in is 256, including end character '\\0'.\n @param dirPath: pointer to memory space used to store camera media file path.\n @return Execution result."]
    pub GetMediaFileDir: ::std::option::Option<
        unsafe extern "C" fn(dirPath: *mut ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get the file info of the selected origin media file.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @param fileInfo: pointer to memory space used to store file info of the selected origin media file.\n @return Execution result."]
    pub GetMediaFileOriginInfo: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            fileInfo: *mut T_DjiCameraMediaFileInfo,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get the data of the selected origin media file.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @param offset: the offset of origin file data that need get from the selected media file.\n @param length: the length of origin file data that need get from the selected media file.\n @param data: pointer to memory space used to store the selected origin media file.\n @return Execution result."]
    pub GetMediaFileOriginData: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            offset: u32,
            length: u32,
            data: *mut u8,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to create the thumb nail of selected media file.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @return Execution result."]
    pub CreateMediaFileThumbNail: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get the file info of the created thumbnail.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @param fileInfo: pointer to memory space used to store file info of the created thumbnail.\n @return Execution result."]
    pub GetMediaFileThumbNailInfo: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            fileInfo: *mut T_DjiCameraMediaFileInfo,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get the data of the created thumbnail.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @param offset: the offset of thumb nail data that need get from the selected media file.\n @param length: the length of thumb nail data that need get from the selected media file.\n @param data: pointer to memory space used to store the created thumbnail data.\n @return Execution result."]
    pub GetMediaFileThumbNailData: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            offset: u32,
            length: u32,
            data: *mut u8,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to destroy the created thumb nail of selected media file.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @return Execution result."]
    pub DestroyMediaFileThumbNail: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to create the screen nail of selected media file.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @return Execution result."]
    pub CreateMediaFileScreenNail: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get the data of the created screen nail.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @param offset: the offset of screen nail data that need get from selected media file.\n @param length: the length of screen nail data that need get from selected media file.\n @param data: pointer to memory space used to store the created screen nail data.\n @return Execution result."]
    pub GetMediaFileScreenNailData: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            offset: u32,
            length: u32,
            data: *mut u8,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get the file info of the created screen nail.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @param fileInfo: pointer to memory space used to store file info of the created screen nail.\n @return Execution result."]
    pub GetMediaFileScreenNailInfo: ::std::option::Option<
        unsafe extern "C" fn(
            filePath: *const ::std::os::raw::c_char,
            fileInfo: *mut T_DjiCameraMediaFileInfo,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to destroy the created screen nail of selected media file.\n @param dirPath: pointer to memory space used to store camera current media file path.\n @return Execution result."]
    pub DestroyMediaFileScreenNail: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to notification when download starting.\n @note You can adjust the bandwidth proportion of each high speed channel in the notification callback.\n @return Execution result."]
    pub StartDownloadNotification: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to notification when download stoping.\n @note You can adjust the bandwidth proportion of each high speed channel in the notification callback.\n @return Execution result."]
    pub StopDownloadNotification: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to delete the user's media files.\n @param filePath: pointer to memory space used to store camera current media file path.\n @return Execution result."]
    pub DeleteMediaFile: ::std::option::Option<
        unsafe extern "C" fn(filePath: *mut ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get camera media playback status.\n @param status: pointer to memory space used to store camera media file path.\n @return Execution result."]
    pub GetMediaPlaybackStatus: ::std::option::Option<
        unsafe extern "C" fn(status: *mut T_DjiCameraPlaybackStatus) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to set the file path of media file that need playback.\n @param filePath: pointer to memory space used to store the file path of media file that need playback.\n @return Execution result."]
    pub SetMediaPlaybackFile: ::std::option::Option<
        unsafe extern "C" fn(filePath: *const ::std::os::raw::c_char) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to start media video playback when camera work in playback mode.\n @return Execution result."]
    pub StartMediaPlayback: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to stop media video playback when camera work in playback mode.\n @return Execution result."]
    pub StopMediaPlayback: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to pause media video playback when camera work in playback mode.\n @return Execution result."]
    pub PauseMediaPlayback: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to seek to the playback position of media video when camera work in playback mode.\n @param playbackPosition: playback position of video media, unit: ms.\n @return Execution result."]
    pub SeekMediaPlayback:
        ::std::option::Option<unsafe extern "C" fn(playbackPosition: u32) -> T_DjiReturnCode>,
}
#[doc = " @brief Prototype of handler functions for tap zooming.\n @note User can not execute blocking style operations or functions in callback function, like djiXPort_RotateSync()\n function, because that will block dji root thread, causing problems such as slow system response, payload\n disconnection or infinite loop."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiCameraTapZoomHandler {
    #[doc = " @brief Prototype of callback function used to get tap zoom state.\n @param state: pointer to memory space used to store tap zoom state.\n @return Execution result."]
    pub GetTapZoomState: ::std::option::Option<
        unsafe extern "C" fn(state: *mut T_DjiCameraTapZoomState) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to enable or disable tap zoom function.\n @details dji application should response tap zoom command only if tap zoom function is enabled.\n @param enabledFlag: enabled flag.\n @return Execution result."]
    pub SetTapZoomEnabled:
        ::std::option::Option<unsafe extern "C" fn(enabledFlag: bool) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get the flag that specifies whether tap zoom function has been\n enabled,\n @param enabledFlag: pointer to memory space used to store enabled flag.\n @return Execution result."]
    pub GetTapZoomEnabled:
        ::std::option::Option<unsafe extern "C" fn(enabledFlag: *mut bool) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to set multiplier of single tap zoom.\n @param multiplier: multiplier of single tap zoom.\n @return Execution result."]
    pub SetTapZoomMultiplier:
        ::std::option::Option<unsafe extern "C" fn(multiplier: u8) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to get multiplier of single tap zoom.\n @param multiplier: pointer to memory space use to store multiplier of single tap zoom.\n @return Execution result."]
    pub GetTapZoomMultiplier:
        ::std::option::Option<unsafe extern "C" fn(multiplier: *mut u8) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to trigger tap zoom.\n @details Users trigger tap zoom in screen of mobile end, this callback function will be called. Then, dji\n application should rotate gimbal to orientation of target point and zoom by specified multiplier.\n @param target: position information of target point in screen.\n @return Execution result."]
    pub TapZoomAtTarget: ::std::option::Option<
        unsafe extern "C" fn(target: T_DjiCameraPointInScreen) -> T_DjiReturnCode,
    >,
}
extern "C" {
    #[doc = " @brief Initialize the payload camera module.\n @note The interface is the total initialization interface of the camera module. The following interfaces are optional\n functions and can be freely selected according to the actual load device condition of the user. Before registering\n the optional interface, the interface must be initialized before the system can work normally. Interface initialization\n needs to be after djiCore_Init.\n @return Execution result."]
    pub fn DjiPayloadCamera_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for payload camera common function interfaces.\n @note This interface registers the camera's basic function interface, including camera camera, video, mode settings,\n SD card operation, camera status interface. Registration of this interface needs to be after DjiPayloadCamera_Init.\n @param cameraCommonHandler: pointer to the handler for payload camera common functions.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegCommonHandler(
        cameraCommonHandler: *const T_DjiCameraCommonHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for payload camera exposure and metering function interfaces.\n @note This interface registers the spot metering and exposure interface of the camera. It currently includes\n setting and acquiring the metering mode and metering area. Special attention must be paid to the limitations\n of the interface parameters. Registration of this interface needs to be after DjiPayloadCamera_Init.\n @param cameraExposureMeteringHandler: pointer to the handler for payload camera exposure and metering functions.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegExposureMeteringHandler(
        cameraExposureMeteringHandler: *const T_DjiCameraExposureMeteringHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for payload camera focus function interfaces.\n @note This interface registers the camera's focus interface, which includes setting and acquiring the focus mode,\n focus area, and focus settings. Special attention must be paid to the interface parameters. Registration of\n this interface needs to be after DjiPayloadCamera_Init.\n @param cameraFocusHandler: pointer to the handler for payload camera focus functions.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegFocusHandler(
        cameraFocusHandler: *const T_DjiCameraFocusHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for payload camera digital zoom function interfaces.\n @note This interface registers the camera's digital zoom interface, which includes setting and obtaining the digital\n zoom zoom factor. Registering the load on this interface requires digital zoom. Registration of this interface\n needs to be after DjiPayloadCamera_Init.\n @param cameraDigitalZoomHandler: pointer to the handler for payload camera digital zoom functions.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegDigitalZoomHandler(
        cameraDigitalZoomHandler: *const T_DjiCameraDigitalZoomHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for payload camera optical zoom function interfaces.\n @note This interface registers the camera's optical zoom interface, which includes setting and acquiring optical zoom\n parameters, and a continuous zoom interface. Registering the load on this interface requires support for optical\n zoom. Registration of this interface needs to be after DjiPayloadCamera_Init.\n @param cameraOpticalZoomHandler: pointer to the handler for payload camera optical zoom functions.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegOpticalZoomHandler(
        cameraOpticalZoomHandler: *const T_DjiCameraOpticalZoomHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register handler functions for tap zoom function.\n @details Registration specifies dji application support tap zoom function.\n @param cameraTapZoomHandler: pointer to structure of handler functions for tap zoom function.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegTapZoomHandler(
        cameraTapZoomHandler: *const T_DjiCameraTapZoomHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set the type of camera video stream.\n @note The interface is used to set the camera video stream type. Must ensure the format of video stream conforms to\n the specified type in E_DjiCameraVideoStreamType, please refer to developer documentation for more details.\n @attention Set video stream type must before calling djiCore_ApplicationStart function, when calling this interface\n the thread will be blocked, and the maximum blocking time is 10s. If this interface is not called, the default video\n stream type ::DJI_CAMERA_VIDEO_STREAM_TYPE_H264_CUSTOM_FORMAT will be used.\n @param videoStreamType: camera video stream type.\n @return Execution result."]
    pub fn DjiPayloadCamera_SetVideoStreamType(
        videoStreamType: E_DjiCameraVideoStreamType,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the network remote address for sending camera video stream.\n @note The interface is used to get the network remote address for sending camera video stream. You can get this info for another\n heterogeneous system to do somethings. This interface should be used after calling djiCore_Init function.\n @attention If you want use this interface, should call djiPlatform_RegHalNetworkHandler interface firstly, otherwise\n this interface will not work.\n @param ipAddr: the remote ip address for sending camera video stream.\n @param port: the remote port for sending camera video stream.\n @return Execution result."]
    pub fn DjiPayloadCamera_GetVideoStreamRemoteAddress(
        ipAddr: *mut ::std::os::raw::c_char,
        port: *mut u16,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for payload camera media download and playback function interfaces.\n @note Registering the camera playback and downloading related interfaces, mainly able to operate the media files of\n the user storage device online through the playback interface of the pilot. It can playback and download files\n of pictures and videos`. Currently, only media files in MP4 and JPG formats are supported.\n @param cameraMediaHandler: pointer to the handler for payload camera media download and playback functions.\n @return Execution result."]
    pub fn DjiPayloadCamera_RegMediaDownloadPlaybackHandler(
        cameraMediaHandler: *const T_DjiCameraMediaDownloadPlaybackHandler,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Send the video to mobile end via video stream of the data channel. This function exists and can be used only in Linux.\n @note Must ensure actual bandwidth is less than bandwidth limitation of corresponding channel or stream, please\n refer to developer documentation and state of channel/stream for details related to bandwidth limitation. User can\n get state of \"videoStream\" channel via DjiPayloadCamera_GetVideoStreamState() function. If actual bandwidth\n exceeds the limitation or busy state is set, the user should stop transmitting data or decrease amount of data to be\n sent. Otherwise, data may be discarded.\n @param data: pointer to data to be sent.\n @param len: length of data to be sent via data stream, and it must be less than or equal to 65000, unit: byte.\n @return Execution result."]
    pub fn DjiPayloadCamera_SendVideoStream(data: *const u8, len: u16) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get data transmission state of \"videoStream\" channel. User can use the state as base for controlling data\n transmission of video stream. This function exists and can be used only in Linux operation system.\n @param state: pointer to \"videoStream\" channel state.\n @return Execution result."]
    pub fn DjiPayloadCamera_GetVideoStreamState(
        state: *mut T_DjiDataChannelState,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Push added media file information to aircraft system.\n @details After photography or recording video, users must push information of created media file immediately using\n this interface.\n @param filePath: pointer to path of added media file. Guaranteed to end with '\\0'. Length of path have to be less\n than ::dji_FILE_PATH_SIZE_MAX bytes.\n @param mediaFileInfo: information of added media file.\n @return Execution result."]
    pub fn DjiPayloadCamera_PushAddedMediaFileInfo(
        filePath: *const ::std::os::raw::c_char,
        mediaFileInfo: T_DjiCameraMediaFileInfo,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get camera type of other payloads mounted on aircraft.\n @note Please refer to DJI documentation in DJI SDK developer website for details of conditions of use.\n @note If there is empty in requested position or payload do not have camera type, the interface will return error.\n @param payloadPosition: position where payload mounted on.\n @param cameraType: Pointer to camera type of payload.\n @return Execution result."]
    pub fn DjiPayloadCamera_GetCameraTypeOfPayload(
        payloadPosition: E_DjiMountPosition,
        cameraType: *mut E_DjiCameraType,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get optical zoom specification of other camera payloads mounted on aircraft.\n @note Please refer to DJI documentation in DJI SDK developer website for details of conditions of use.\n @note If there is empty in requested position or payload do not have related information, the interface will return\n error.\n @param payloadPosition: position where payload mounted on.\n @param opticalZoomSpec: pointer to optical zoom specification.\n @return Execution result."]
    pub fn DjiPayloadCamera_GetCameraOpticalZoomSpecOfPayload(
        payloadPosition: E_DjiMountPosition,
        opticalZoomSpec: *mut T_DjiCameraOpticalZoomSpec,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get hybrid zoom focal length of other camera payloads mounted on aircraft.\n @note Please refer to DJI documentation in DJI SDK developer website for details of conditions of use.\n @note If there is empty in requested position or payload do not have related information, the interface will return\n error.\n @param payloadPosition: position where payload mounted on.\n @param focalLength: Pointer to optical focal length, unit: 0.1mm.\n @return Execution result."]
    pub fn DjiPayloadCamera_GetCameraHybridZoomFocalLengthOfPayload(
        payloadPosition: E_DjiMountPosition,
        focalLength: *mut u16,
    ) -> T_DjiReturnCode;
}
pub const E_DjiPerceptionDirection_DJI_PERCEPTION_RECTIFY_DOWN: E_DjiPerceptionDirection = 0;
pub const E_DjiPerceptionDirection_DJI_PERCEPTION_RECTIFY_FRONT: E_DjiPerceptionDirection = 1;
pub const E_DjiPerceptionDirection_DJI_PERCEPTION_RECTIFY_REAR: E_DjiPerceptionDirection = 2;
pub const E_DjiPerceptionDirection_DJI_PERCEPTION_RECTIFY_UP: E_DjiPerceptionDirection = 3;
pub const E_DjiPerceptionDirection_DJI_PERCEPTION_RECTIFY_LEFT: E_DjiPerceptionDirection = 4;
pub const E_DjiPerceptionDirection_DJI_PERCEPTION_RECTIFY_RIGHT: E_DjiPerceptionDirection = 5;
#[doc = " @bref Perception camera direction"]
pub type E_DjiPerceptionDirection = ::std::os::raw::c_uint;
pub const E_DjiPerceptionCameraPosition_RECTIFY_DOWN_LEFT: E_DjiPerceptionCameraPosition = 1;
pub const E_DjiPerceptionCameraPosition_RECTIFY_DOWN_RIGHT: E_DjiPerceptionCameraPosition = 2;
pub const E_DjiPerceptionCameraPosition_RECTIFY_FRONT_LEFT: E_DjiPerceptionCameraPosition = 3;
pub const E_DjiPerceptionCameraPosition_RECTIFY_FRONT_RIGHT: E_DjiPerceptionCameraPosition = 4;
pub const E_DjiPerceptionCameraPosition_RECTIFY_REAR_LEFT: E_DjiPerceptionCameraPosition = 5;
pub const E_DjiPerceptionCameraPosition_RECTIFY_REAR_RIGHT: E_DjiPerceptionCameraPosition = 6;
pub const E_DjiPerceptionCameraPosition_RECTIFY_UP_LEFT: E_DjiPerceptionCameraPosition = 21;
pub const E_DjiPerceptionCameraPosition_RECTIFY_UP_RIGHT: E_DjiPerceptionCameraPosition = 22;
pub const E_DjiPerceptionCameraPosition_RECTIFY_LEFT_LEFT: E_DjiPerceptionCameraPosition = 23;
pub const E_DjiPerceptionCameraPosition_RECTIFY_LEFT_RIGHT: E_DjiPerceptionCameraPosition = 24;
pub const E_DjiPerceptionCameraPosition_RECTIFY_RIGHT_LEFT: E_DjiPerceptionCameraPosition = 25;
pub const E_DjiPerceptionCameraPosition_RECTIFY_RIGHT_RIGHT: E_DjiPerceptionCameraPosition = 26;
#[doc = " @bref Perception camera design location"]
pub type E_DjiPerceptionCameraPosition = ::std::os::raw::c_uint;
#[doc = " @bref Perception camera ram image info"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiPerceptionRawImageInfo {
    pub index: u32,
    pub direction: u8,
    pub bpp: u8,
    pub width: u32,
    pub height: u32,
}
#[doc = " @bref Perception camera image info"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiPerceptionImageInfo {
    pub rawInfo: T_DjiPerceptionRawImageInfo,
    pub dataId: u16,
    pub sequence: u16,
    pub dataType: u32,
    pub timeStamp: u64,
}
#[doc = " @bref Perception camera parameters"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiPerceptionCameraParameters {
    pub direction: u8,
    pub leftIntrinsics: [f32; 9usize],
    pub rightIntrinsics: [f32; 9usize],
    pub rotationLeftInRight: [f32; 9usize],
    pub translationLeftInRight: [f32; 3usize],
}
#[doc = " @bref Perception camera parameters packet"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiPerceptionCameraParametersPacket {
    pub timeStamp: u32,
    pub directionNum: u32,
    pub cameraParameters: [T_DjiPerceptionCameraParameters; 6usize],
}
#[doc = " @bref Callback type to receive stereo camera image"]
pub type DjiPerceptionImageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        imageInfo: T_DjiPerceptionImageInfo,
        imageRawBuffer: *mut u8,
        bufferLen: u32,
    ),
>;
extern "C" {
    #[doc = " @brief Initialize the perception module.\n @note The interface initialization needs to be after DjiCore_Init.\n @return Execution result."]
    pub fn DjiPerception_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialize the perception module.\n @return Execution result."]
    pub fn DjiPerception_Deinit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Subscribe the raw images of both stereo cameras in the same direction. Default frequency at 20 Hz.\n @param direction: direction to specify the direction of the subscription. Ref to E_DjiPerceptionDirection\n @param callback callback to observer the stereo camera image and info.\n @return Execution result."]
    pub fn DjiPerception_SubscribePerceptionImage(
        direction: E_DjiPerceptionDirection,
        callback: DjiPerceptionImageCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Unsubscribe the raw image of both stereo cameras in the same direction.\n @param direction: direction to specify the direction of the subscription. Ref to E_DjiPerceptionDirection\n @return Execution result."]
    pub fn DjiPerception_UnsubscribePerceptionImage(
        direction: E_DjiPerceptionDirection,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the internal and external parameters of all stereo cameras.\n @return Execution result."]
    pub fn DjiPerception_GetStereoCameraParameters(
        packet: *mut T_DjiPerceptionCameraParametersPacket,
    ) -> T_DjiReturnCode;
}
#[doc = " @brief Prototype of callback function used to get the newest PPS triggered timestamp.\n @warning User can not execute blocking style operations or functions in callback function, because that will block DJI\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param localTimeUs: pointer to memory space used to store PPS triggered timestamp.\n @return Execution result."]
pub type DjiGetNewestPpsTriggerLocalTimeUsCallback =
    ::std::option::Option<unsafe extern "C" fn(localTimeUs: *mut u64) -> T_DjiReturnCode>;
#[doc = " @brief Data structure of time in aircraft time system."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiTimeSyncAircraftTime {
    #[doc = "< Specifies year."]
    pub year: u16,
    #[doc = "< Specifies month, range from 1 to 12."]
    pub month: u8,
    #[doc = "< Specifies day, range from 1 to 31."]
    pub day: u8,
    #[doc = "< Specifies hour, range from 0 to 23."]
    pub hour: u8,
    #[doc = "< Specifies minute, range from 0 to 59."]
    pub minute: u8,
    #[doc = "< Specifies second, range from 0 to 59."]
    pub second: u8,
    #[doc = "< Specifies microsecond, range from 0 to 999999."]
    pub microsecond: u32,
}
extern "C" {
    #[doc = " @brief Initialise time synchronization module in blocking mode. User should call this function before all other time\n synchronization operations, just like transferring time.\n @note Max execution time of this function is slightly larger than 2000ms.\n @note This function have to be called in user task, rather than main() function, and after scheduler being started.\n @return Execution result."]
    pub fn DjiTimeSync_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to get the newest timestamp in local time system when PPS rising edge signal\n is detected.\n @details DJI uses the timestamp information to synchronise time of local time system and RTK navigation and\n positioning system.\n @param callback: pointer to the callback function.\n @return Execution result."]
    pub fn DjiTimeSync_RegGetNewestPpsTriggerTimeCallback(
        callback: DjiGetNewestPpsTriggerLocalTimeUsCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Transfer local time to time in aircraft time system.\n @note Before calling the interface, users must call DjiTimeSync_RegGetNewestPpsTriggerTimeCallback() to register\n callback function used to report the latest triggered time of PPS signal.\n @param localTimeUs: local time, unit: microsecond.\n @param aircraftTime: pointer to memory space used to store time in aircraft time system.\n @return Execution result."]
    pub fn DjiTimeSync_TransferToAircraftTime(
        localTimeUs: u64,
        aircraftTime: *mut T_DjiTimeSyncAircraftTime,
    ) -> T_DjiReturnCode;
}
pub const E_DjiPositioningRtcmDataType_DJI_POSITIONING_RTCM_DATA_TYPE_RTK_ON_AIRCRAFT:
    E_DjiPositioningRtcmDataType = 0;
pub const E_DjiPositioningRtcmDataType_DJI_POSITIONING_RTCM_DATA_TYPE_RTK_BASE_STATION:
    E_DjiPositioningRtcmDataType = 1;
#[doc = " @brief Positioning rtcm data type."]
pub type E_DjiPositioningRtcmDataType = ::std::os::raw::c_uint;
#[doc = " @brief Data structure that describes a positioning event."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiPositioningEventInfo {
    #[doc = " Index of event set in which positioning event is located. The item will be written to mark file in aircraft for\n some post-precess work. If not needed, fill in 0."]
    pub eventSetIndex: u16,
    #[doc = " Index of target point in payload whose position user is requesting. The item will be written to mark file in\n aircraft for some post-precess work. If not needed, fill in 0."]
    pub targetPointIndex: u8,
    #[doc = " Timestamp in aircraft time system when the positioning event occur. Users should transfer time in local time\n system to time in aircraft time system by DjiTimeSync_TransferToAircraftTime() interface in time\n synchronization module."]
    pub eventTime: T_DjiTimeSyncAircraftTime,
}
#[doc = " @brief Data structure that describes position of a point."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiPositioningPosition {
    #[doc = "< Specifies longitude, unit: degree."]
    pub longitude: dji_f64_t,
    #[doc = "< Specifies latitude, unit: degree."]
    pub latitude: dji_f64_t,
    #[doc = "< Specifies height above sea level, unit: m."]
    pub height: dji_f64_t,
}
#[doc = " @brief Position value standard deviation."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiPositioningPositionStandardDeviation {
    #[doc = "< Specifies longitude standard deviation, unit: degree."]
    pub longitude: dji_f32_t,
    #[doc = "< Specifies latitude standard deviation， unit: degree."]
    pub latitude: dji_f32_t,
    #[doc = "< Specifies height standard deviation， unit: m."]
    pub height: dji_f32_t,
}
#[doc = " @brief Position of target point and other details returned by interface of requesting position."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiPositioningPositionInfo {
    #[doc = "< Property of position solution."]
    pub positionSolutionProperty: E_DjiFcSubscriptionPositionSolutionProperty,
    #[doc = "< Specifies UAV attitude, unit: degree."]
    pub uavAttitude: T_DjiAttitude3d,
    #[doc = "< Specifies position offset from RTK main antenna to target points in NED coordinate system, unit: mm."]
    pub offsetBetweenMainAntennaAndTargetPoint: T_DjiVector3d,
    #[doc = "< Specifies position of target points in GROUND coordinate system."]
    pub targetPointPosition: T_DjiPositioningPosition,
    #[doc = "< Specifies position standard deviation of target points."]
    pub targetPointPositionStandardDeviation: T_DjiPositioningPositionStandardDeviation,
}
impl Default for T_DjiPositioningPositionInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Prototype of callback function used to receive the rtk rtcm raw data.\n @param index: the index of rtcm data package.\n @param data: pointer to receive rtk rtcm data from aircraft.\n @param dataLen: receive data length of rtcm data from aircraft.\n @return Execution result."]
pub type DjiReceiveRtkRtcmDataCallback = ::std::option::Option<
    unsafe extern "C" fn(index: u8, data: *const u8, dataLen: u16) -> T_DjiReturnCode,
>;
extern "C" {
    #[doc = " @brief Initialise positioning module in blocking mode. User should call this function before all other positioning\n operations, just like setting task index, register callback function and requesting positions.\n @note Max execution time of this function is slightly larger than 500ms.\n @note This function has to be called in user task, rather than main() function, and after scheduler being started.\n @return Execution result."]
    pub fn DjiPositioning_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set task index, specifying a sequence number of operations, using to write to mark the file for some post-process\n flows.\n @details One operation may be a precise surveying and mapping task or ten exposures of camera. The default task index\n is 0.\n @param index: task index."]
    pub fn DjiPositioning_SetTaskIndex(index: u8);
}
extern "C" {
    #[doc = " @brief The interface is used to get the position of target points and other information (refer to\n ::T_DjiPositioningPositionInfo) based on the timestamp in aircraft time system when some events (positioning events) are\n triggered. The function uses blocking mode.\n @details Users can request positions for multiple events (event set) conveniently, such as sync exposure of\n multiple cameras. User must register callback function used to get the newest PPS triggered timestamp (refer to\n DjiPositioning_RegGetNewestPpsTriggerTimeCallback()) before requesting position. When users have set structure\n parameters of payload and interest points (the points whose position user hope to get, e.g. center point of the camera\n image sensor), the target points are interest points, otherwise the target points are main gimbal interface center.\n Users can use position information of gimbal interface center, position offset between gimbal interface center and\n RTK main antenna, UAV attitude, gimbal structure parameters ,and gimbal attitude to calculate the position of interest\n points in the payload.\n @note Max execution time of this function is slightly larger than 600ms.\n @note All requested timestamp have to be between the time point 2 seconds earlier than the newest synchronized\n timestamp and the time point 1 seconds earlier than the newest synchronized timestamp.\n @param eventCount: count of positioning event set specified by eventInfo parameter. Please ensure the count is less\n than 5.\n @param eventInfo: pointer to positioning event information array.\n @param positionInfo: the position of target points. In Matrice 210 RTK V2 and Matrice 300 RTK aircraft system, it is\n the position of the main gimbal interface always.\n @return Execution result."]
    pub fn DjiPositioning_GetPositionInformationSync(
        eventCount: u8,
        eventInfo: *mut T_DjiPositioningEventInfo,
        positionInfo: *mut T_DjiPositioningPositionInfo,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to receive rtk rtcm raw data by data type.\n @note The callback function will be called after registering. The call frequency depends on the number of satellites.\n @param callback: pointer to the callback function.\n @return Execution result."]
    pub fn DjiPositioning_RegReceiveRtcmDataCallback(
        dataType: E_DjiPositioningRtcmDataType,
        callback: DjiReceiveRtkRtcmDataCallback,
    ) -> T_DjiReturnCode;
}
#[doc = "< Specifies pin is in low level state."]
pub const E_DjiPowerManagementPinState_DJI_POWER_MANAGEMENT_PIN_STATE_RESET:
    E_DjiPowerManagementPinState = 0;
#[doc = "< Specifies pin is in high level state."]
pub const E_DjiPowerManagementPinState_DJI_POWER_MANAGEMENT_PIN_STATE_SET:
    E_DjiPowerManagementPinState = 1;
#[doc = " @brief Pin state."]
pub type E_DjiPowerManagementPinState = ::std::os::raw::c_uint;
#[doc = " @brief Prototype of callback function used to set level of high power application pin.\n @param pinState: level state of pin to be set.\n @return Execution result."]
pub type DjiWriteHighPowerApplyPinCallback = ::std::option::Option<
    unsafe extern "C" fn(pinState: E_DjiPowerManagementPinState) -> T_DjiReturnCode,
>;
#[doc = " @brief Prototype of callback function used to notify payload that the aircraft will power off soon and get state\n whether the payload is ready to power off or not.\n @warning User can not execute blocking style operations or functions in a callback function, because that will block DJI\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param powerOffPreparationFlag: pointer to memory space used to store power off preparation flag. True represents\n that payload has completed all work and is ready to power off. False represents that payload is not ready to power\n off.\n @return Execution result."]
pub type DjiPowerOffNotificationCallback = ::std::option::Option<
    unsafe extern "C" fn(powerOffPreparationFlag: *mut bool) -> T_DjiReturnCode,
>;
extern "C" {
    #[doc = " @brief Initialise power management module, and user should call this function before using power management features.\n @return Execution result."]
    pub fn DjiPowerManagement_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief DeInitialise power management module, and user should call this function before using power management features.\n @return Execution result."]
    pub fn DjiPowerManagement_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Apply high power from aircraft in blocking mode.\n @details Before applying, user should register callback function used to set level state of high power application\n pin using DjiPowerManagement_RegWriteHighPowerApplyPinCallback() function. After applying high power, power pin of\n DJI adapter will output high power based predetermined specification.\n @note Max execution time of this function is slightly larger than 600ms.\n @return Execution result."]
    pub fn DjiPowerManagement_ApplyHighPowerSync() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to set level state of high power application pin. Must be called before\n applying high power.\n @param callback: pointer to the callback function.\n @return Execution result."]
    pub fn DjiPowerManagement_RegWriteHighPowerApplyPinCallback(
        callback: DjiWriteHighPowerApplyPinCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to notify payload that the aircraft will power off soon and get state\n whether the payload is ready to power off or not.\n @details After registering, the callback function will be called at a fixed frequency when aircraft will power off.\n User fill in the power off preparation flag, and once the payload is ready to power off, the callback function will not\n be called. After a specified time, if the payload is not ready to power off, the aircraft will power off immediately. The\n specified time is 10s.\n @param callback: pointer to callback function used to notify aircraft power off message and get payload power off\n preparation flag.\n @return Execution result."]
    pub fn DjiPowerManagement_RegPowerOffNotificationCallback(
        callback: DjiPowerOffNotificationCallback,
    ) -> T_DjiReturnCode;
}
#[doc = " @brief FTP firmware transfer type.\n @note This transfer type only support linux platform and use network port. Users need to deploy FTP service on\n payload. The ftp user info used to transfer upgrade firmware is :\n username:dji_payload_ftp\n password:DJi_#$31\n You can get guide about FTP service deployment on https://developer.dji.com/payload-sdk/documentation"]
pub const E_DjiFirmwareTransferType_DJI_FIRMWARE_TRANSFER_TYPE_FTP: E_DjiFirmwareTransferType = 0;
#[doc = " @brief DCFTP firmware transfer type.\n @details DCFTP (DJI Common File Transfer Protocol) is a private protocol used to transfer file on DJI Product.\n Users can get file data by command callbacks, see :: T_DjiUpgradeDcftpFileTransferOpt.\n @note This transfer type is used to support RTOS platform or payload don't have network port. The transfer speed\n is very slow compare to FTP because it uses low speed transfer channel."]
pub const E_DjiFirmwareTransferType_DJI_FIRMWARE_TRANSFER_TYPE_DCFTP: E_DjiFirmwareTransferType = 1;
pub type E_DjiFirmwareTransferType = ::std::os::raw::c_uint;
#[doc = "< Idle stage means not in upgrade mode."]
pub const E_DjiUpgradeStage_DJI_UPGRADE_STAGE_IDLE: E_DjiUpgradeStage = 0;
#[doc = "< Ongoing stage means payload is upgrading."]
pub const E_DjiUpgradeStage_DJI_UPGRADE_STAGE_ONGOING: E_DjiUpgradeStage = 3;
#[doc = "< Device reboot stage means device is rebooting."]
pub const E_DjiUpgradeStage_DJI_UPGRADE_STAGE_DEVICE_REBOOT: E_DjiUpgradeStage = 6;
#[doc = "< End Stage means upgrade finish and reporting upgrade result to the terminal APP."]
pub const E_DjiUpgradeStage_DJI_UPGRADE_STAGE_END: E_DjiUpgradeStage = 4;
pub type E_DjiUpgradeStage = ::std::os::raw::c_uint;
#[doc = "< Upgrade success."]
pub const E_DjiUpgradeEndState_DJI_UPGRADE_END_STATE_SUCCESS: E_DjiUpgradeEndState = 1;
#[doc = "< Upgrade failure due to unknown reason."]
pub const E_DjiUpgradeEndState_DJI_UPGRADE_END_STATE_UNKNOWN_ERROR: E_DjiUpgradeEndState = 2;
pub type E_DjiUpgradeEndState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeOngoingInfo {
    #[doc = "< The upgrade progress, the range is 0 ~ 100."]
    pub upgradeProgress: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeRebootInfo {
    #[doc = "< The timeout value of rebooting device. unit: s"]
    pub rebootTimeout: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeEndInfo {
    #[doc = "< The upgrade end state"]
    pub upgradeEndState: E_DjiUpgradeEndState,
}
impl Default for T_DjiUpgradeEndInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeFtpFileTransferInfo {
    #[doc = "< FTP port used to transfer file, default is 21"]
    pub port: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeFileInfo {
    pub fileSize: u32,
    #[doc = " The size of file."]
    pub fileName: [::std::os::raw::c_char; 256usize],
}
impl Default for T_DjiUpgradeFileInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeDcftpFileTransferOpt {
    #[doc = " @brief Prototype of callback function used to start file transfer.\n @param fileInfo: the file info about the file to be transferred.\n @return Execution result."]
    pub start: ::std::option::Option<
        unsafe extern "C" fn(fileInfo: *const T_DjiUpgradeFileInfo) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to transfer file data.\n @details After start transfer, this callback function will be called several times to transfer file data sequentially.\n @param data: pointer to memory space used to store file data.\n @param dataLen: the data length of data.\n @return Execution result."]
    pub transfer: ::std::option::Option<
        unsafe extern "C" fn(data: *const u8, dataLen: u16) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to finish file transfer.\n @param md5: the md5 value of file, used to check the correctness of the file transfer .\n @return Execution result."]
    pub finish: ::std::option::Option<unsafe extern "C" fn(md5: *const u8) -> T_DjiReturnCode>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiFirmwareTransferInfo {
    #[doc = " The firmware transfer type for upgrade."]
    pub transferType: E_DjiFirmwareTransferType,
    #[doc = " If transferType is DJI_FIRMWARE_TRANSFER_TYPE_FTP, need support ftpTransferInfo."]
    pub ftpTransferInfo: T_DjiUpgradeFtpFileTransferInfo,
    #[doc = " If transferType is DJI_FIRMWARE_TRANSFER_TYPE_DCFTP, need support dcftpFileTransferOpt."]
    pub dcftpFileTransferOpt: T_DjiUpgradeDcftpFileTransferOpt,
}
impl Default for T_DjiFirmwareTransferInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiUpgradeState {
    #[doc = " The upgrade stage in upgrade process."]
    pub upgradeStage: E_DjiUpgradeStage,
    pub __bindgen_anon_1: T_DjiUpgradeState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DjiUpgradeState__bindgen_ty_1 {
    #[doc = " If upgradeStage is DJI_UPGRADE_STAGE_ONGOING, need support upgradeOngoingInfo."]
    pub upgradeOngoingInfo: T_DjiUpgradeOngoingInfo,
    #[doc = " If upgradeStage is DJI_UPGRADE_STAGE_DEVICE_REBOOT, need support upgradeRebootInfo."]
    pub upgradeRebootInfo: T_DjiUpgradeRebootInfo,
    #[doc = " If upgradeStage is DJI_UPGRADE_STAGE_END, need support upgradeEndInfo."]
    pub upgradeEndInfo: T_DjiUpgradeEndInfo,
}
impl Default for T_DjiUpgradeState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DjiUpgradeState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeConfig {
    #[doc = "< The current firmware version of payload."]
    pub currentFirmwareVersion: T_DjiFirmwareVersion,
    #[doc = "< The firmware transfer info of payload."]
    pub firmwareTransferInfo: T_DjiFirmwareTransferInfo,
}
impl Default for T_DjiUpgradeConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiUpgradeHandler {
    #[doc = " @brief Prototype of callback function used to enter upgrade mode.\n @param waitTime: the wait time for enter upgrade mode. The terminal APP will wait these time before do other\n upgrade actions. You can use this time to prepare for firmware upgrade in other task, such as clean firmware\n store area. unit: s\n @return Execution result."]
    pub EnterUpgradeMode:
        ::std::option::Option<unsafe extern "C" fn(waitTime: *mut u16) -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to check transferred firmware.\n @details You can verify signature and decrypt firmware in this callback function.\n @return Execution result."]
    pub CheckFirmware: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to start firmware upgrade.\n @note After start upgrade, the upgrade stage need change to ::DJI_UPGRADE_STAGE_ONGOING\n @return Execution result."]
    pub StartUpgrade: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    #[doc = " @brief Prototype of callback function used to finish firmware upgrade.\n @note After call finish upgrade, the upgrade stage need change from ::DJI_UPGRADE_STAGE_END to ::DJI_UPGRADE_STAGE_IDLE\n @return Execution result."]
    pub FinishUpgrade: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
}
extern "C" {
    #[doc = " @brief Initialise upgrade module, and user should call this function before using upgrade features.\n @param upgradeConfig: upgrade init configuration.\n @return Execution result."]
    pub fn DjiUpgrade_Init(upgradeConfig: *const T_DjiUpgradeConfig) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Enable local upgrade mode.\n @details After enable local upgrade mode, DJI Assistant 2 will display payload upgrade interface. Users can choose\n firmware file to upgrade payload.\n @return Execution result."]
    pub fn DjiUpgrade_EnableLocalUpgrade() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for upgrade process.\n @param upgradeHandler: pointer to structure of handler functions for upgrade process.\n @return Execution result."]
    pub fn DjiUpgrade_RegHandler(upgradeHandler: *const T_DjiUpgradeHandler) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Push upgrade state to terminal app.\n @param upgradeState: upgrade state in upgrade process.\n @note When start upgrade, you need push upgrade state until finish upgrade. The upgrade state push logic is :\n 1. StartUpgrade callback called;\n 2. The upgrade stage change to :: DJI_UPGRADE_STAGE_ONGOING. Push upgrade state upgradeOngoingInfo when upgradeOngoingInfo changed;\n 3. After upgrade ongoing, change upgrade stage to DJI_UPGRADE_STAGE_DEVICE_REBOOT and push upgrade state upgradeRebootInfo;\n 4. Device reboot;\n 4. After device reboot, change upgrade stage to DJI_UPGRADE_STAGE_END and continuous push upgrade state upgradeEndInfo (recommended 1Hz);\n 5. FinishUpgrade Callback called, stop push upgrade state. The upgrade process finished.\n @return Execution result."]
    pub fn DjiUpgrade_PushUpgradeState(upgradeState: *const T_DjiUpgradeState) -> T_DjiReturnCode;
}
#[doc = " @brief Type define dji_f32_t as T_DjiWaypointV2GlobalCruiseSpeed.\n @details Type used for global cruise speed of waypoint mission, unit: m/s."]
pub type T_DjiWaypointV2GlobalCruiseSpeed = dji_f32_t;
#[doc = "  No further action will be taken.\n  The aircraft can be controlled by the remote controller."]
pub const E_DJIWaypointV2MissionFinishedAction_DJI_WAYPOINT_V2_FINISHED_NO_ACTION:
    E_DJIWaypointV2MissionFinishedAction = 0;
#[doc = "  Goes home when the mission is finished. The aircraft will\n  land directly if it is within 20 meters away from the home point."]
pub const E_DJIWaypointV2MissionFinishedAction_DJI_WAYPOINT_V2_FINISHED_GO_HOME:
    E_DJIWaypointV2MissionFinishedAction = 1;
#[doc = "  The aircraft will land automatically at the last waypoint."]
pub const E_DJIWaypointV2MissionFinishedAction_DJI_WAYPOINT_V2_FINISHED_AUTO_LANDING:
    E_DJIWaypointV2MissionFinishedAction = 2;
#[doc = "  The aircraft will go back to the first waypoint and hover."]
pub const E_DJIWaypointV2MissionFinishedAction_DJI_WAYPOINT_V2_FINISHED_GO_TO_FIRST_WAYPOINT:
    E_DJIWaypointV2MissionFinishedAction = 3;
#[doc = "  When the aircraft reaches its final waypoint, it will hover without ending the\n  mission. The joystick  can still be used to pull the aircraft back along its\n  previous waypoints. The only way this mission  can end is if stopMission is\n  called."]
pub const E_DJIWaypointV2MissionFinishedAction_DJI_WAYPOINT_V2_FINISHED_CONTINUE_UNTIL_STOP:
    E_DJIWaypointV2MissionFinishedAction = 4;
#[doc = "  Actions will be taken when the waypoint mission is finished."]
pub type E_DJIWaypointV2MissionFinishedAction = ::std::os::raw::c_uint;
#[doc = " Stops current mission when the remote controller signal(RC) is lost.\n And execute rc lost action which is choosed by users on APP.\n note:the option can be invalid only if you didn't obtain joystick authority\n (DjiFlightController_ObtainJoystickCtrlAuthority).Or it will continue executing\n the mission"]
pub const E_DJIWaypointV2MissionActionWhenRcLost_DJI_WAYPOINT_V2_MISSION_STOP_WAYPOINT_V2_AND_EXECUTE_RC_LOST_ACTION : E_DJIWaypointV2MissionActionWhenRcLost = 0 ;
#[doc = "  Continue executing the mission when the remote controller signal(RC) is lost.."]
pub const E_DJIWaypointV2MissionActionWhenRcLost_DJI_WAYPOINT_V2_MISSION_KEEP_EXECUTE_WAYPOINT_V2 : E_DJIWaypointV2MissionActionWhenRcLost = 1 ;
pub type E_DJIWaypointV2MissionActionWhenRcLost = ::std::os::raw::c_uint;
#[doc = "  Go to the waypoint safely. The aircraft will rise to the same altitude of the\n  waypoint if the current  altitude is lower then the waypoint altitude. It then\n  goes to the waypoint coordinate from the current  altitude, and proceeds to the\n  altitude of the waypoint."]
pub const E_DJIWaypointV2MissionGotoFirstWaypointMode_DJI_WAYPOINT_V2_MISSION_GO_TO_FIRST_WAYPOINT_MODE_SAFELY : E_DJIWaypointV2MissionGotoFirstWaypointMode = 0 ;
#[doc = "  Go to the waypoint from the current aircraft point to the waypoint directly."]
pub const E_DJIWaypointV2MissionGotoFirstWaypointMode_DJI_WAYPOINT_V2_MISSION_GO_TO_FIRST_WAYPOINT_MODE_POINT_TO_POINT : E_DJIWaypointV2MissionGotoFirstWaypointMode = 1 ;
pub type E_DJIWaypointV2MissionGotoFirstWaypointMode = ::std::os::raw::c_uint;
#[doc = "  In the mission, the aircraft will go to the waypoint along a curve and fly past the waypoint."]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_GO_TO_POINT_ALONG_CURVE:
    E_DJIWaypointV2FlightPathMode = 0;
#[doc = "  In the mission, the aircraft will go to the waypoint along a curve and stop at the waypoint."]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_GO_TO_POINT_ALONG_CURVE_AND_STOP : E_DJIWaypointV2FlightPathMode = 1 ;
#[doc = "  In the mission, the aircraft will go to the waypoint along a straight line and stop at the waypoint."]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_GO_TO_POINT_IN_STRAIGHT_AND_STOP : E_DJIWaypointV2FlightPathMode = 2 ;
#[doc = "  In the mission, the aircraft will fly from the previous waypoint to the next waypoint along a smooth curve without stopping at this waypoint.\n  the next in a curved motion,  adhering to the ``DJIWaypointV2_dampingDistance``, which is\n  set in ``DJIWaypointV2``."]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_COORDINATE_TURN:
    E_DJIWaypointV2FlightPathMode = 3;
#[doc = "  In the mission, the aircraft will go to the first waypoint along a straight line.\n  This is only valid for the first waypoint."]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_GO_TO_FIRST_POINT_ALONG_STRAIGHT_LINE : E_DJIWaypointV2FlightPathMode = 4 ;
#[doc = "  Straight exit the Last waypoint, Only valid for last waypoint."]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_STRAIGHT_OUT:
    E_DJIWaypointV2FlightPathMode = 5;
#[doc = "  Unknown"]
pub const E_DJIWaypointV2FlightPathMode_DJI_WAYPOINT_V2_FLIGHT_PATH_MODE_UNKNOWN:
    E_DJIWaypointV2FlightPathMode = 255;
#[doc = "  Waypoint flight path mode."]
pub type E_DJIWaypointV2FlightPathMode = ::std::os::raw::c_uint;
#[doc = "  Aircraft's heading will always be in the direction of flight."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_MODE_AUTO: E_DJIWaypointV2HeadingMode =
    0;
#[doc = " Aircraft's heading will be set to the heading when reaching the first waypoint.\n Before reaching the first waypoint, the aircraft's heading can be controlled by\n the remote controller. When the aircraft reaches the first waypoint, its\n heading will be fixed."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_FIXED: E_DJIWaypointV2HeadingMode = 1;
#[doc = "  The aircraft's heading in the mission can be controlled by the remote controller."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_MANUAL: E_DJIWaypointV2HeadingMode = 2;
#[doc = " In the mission, the aircraft's heading will change dynamically and adapt to the heading set at the next waypoint.\n See ``DJIWaypointV2_heading`` to preset the heading."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_WAYPOINT_CUSTOM:
    E_DJIWaypointV2HeadingMode = 3;
#[doc = "  Aircraft's heading will always toward point of interest.\n  using ``DJIWaypointV2_pointOfInterest`` setting point of interest coordiate and ``DJIWaypointV2_pointOfInterestAltitude``\n  setting point of interset altitute."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_TOWARDS_POINT_OF_INTEREST:
    E_DJIWaypointV2HeadingMode = 4;
#[doc = "  The aircraft's heading rotate simultaneously with its gimbal's yaw."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_GIMBAL_YAW_FOLLOW:
    E_DJIWaypointV2HeadingMode = 5;
#[doc = "  Unknown."]
pub const E_DJIWaypointV2HeadingMode_DJI_WAYPOINT_V2_HEADING_UNKNOWN: E_DJIWaypointV2HeadingMode =
    255;
#[doc = "  Represents current aircraft's heading mode on current waypoint."]
pub type E_DJIWaypointV2HeadingMode = ::std::os::raw::c_uint;
#[doc = "  The aircraft's heading rotates clockwise."]
pub const E_DJIWaypointV2TurnMode_DJI_WAYPOINT_V2_TURN_MODE_CLOCK_WISE: E_DJIWaypointV2TurnMode = 0;
#[doc = "  The aircraft's heading rotates counterclockwise."]
pub const E_DJIWaypointV2TurnMode_DJI_WAYPOINT_V2_TURN_MODE_COUNTER_CLOCK_WISE:
    E_DJIWaypointV2TurnMode = 1;
#[doc = "  Changes the heading of the aircraft by rotating the aircraft anti-clockwise."]
pub const E_DJIWaypointV2TurnMode_DJI_WAYPOINT_V2_TURN_MODE_UNKNOWN: E_DJIWaypointV2TurnMode = 255;
#[doc = "  The direction when the aircraft changes its heading to adapt to the heading at the waypoint."]
pub type E_DJIWaypointV2TurnMode = ::std::os::raw::c_uint;
#[doc = "  Waypoint mission state is ground station not start."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_GROUND_STATION_NOT_START:
    E_DJIWaypointV2MissionState = 0;
#[doc = "  Waypoint mission state is mission prepared."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_MISSION_PREPARED:
    E_DJIWaypointV2MissionState = 1;
#[doc = "  Waypoint mission state is enter mission."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_ENTER_MISSION:
    E_DJIWaypointV2MissionState = 2;
#[doc = "  Waypoint mission state is execute flying route mission."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_EXECUTING:
    E_DJIWaypointV2MissionState = 3;
#[doc = "  Waypoint mission state is pause state."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_PAUSED:
    E_DJIWaypointV2MissionState = 4;
#[doc = "  Waypoint mission state is enter mission after ending pause."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_ENTER_MISSION_AFTER_ENDING_PAUSE : E_DJIWaypointV2MissionState = 5 ;
#[doc = "  Waypoint mission state is exit mission."]
pub const E_DJIWaypointV2MissionState_DJI_WAYPOINT_V2_MISSION_STATE_EXIT_MISSION:
    E_DJIWaypointV2MissionState = 6;
#[doc = "  All the possible state of ``WaypointV2MissionOperator``."]
pub type E_DJIWaypointV2MissionState = ::std::os::raw::c_uint;
#[doc = " waypoint position relative to WayPointV2InitSettings's reference point\n unit: m"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiWaypointV2RelativePosition {
    pub positionX: dji_f32_t,
    #[doc = " X distance to reference point, North is positive"]
    pub positionY: dji_f32_t,
    #[doc = " Y distance to reference point, East is positive"]
    pub positionZ: dji_f32_t,
}
#[doc = "  Represents current waypoint's speed config."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV2Config {
    #[doc = " 0: set local waypoint's cruise speed,\n  1: unset local waypoint's cruise speed"]
    pub useLocalCruiseVel: u16,
    #[doc = " 0: set local waypoint's max speed,\n  1: unset local waypoint's max speed"]
    pub useLocalMaxVel: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiWaypointV2 {
    #[doc = " waypoint position relative to WayPointV2InitSettings's reference point\n unit: m"]
    pub longitude: dji_f64_t,
    pub latitude: dji_f64_t,
    pub relativeHeight: dji_f32_t,
    #[doc = "  Waypoint flight path mode."]
    pub waypointType: E_DJIWaypointV2FlightPathMode,
    #[doc = "  Represents current aircraft's heading mode on current waypoint."]
    pub headingMode: E_DJIWaypointV2HeadingMode,
    #[doc = "  Represents current waypoint's speed config."]
    pub config: T_DjiWaypointV2Config,
    pub dampingDistance: u16,
    #[doc = "  The heading to which the aircraft will rotate by the time it reaches the\n  waypoint. The aircraft heading  will gradually change between two waypoints with\n  different headings if the waypoint  mission's `headingMode` is set  to\n  `DJIWaypointV2_DJIWaypointV2HeadingMode_WaypointCustom`. A heading has a range of\n  [-180, 180] degrees, where 0 represents True North."]
    pub heading: dji_f32_t,
    #[doc = "  Determines whether the aircraft will turn clockwise or anticlockwise when\n  changing its heading."]
    pub turnMode: E_DJIWaypointV2TurnMode,
    #[doc = "  Property is used when ``DJIWaypointV2_headingMode`` is\n  ``DJIWaypointV2_DJIWaypointV2HeadingMode_TowardPointOfInterest``.\n  Aircraft will always be heading to point while executing mission. Default is\n  \"kCLLocationCoordinate2DInvalid\"."]
    pub pointOfInterest: T_DjiWaypointV2RelativePosition,
    #[doc = "  While the aircraft is travelling between waypoints, you can offset its speed by\n  using the throttle joystick on the remote controller. \"maxFlightSpeed\" is this\n  offset when the joystick is pushed to maximum deflection. For example, If\n  maxFlightSpeed is 10 m/s, then pushing the throttle joystick all the way up will\n  add 10 m/s to the aircraft speed, while pushing down will subtract 10 m/s from\n  the aircraft speed. If the remote controller stick is not at maximum deflection,\n  then the offset speed will be interpolated between \"[0, maxFlightSpeed]\"\" with a\n  resolution of 1000 steps. If the offset speed is negative, then the aircraft\n  will fly backwards to previous waypoints. When it reaches the first waypoint, it\n  will then hover in place until a positive speed is applied. \"maxFlightSpeed\" has\n  a range of [2,15] m/s.\n\n  unit: m/s"]
    pub maxFlightSpeed: dji_f32_t,
    #[doc = "  The base automatic speed of the aircraft as it moves between waypoints with\n  range [-15, 15] m/s. The aircraft's actual speed is a combination of the base\n  automatic speed, and the speed control given by the throttle joystick on the\n  remote controller. If \"autoFlightSpeed >0\": Actual speed is \"autoFlightSpeed\" +\n  Joystick Speed (with combined max of \"maxFlightSpeed\") If \"autoFlightSpeed =0\":\n  Actual speed is controlled only by the remote controller joystick. If\n  \"autoFlightSpeed <0\" and the aircraft is at the first waypoint, the aircraft\n  will hover in place until the speed is made positive by the remote controller\n  joystick. In flight controller firmware 3.2.10.0 or above, different speeds\n  between individual waypoints can also be set in waypoint objects which will\n  overwrite \"autoFlightSpeed\".\n\n  unit: m/s."]
    pub autoFlightSpeed: dji_f32_t,
}
impl Default for T_DjiWaypointV2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV2List {
    pub waypointV2: *mut T_DjiWaypointV2,
    pub waypointV2Num: u16,
}
impl Default for T_DjiWaypointV2List {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  The action will be triggered when action associated executes.\n  The parameters should be defined by ``DJIWaypointV2Action_E_DJIWaypointV2AssociateTriggerParam``."]
pub const E_DJIWaypointV2ActionTriggerType_DJI_WAYPOINT_V2_ACTION_TRIGGER_ACTION_ASSOCIATED:
    E_DJIWaypointV2ActionTriggerType = 2;
#[doc = "  The action will be triggered when the aircraft flies from one waypoint to the next.\n  The parameters should be defined by ``DJIWaypointV2Action_T_DJIWaypointV2TrajectoryTriggerParam``."]
pub const E_DJIWaypointV2ActionTriggerType_DJI_WAYPOINT_V2_ACTION_TRIGGER_TYPE_TRAJECTORY:
    E_DJIWaypointV2ActionTriggerType = 3;
#[doc = "  The action will be triggered when the aircraft flies between two waypoints\n  The parameters should be defined by ``DJIWaypointV2Action_T_DJIWaypointV2IntervalTriggerParam``."]
pub const E_DJIWaypointV2ActionTriggerType_DJI_WAYPOINT_V2_ACTION_TRIGGER_TYPE_INTERVAL:
    E_DJIWaypointV2ActionTriggerType = 4;
#[doc = "  The action will be trigger when the aircraft reach the waypoint point.\n  The parameters should be setting by ``DJIWaypointV2SampleReachPointTriggerParam``."]
pub const E_DJIWaypointV2ActionTriggerType_DJI_WAYPOINT_V2_ACTION_TRIGGER_TYPE_SAMPLE_REACH_POINT : E_DJIWaypointV2ActionTriggerType = 5 ;
#[doc = "  Unknown"]
pub const E_DJIWaypointV2ActionTriggerType_DJI_WAYPOINT_V2_ACTION_TRIGGER_TYPE_UNKNOWN:
    E_DJIWaypointV2ActionTriggerType = 255;
#[doc = "  Possible types of action trigger."]
pub type E_DJIWaypointV2ActionTriggerType = ::std::os::raw::c_uint;
#[doc = "  The trigger starts simultaneously with the trigger that is associated."]
pub const E_DJIWaypointV2TriggerAssociatedTimingType_DJI_WAYPOINT_V2_TRIGGER_ASSOCIATED_TIMING_TYPE_SIMULTANEOUSLY : E_DJIWaypointV2TriggerAssociatedTimingType = 1 ;
#[doc = "  The trigger starts after the trigger associated has finished."]
pub const E_DJIWaypointV2TriggerAssociatedTimingType_DJI_WAYPOINT_V2_TRIGGER_ASSOCIATED_TIMING_TYPE_AFTER_FINISHED : E_DJIWaypointV2TriggerAssociatedTimingType = 2 ;
#[doc = "  Unkown timing type."]
pub const E_DJIWaypointV2TriggerAssociatedTimingType_DJI_WAYPOINT_V2_TRIGGER_ASSOCIATED_TIMING_TYPE_UNKNOWN : E_DJIWaypointV2TriggerAssociatedTimingType = 255 ;
#[doc = "  The type of ``DJIWaypointV2Action_E_DJIWaypointV2AssociateTriggerParam``,\n  Determines the time to execute the trigger associated with another one."]
pub type E_DJIWaypointV2TriggerAssociatedTimingType = ::std::os::raw::c_uint;
#[doc = "  The action will be repeated after a particular period of time."]
pub const E_DJIWaypointV2ActionIntervalType_DJI_WAYPOINT_V2_ACTION_INTERVAL_TYPE_TIME:
    E_DJIWaypointV2ActionIntervalType = 1;
#[doc = "  The action will be repeated after a particular distance."]
pub const E_DJIWaypointV2ActionIntervalType_DJI_WAYPOINT_V2_ACTION_INTERVAL_TYPE_DISTANCE:
    E_DJIWaypointV2ActionIntervalType = 2;
#[doc = "  Unknown action trigger type."]
pub const E_DJIWaypointV2ActionIntervalType_DJI_WAYPOINT_V2_ACTION_INTERVAL_TYPE_UNKNOWN:
    E_DJIWaypointV2ActionIntervalType = 255;
#[doc = "  The type of ``DJIWaypointV2Action_DJIWaypointV2IntervalTriggerParam``,\n  Determines the interval type of how action repeats."]
pub type E_DJIWaypointV2ActionIntervalType = ::std::os::raw::c_uint;
#[doc = "  The action will be executed by the camera.\n  The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``."]
pub const E_DJIWaypointV2ActionActuatorType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_TYPE_CAMERA:
    E_DJIWaypointV2ActionActuatorType = 1;
#[doc = "  The action will be executed by the gimbal.\n  The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2GimbalActuatorParam``."]
pub const E_DJIWaypointV2ActionActuatorType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_TYPE_GIMBAL:
    E_DJIWaypointV2ActionActuatorType = 2;
#[doc = "  The action will executes by control aircraft.\n  The parameters should be setting by ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``."]
pub const E_DJIWaypointV2ActionActuatorType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_TYPE_AIRCRAFT_CONTROL : E_DJIWaypointV2ActionActuatorType = 4 ;
#[doc = "  Unknown actuator type."]
pub const E_DJIWaypointV2ActionActuatorType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_TYPE_UNKNOWN:
    E_DJIWaypointV2ActionActuatorType = 255;
#[doc = "  Possible types of action actuator."]
pub type E_DJIWaypointV2ActionActuatorType = ::std::os::raw::c_uint;
#[doc = "  Starts to shoot a photo."]
pub const E_DJIWaypointV2ActionActuatorCameraOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_CAMERA_OPERATION_TYPE_TAKE_PHOTO : E_DJIWaypointV2ActionActuatorCameraOperationType = 1 ;
#[doc = "  Starts to record a video."]
pub const E_DJIWaypointV2ActionActuatorCameraOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_CAMERA_OPERATION_TYPE_START_RECORD_VIDEO : E_DJIWaypointV2ActionActuatorCameraOperationType = 2 ;
#[doc = "  Stops to record a video."]
pub const E_DJIWaypointV2ActionActuatorCameraOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_CAMERA_OPERATION_TYPE_STOP_RECORD_VIDEO : E_DJIWaypointV2ActionActuatorCameraOperationType = 3 ;
#[doc = "  Starts focus."]
pub const E_DJIWaypointV2ActionActuatorCameraOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_CAMERA_OPERATION_TYPE_FOCUS : E_DJIWaypointV2ActionActuatorCameraOperationType = 4 ;
#[doc = "  Starts focal lenth. Only support those support flocal lenth cameras."]
pub const E_DJIWaypointV2ActionActuatorCameraOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_CAMERA_OPERATION_TYPE_FOCUL_LENGTH : E_DJIWaypointV2ActionActuatorCameraOperationType = 5 ;
#[doc = "  Unknown."]
pub const E_DJIWaypointV2ActionActuatorCameraOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_CAMERA_OPERATION_TYPE_UNKNOWN : E_DJIWaypointV2ActionActuatorCameraOperationType = 255 ;
#[doc = "  Possible types of camera actuator operation."]
pub type E_DJIWaypointV2ActionActuatorCameraOperationType = ::std::os::raw::c_uint;
#[doc = "  Rotates the gimbal. Only valid when the trigger type is\n  ``DJIWaypointV2MissionV2_DJIWaypointV2TriggerAssociatedTimingType_ReachPoint``."]
pub const E_DJIWaypointV2ActionActuatorGimbalOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_GIMBAL_OPERATION_TYPE_ROTATE_GIMBAL : E_DJIWaypointV2ActionActuatorGimbalOperationType = 1 ;
#[doc = "  Unknown"]
pub const E_DJIWaypointV2ActionActuatorGimbalOperationType_DJI_WAYPOINT_V2_ACTION_ACTUATOR_GIMBAL_OPERATION_TYPE_UNKNOWN : E_DJIWaypointV2ActionActuatorGimbalOperationType = 255 ;
#[doc = "  The type of gimbal actuator operation."]
pub type E_DJIWaypointV2ActionActuatorGimbalOperationType = ::std::os::raw::c_uint;
#[doc = " Get the remain memory  ack data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV2GetRemainMemory {
    pub totalMemory: u16,
    pub remainMemory: u16,
}
#[doc = " Get the mission's start and stop index ack data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV2GetWaypointStartEndIndex {
    pub result: u32,
    pub startIndex: u16,
    pub endIndex: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2SampleReachPointTriggerParam {
    #[doc = "  It determines the index of the waypoint at which the action will be\n triggered."]
    pub waypointIndex: u16,
    pub terminateNum: u16,
}
#[doc = "  This class defines\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionTriggerType_ActionAssociated``."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2AssociateTriggerParam {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "  Waiting time in seconds after ActionTrigger starts."]
    pub waitingTime: u8,
    #[doc = "  Associated action ID."]
    pub actionIdAssociated: u16,
}
impl T_DJIWaypointV2AssociateTriggerParam {
    #[inline]
    pub fn actionAssociatedType(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_actionAssociatedType(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn waitTimeUint(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_waitTimeUint(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        actionAssociatedType: u8,
        waitTimeUint: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let actionAssociatedType: u8 = unsafe { ::std::mem::transmute(actionAssociatedType) };
            actionAssociatedType as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let waitTimeUint: u8 = unsafe { ::std::mem::transmute(waitTimeUint) };
            waitTimeUint as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  This class represents a trajectory trigger action when should be trigger."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2TrajectoryTriggerParam {
    #[doc = "  It determines the index of the waypoint at which the trigger starts."]
    pub startIndex: u16,
    #[doc = "  It determines the waypoint when the trigger stops."]
    pub endIndex: u16,
}
#[doc = "  This class defines\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionTriggerType_Trajectory``."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2IntervalTriggerParam {
    #[doc = "  It determines the index of the waypoint at which the trigger starts."]
    pub startIndex: u16,
    #[doc = "  If the\n ``DJIWaypointV2Action_T_DJIWaypointV2IntervalTriggerParam_actionIntervalType``\n is ``DJIWaypointV2MissionV2_DJIWaypointV2TriggerAssociatedTimingType_Time``\n  The time interval in 0.01 seconds when two action are executed as the aircraft\n moves\n  from the current waypoint to the next waypoint.\n  If the\n ``DJIWaypointV2Action_T_DJIWaypointV2IntervalTriggerParam_actionIntervalType``\n is\n ``DJIWaypointV2MissionV2_DJIWaypointV2TriggerAssociatedTimingType_Distance``\n  The distance interval in 0.01 meters when two action are executed as the\n aircraft\n moves\n  from the current waypoint to the next waypoint."]
    pub interval: u16,
    #[doc = "  The type of interval trigger.\n  See ``E_DJIWaypointV2ActionIntervalType``."]
    pub actionIntervalType: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DJIWaypointV2Trigger {
    pub actionTriggerType: u8,
    pub __bindgen_anon_1: T_DJIWaypointV2Trigger__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DJIWaypointV2Trigger__bindgen_ty_1 {
    pub sampleReachPointTriggerParam: T_DJIWaypointV2SampleReachPointTriggerParam,
    pub associateTriggerParam: T_DJIWaypointV2AssociateTriggerParam,
    pub trajectoryTriggerParam: T_DJIWaypointV2TrajectoryTriggerParam,
    pub intervalTriggerParam: T_DJIWaypointV2IntervalTriggerParam,
}
impl Default for T_DJIWaypointV2Trigger__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DJIWaypointV2Trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Focus point parameter"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiWaypointV2CGPoint {
    #[doc = " x axis focus point value\n range: [0,1]"]
    pub x: dji_f32_t,
    #[doc = " y axis focus point value\n range: [0,1]"]
    pub y: dji_f32_t,
}
#[doc = "  This class defines a camera focus operation for\n ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DJIWaypointV2CameraFocusParam {
    #[doc = "  The lens focus target point. When the focus mode is auto, the target point\n  is the focal point. When the focus mode is manual, the target point is the\n zoom\n  out area if the focus assistant is enabled for the manual mode.\n  The range for x and y is from 0.0 to 1.0. The point [0.0, 0.0] represents\n the top-left angle of the screen."]
    pub focusTarget: T_DjiWaypointV2CGPoint,
    #[doc = " focus type:\n 0:point focus\n 1:rectangle focus"]
    pub regionType: u8,
    #[doc = " Normalized focus area width(0,1)"]
    pub width: dji_f32_t,
    #[doc = " Normalized focus area height(0,1)"]
    pub height: dji_f32_t,
    pub reserve: u32,
    #[doc = " [0,255]"]
    pub retryTimes: u8,
}
#[doc = "  This class defines a camera focal length operation for\n ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2CameraFocalLengthParam {
    #[doc = "  Focal length of zoom lens. Valid range is\n [``DJICamera_DJICameraOpticalZoomSpec_minFocalLength``,\n ``DJICamera_DJICameraOpticalZoomSpec_minFocalLength``]\n  and must be a multiple of\n ``DJICamera_DJICameraOpticalZoomSpec_focalLengthStep``.\n  Only support by those camera\n ``DJICamera_CameraSettings_isOpticalZoomSupported`` return ``TRUE``."]
    pub focalLength: u16,
    pub retryTimes: u8,
}
#[doc = "  This class defines the parameters for\n ``DJIWaypointV2Action_DJIWaypointV2Actuator``.\n  This determines how the camera will be performed when a waypoint mission is\n executing."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct T_DJIWaypointV2CameraActuatorParam {
    #[doc = "  The operation type of camera actuator.\n  See\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorCameraOperationType``."]
    pub operationType: u16,
    pub __bindgen_anon_1: T_DJIWaypointV2CameraActuatorParam__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DJIWaypointV2CameraActuatorParam__bindgen_ty_1 {
    #[doc = "  The parameters for camera focus operation. It is valid only when\n ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam_operationType``\n  is\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorCameraOperationType_Focus``"]
    pub focusParam: T_DJIWaypointV2CameraFocusParam,
    #[doc = "  The parameters for camera focus length operation. It is valid only when\n ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam_operationType``\n  is\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorCameraOperationType_FocalLength``"]
    pub zoomParam: T_DJIWaypointV2CameraFocalLengthParam,
}
impl Default for T_DJIWaypointV2CameraActuatorParam__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DJIWaypointV2CameraActuatorParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Gimbal rotation parameter"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIGimbalRotation {
    pub x: i16,
    #[doc = " gimbal roll angle,  unit: 0.1 deg,range:[-3600, 3600]"]
    pub y: i16,
    #[doc = " gimbal pitch angle, unit: 0.1 deg,range:[-3600, 3600]"]
    pub z: i16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub durationTime: u8,
}
impl T_DJIGimbalRotation {
    #[inline]
    pub fn ctrl_mode(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ctrl_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rollCmdIgnore(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rollCmdIgnore(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pitchCmdIgnore(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pitchCmdIgnore(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn yawCmdIgnore(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_yawCmdIgnore(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn absYawModeRef(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_absYawModeRef(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ctrl_mode: u8,
        rollCmdIgnore: u8,
        pitchCmdIgnore: u8,
        yawCmdIgnore: u8,
        absYawModeRef: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ctrl_mode: u8 = unsafe { ::std::mem::transmute(ctrl_mode) };
            ctrl_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rollCmdIgnore: u8 = unsafe { ::std::mem::transmute(rollCmdIgnore) };
            rollCmdIgnore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pitchCmdIgnore: u8 = unsafe { ::std::mem::transmute(pitchCmdIgnore) };
            pitchCmdIgnore as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let yawCmdIgnore: u8 = unsafe { ::std::mem::transmute(yawCmdIgnore) };
            yawCmdIgnore as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let absYawModeRef: u8 = unsafe { ::std::mem::transmute(absYawModeRef) };
            absYawModeRef as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  This class defines the parameters for\n ``DJIWaypointV2Action_DJIWaypointV2Actuator``. It determines how the\n  gimbal actuator will be performed when a waypoint mission is executed."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2GimbalActuatorParam {
    #[doc = "  The operation type of gimbal actuator.\n  See\n ``E_DJIWaypointV2ActionActuatorGimbalOperationType``."]
    pub operationType: u16,
    #[doc = "  The rotation of gimbal actuator."]
    pub rotation: T_DJIGimbalRotation,
}
#[doc = "  Rotates the aircraft's yaw."]
pub const E_DJIWaypointV2ActionActuatorAircraftControlOperationType_DJIWaypointV2ActionActuatorAircraftControlOperationTypeRotateYaw : E_DJIWaypointV2ActionActuatorAircraftControlOperationType = 1 ;
#[doc = "  Keeps the aircraft stop flying or start flying."]
pub const E_DJIWaypointV2ActionActuatorAircraftControlOperationType_DJIWaypointV2ActionActuatorAircraftControlOperationTypeFlyingControl : E_DJIWaypointV2ActionActuatorAircraftControlOperationType = 2 ;
#[doc = "  Unknown"]
pub const E_DJIWaypointV2ActionActuatorAircraftControlOperationType_DJIWaypointV2ActionActuatorAircraftControlOperationTypeUnknown : E_DJIWaypointV2ActionActuatorAircraftControlOperationType = 255 ;
#[doc = " Possible types of aircraft control actuator operation."]
pub type E_DJIWaypointV2ActionActuatorAircraftControlOperationType = ::std::os::raw::c_uint;
#[doc = "  This class defines how the aircraft rotates on the yaw axis."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DJIWaypointV2AircraftControlRotateHeadingParam {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "  Determines the direction how aircraft changes its heading."]
    pub yaw: dji_f32_t,
}
impl T_DJIWaypointV2AircraftControlRotateHeadingParam {
    #[inline]
    pub fn isRelative(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isRelative(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isRelative: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isRelative: u8 = unsafe { ::std::mem::transmute(isRelative) };
            isRelative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  This class defines if the aircraft starts or stops the flight."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2AircraftControlFlyingParam {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl T_DJIWaypointV2AircraftControlFlyingParam {
    #[inline]
    pub fn isStartFlying(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isStartFlying(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isStartFlying: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let isStartFlying: u8 = unsafe { ::std::mem::transmute(isStartFlying) };
            isStartFlying as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  This class defines the parameters for\n ``DJIWaypointV2Action_DJIWaypointV2Actuator``. It determines how the\n  aircraft control actuator will be performed when a waypoint mission is\n executed."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct T_DJIWaypointV2AircraftControlParam {
    #[doc = "  The operation type of aircraft control actuator.\n  See\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorAircraftControlOperationType``."]
    pub operationType: u16,
    pub __bindgen_anon_1: T_DJIWaypointV2AircraftControlParam__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DJIWaypointV2AircraftControlParam__bindgen_ty_1 {
    #[doc = "  The parameter for rotating the aircraft's heading. It's valid only when\n ``DJIWaypointV2Action_DJIWaypointV2AircraftControlParam_operationType``\n  is\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorAircraftControlOperationType_RotateYaw``"]
    pub yawRotatingParam: T_DJIWaypointV2AircraftControlRotateHeadingParam,
    #[doc = "  The parameters to control flying behavior.  It's valid only when\n ``DJIWaypointV2Action_DJIWaypointV2AircraftControlParam_operationType``\n  is\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorAircraftControlOperationType_FlyingControl``"]
    pub flyControlParam: T_DJIWaypointV2AircraftControlFlyingParam,
}
impl Default for T_DJIWaypointV2AircraftControlParam__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DJIWaypointV2AircraftControlParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  This class defines an actuator for ``DJIWaypointV2Action``. It determines\n how the\n  action is performed when a waypoint mission is executed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DJIWaypointV2Actuator {
    #[doc = "  The type of Actuator.see \"E_DJIWaypointV2ActionActuatorType\""]
    pub actuatorType: u8,
    #[doc = "  The index of actuator. It is valid when the diagnostics is related\n  to camera or gimbal and the connected product has multiple gimbals and\n cameras."]
    pub actuatorIndex: u8,
    pub __bindgen_anon_1: T_DJIWaypointV2Actuator__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DJIWaypointV2Actuator__bindgen_ty_1 {
    #[doc = "  The camera actuator param, It is valid only when the\n ``DJIWaypointV2Action_DJIWaypointV2Actuator_type``\n  is ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorType_Camera``."]
    pub cameraActuatorParam: T_DJIWaypointV2CameraActuatorParam,
    #[doc = "  Parameters for gimbal actuator. It is valid only when the\n ``DJIWaypointV2Action_DJIWaypointV2Actuator_type``\n  is ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorType_Gimbal``."]
    pub gimbalActuatorParam: T_DJIWaypointV2GimbalActuatorParam,
    #[doc = "  Parameters for aircraft control actuator. It is valid only when the\n ``DJIWaypointV2Action_DJIWaypointV2Actuator_type``\n  is\n ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorType_AircraftControl``."]
    pub aircraftControlActuatorParam: T_DJIWaypointV2AircraftControlParam,
}
impl Default for T_DJIWaypointV2Actuator__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DJIWaypointV2Actuator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  This class represents an action for ``DJIWaypointV2Mission``. It\n determines how\n  action is performed when a waypoint mission is executed."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct T_DJIWaypointV2Action {
    #[doc = "  The ID of Action."]
    pub actionId: u16,
    #[doc = "  The trigger of action."]
    pub trigger: T_DJIWaypointV2Trigger,
    #[doc = "  The actuator of action."]
    pub actuator: T_DJIWaypointV2Actuator,
}
impl Default for T_DJIWaypointV2Action {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Waypoint V2 Mission Initialization Settings Internal\n User have no need to use it"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_WayPointV2InitSettingsInternal {
    pub version: u16,
    pub reserved: u8,
    pub missionID: u32,
    pub missTotalLen: u16,
    pub waypointCount: u16,
    pub repeatTimes: u8,
    pub finishedAction: u8,
    pub maxFlightSpeed: u16,
    pub autoFlightSpeed: u16,
    pub startIndex: u16,
    pub actionWhenRcLost: u8,
    pub gotoFirstWaypointMode: u8,
    pub refLati: dji_f64_t,
    pub refLong: dji_f64_t,
    pub refAlti: dji_f32_t,
}
#[doc = " Mission's event data"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union U_DjiWaypointV2EventData {
    pub interruptReason: u8,
    #[doc = "event ID:0x02\n 0x00:Finish recover from pause;\n 0x10:Start recover from break;\n 0x11:Finish recover from break;\n 0x12:Fail recover from break."]
    pub recoverProcess: u8,
    #[doc = "event ID:0x03\n 0x00:finished successfully.\n 0x10:External user trigger ended successfully.\n 0x20:Request the route when motors is starting on the ground.\n 0x21:Auto takeoff time out.\n 0x22:Auto takeoff did not reach the predetermined altitude.\n 0x23:AUto takeoff abnormal.\n 0x24:Preempted by high priority tasks.\n 0x25:Unknown reason.\n 0x26:Route planning failure"]
    pub exitReason: u8,
    pub waypointIndex: u16,
    pub T_DjiWaypointV2MissionExecEvent: U_DjiWaypointV2EventData_T_DjiWaypointV2MissionExecEvent,
    pub avoidState: u8,
    pub T_DjiWaypointV2ActionExecEvent: U_DjiWaypointV2EventData_T_DjiWaypointV2ActionExecEvent,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct U_DjiWaypointV2EventData_T_DjiWaypointV2MissionExecEvent {
    pub currentMissionExecTimes: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl U_DjiWaypointV2EventData_T_DjiWaypointV2MissionExecEvent {
    #[inline]
    pub fn finishedAllMissExecTimes(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_finishedAllMissExecTimes(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        finishedAllMissExecTimes: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let finishedAllMissExecTimes: u8 =
                unsafe { ::std::mem::transmute(finishedAllMissExecTimes) };
            finishedAllMissExecTimes as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct U_DjiWaypointV2EventData_T_DjiWaypointV2ActionExecEvent {
    pub actionId: u16,
    #[doc = " 0x00: device id not mounted or identified\n 0x01: is free\n 0x02: is running\n 0x03: be paused"]
    pub preActuatorState: u8,
    #[doc = " 0x00: device id not mounted or identified\n 0x01: is free\n 0x02: is running\n 0x03: be paused"]
    pub curActuatorState: u8,
    #[doc = " error code"]
    pub result: u32,
}
impl Default for U_DjiWaypointV2EventData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Mission's event push ack data"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct T_DjiWaypointV2MissionEventPush {
    #[doc = " 0x01: mission interrupt event\n 0x02: mission resume  event\n 0x03: mission stop event\n 0x10: mission arrival event\n 0x11: route finished event\n 0x12: avoid obstacle event\n 0x30: action switch event"]
    pub event: u8,
    pub FCTimestamp: u32,
    pub data: U_DjiWaypointV2EventData,
}
impl Default for T_DjiWaypointV2MissionEventPush {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Mission's state push data"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV2MissionStatePush {
    pub curWaypointIndex: u16,
    #[doc = "< enum-type: E_DJIWaypointV2MissionState."]
    pub state: u8,
    #[doc = "< Uint:0.01m/s."]
    pub velocity: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DJIWaypointV2ActionList {
    pub actions: *mut T_DJIWaypointV2Action,
    pub actionNum: u16,
}
impl Default for T_DJIWaypointV2ActionList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Waypoint V2 Mission Initialization settings\n @details This is one of the few structs in the OSDK codebase that\n is used in both a sending and a receiving API."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct T_DjiWayPointV2MissionSettings {
    #[doc = "  The Mission ID. Use to distinguish different mission"]
    pub missionID: u32,
    #[doc = "  Mission execution can be repeated more than once. A value of 0 means the mission\n  only executes once, and does not repeat. A value of 1 means the mission will\n  execute a total of two times."]
    pub repeatTimes: u8,
    #[doc = "  Action the aircraft will take when the waypoint mission is complete."]
    pub finishedAction: E_DJIWaypointV2MissionFinishedAction,
    #[doc = "  While the aircraft is travelling between waypoints, you can offset its speed by\n  using the throttle joystick  on the remote controller. `maxFlightSpeed` is this\n  offset when the joystick is pushed  to maximum deflection. For example, If\n  maxFlightSpeed is 10 m/s, then pushing the throttle joystick all the  way up\n  will add 10 m/s to the aircraft speed, while pushing down will subtract 10 m/s\n  from the aircraft  speed. If the remote controller stick is not at maximum\n  deflection, then the offset speed will be  interpolated between [0,\n  `maxFlightSpeed`] with a resolution of 1000 steps. If the  offset speed is\n  negative, then the aircraft will fly backwards to previous waypoints. When it\n  reaches the  first waypoint, it will then hover in place until a positive speed\n  is  applied. `maxFlightSpeed` has a range of [2,15] m/s.\n\n  unit: m/s"]
    pub maxFlightSpeed: dji_f32_t,
    #[doc = "  The base automatic speed of the aircraft as it moves between waypoints with\n  range [-15, 15] m/s. The  aircraft's actual speed is a combination of the base\n  automatic speed, and the speed control given by  the throttle joystick on the\n  remote controller. If `autoFlightSpeed` >0: Actual  speed is `autoFlightSpeed` +\n  Joystick Speed (with combined max  of `maxFlightSpeed`) If `autoFlightSpeed` =0:\n  Actual speed is  controlled only by the remote controller joystick. If\n  `autoFlightSpeed` <0 and the  aircraft is at the first waypoint, the aircraft\n  will hover in place until the speed is made positive by  the remote controller\n  joystick.\n\n  unit: m/s"]
    pub autoFlightSpeed: dji_f32_t,
    #[doc = "  Determines action when connection between the  aircraft\n  and remote controller is lost.\n"]
    pub actionWhenRcLost: E_DJIWaypointV2MissionActionWhenRcLost,
    #[doc = "  Defines how the aircraft will go to the first waypoint from its current\n  position. Default  is ``DJIWaypointV2MissionV2_DJIWaypointV2MissionGotoWaypointMode_Safely``."]
    pub gotoFirstWaypointMode: E_DJIWaypointV2MissionGotoFirstWaypointMode,
    pub mission: *mut T_DjiWaypointV2,
    #[doc = "  The Mission waypoint total number could not exceed 65535"]
    pub missTotalLen: u16,
    pub actionList: T_DJIWaypointV2ActionList,
}
impl Default for T_DjiWayPointV2MissionSettings {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WaypointV2EventCbFunc = ::std::option::Option<
    unsafe extern "C" fn(eventData: T_DjiWaypointV2MissionEventPush) -> T_DjiReturnCode,
>;
pub type WaypointV2StateCbFunc = ::std::option::Option<
    unsafe extern "C" fn(stateData: T_DjiWaypointV2MissionStatePush) -> T_DjiReturnCode,
>;
extern "C" {
    #[doc = " @brief Initialise waypoint v2 module, and user should call this function\n before using waypoint v2 features.\n @return Execution result."]
    pub fn DjiWaypointV2_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialise waypoint v2 module.\n @return Execution result."]
    pub fn DjiWaypointV2_Deinit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Init waypoint v2 mission settings\n @param info: see reference of T_DjiWayPointV2MissionSettings.\n @return Execution result."]
    pub fn DjiWaypointV2_UploadMission(
        info: *const T_DjiWayPointV2MissionSettings,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Start execute waypoint v2 mission\n @return Execution result."]
    pub fn DjiWaypointV2_Start() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Stop execute waypoint v2 mission\n @return Execution result."]
    pub fn DjiWaypointV2_Stop() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Pause execute waypoint v2 mission\n @return Execution result."]
    pub fn DjiWaypointV2_Pause() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Resume execute waypoint v2 mission\n @return Execution result."]
    pub fn DjiWaypointV2_Resume() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get the global cruise speed setting from flight controller\n @param cruiseSpeed: see references of T_DjiWaypointV2GlobalCruiseSpeed.\n @return Execution result."]
    pub fn DjiWaypointV2_GetGlobalCruiseSpeed(
        cruiseSpeed: *mut T_DjiWaypointV2GlobalCruiseSpeed,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set the global cruise speed setting to flight controller\n @param cruiseSpeed: see references of T_DjiWaypointV2GlobalCruiseSpeed.\n @return Execution result."]
    pub fn DjiWaypointV2_SetGlobalCruiseSpeed(
        cruiseSpeed: T_DjiWaypointV2GlobalCruiseSpeed,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Subscribe to waypointV2 event with a callback function.\n @note There will be data when the event is triggered.\n @param callback: see references of WaypointV2EventCbFunc.\n @return Execution result."]
    pub fn DjiWaypointV2_RegisterMissionEventCallback(
        callback: WaypointV2EventCbFunc,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Subscribe to waypointV2 mission state with a callback function.\n @note Data is pushed with a frequency of 10Hz.\n @param callback: see references of WaypointV2StateCbFunc.\n @return Execution result."]
    pub fn DjiWaypointV2_RegisterMissionStateCallback(
        callback: WaypointV2StateCbFunc,
    ) -> T_DjiReturnCode;
}
#[doc = "< Waypoint v3 mission start action."]
pub const E_DjiWaypointV3Action_DJI_WAYPOINT_V3_ACTION_START: E_DjiWaypointV3Action = 0;
#[doc = "< Waypoint v3 mission stop action."]
pub const E_DjiWaypointV3Action_DJI_WAYPOINT_V3_ACTION_STOP: E_DjiWaypointV3Action = 1;
#[doc = "< Waypoint v3 mission pause action."]
pub const E_DjiWaypointV3Action_DJI_WAYPOINT_V3_ACTION_PAUSE: E_DjiWaypointV3Action = 2;
#[doc = "< Waypoint v3 mission resume action."]
pub const E_DjiWaypointV3Action_DJI_WAYPOINT_V3_ACTION_RESUME: E_DjiWaypointV3Action = 3;
#[doc = " @brief Waypoint v3 mission action."]
pub type E_DjiWaypointV3Action = ::std::os::raw::c_uint;
#[doc = "< Waypoint v3 mission in idle state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_IDLE:
    E_DjiWaypointV3MissionState = 0;
#[doc = "< Waypoint v3 mission in prepare state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_PREPARE:
    E_DjiWaypointV3MissionState = 16;
#[doc = "< Waypoint v3 mission in trans mission state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_TRANS_MISSION:
    E_DjiWaypointV3MissionState = 32;
#[doc = "< Waypoint v3 mission in mission state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_MISSION:
    E_DjiWaypointV3MissionState = 48;
#[doc = "< Waypoint v3 mission in break state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_BREAK:
    E_DjiWaypointV3MissionState = 64;
#[doc = "< Waypoint v3 mission in resume state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_RESUME:
    E_DjiWaypointV3MissionState = 80;
#[doc = "< Waypoint v3 mission in return first point state."]
pub const E_DjiWaypointV3MissionState_DJI_WAYPOINT_V3_MISSION_STATE_RETURN_FIRSTPOINT:
    E_DjiWaypointV3MissionState = 98;
#[doc = "  Waypoint v3 current mission state."]
pub type E_DjiWaypointV3MissionState = ::std::os::raw::c_uint;
#[doc = "< Waypoint v3 action in idle state."]
pub const E_DjiWaypointV3ActionState_DJI_WAYPOINT_V3_ACTION_STATE_IDLE: E_DjiWaypointV3ActionState =
    0;
#[doc = "< Waypoint v3 action in idle state."]
pub const E_DjiWaypointV3ActionState_DJI_WAYPOINT_V3_ACTION_STATE_RUNNING:
    E_DjiWaypointV3ActionState = 1;
#[doc = "< Waypoint v3 action in idle state."]
pub const E_DjiWaypointV3ActionState_DJI_WAYPOINT_V3_ACTION_STATE_FINISHED:
    E_DjiWaypointV3ActionState = 5;
#[doc = "  Waypoint v3 current action state."]
pub type E_DjiWaypointV3ActionState = ::std::os::raw::c_uint;
#[doc = "  Waypoint v3 mission state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV3MissionState {
    #[doc = "< Waypoint v3 current mission state, #E_DjiWaypointV3MissionState."]
    pub state: E_DjiWaypointV3MissionState,
    #[doc = "< Waypoint v3 current way line id."]
    pub wayLineId: u32,
    #[doc = "< Waypoint v3 current waypoint index."]
    pub currentWaypointIndex: u16,
}
impl Default for T_DjiWaypointV3MissionState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  Waypoint v3 action state."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWaypointV3ActionState {
    #[doc = "< Waypoint v3 current action state, #E_DjiWaypointV3ActionState."]
    pub state: E_DjiWaypointV3ActionState,
    #[doc = "< Waypoint v3 current way line id."]
    pub wayLineId: u32,
    #[doc = "< Waypoint v3 current waypoint index."]
    pub currentWaypointIndex: u16,
    #[doc = "< Waypoint v3 current action group index."]
    pub actionGroupId: u16,
    #[doc = "< Waypoint v3 current action index."]
    pub actionId: u16,
}
impl Default for T_DjiWaypointV3ActionState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Prototype of callback function used to receive the waypoint v3 mission state.\n @warning User can not execute blocking style operations or functions in callback function, because that will block\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param missionState: current waypoint v3 mission state.\n @return Execution result."]
pub type WaypointV3MissionStateCallback = ::std::option::Option<
    unsafe extern "C" fn(missionState: T_DjiWaypointV3MissionState) -> T_DjiReturnCode,
>;
#[doc = " @brief Prototype of callback function used to receive the waypoint v3 mission state.\n @warning User can not execute blocking style operations or functions in callback function, because that will block\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param missionState: current waypoint v3 mission state.\n @return Execution result."]
pub type WaypointV3ActionStateCallback = ::std::option::Option<
    unsafe extern "C" fn(missionState: T_DjiWaypointV3ActionState) -> T_DjiReturnCode,
>;
extern "C" {
    #[doc = " @brief Initialise waypoint v3 module, and user should call this function.\n before using waypoint v3 features.\n @return Execution result."]
    pub fn DjiWaypointV3_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialise waypoint v3 module.\n @return Execution result."]
    pub fn DjiWaypointV3_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Upload kmz file by raw data.\n @note The size of kmz file is very small, you can use this interface to upload quickly.\n @return Execution result."]
    pub fn DjiWaypointV3_UploadKmzFile(data: *const u8, dataLen: u32) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Execute the mission action.\n @note This action should be called after uploading the kmz file.\n @return Execution result."]
    pub fn DjiWaypointV3_Action(action: E_DjiWaypointV3Action) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the mission state callback for waypoint mission.\n @note If you want to monitor the state of waypoint mission, this interface should be called before uploading kmz\n file or executing this mission action.\n @return Execution result."]
    pub fn DjiWaypointV3_RegMissionStateCallback(
        callback: WaypointV3MissionStateCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the action state callback for waypoint mission.\n @note If you want to monitor the state of waypoint action, this interface should be called before uploading kmz\n file or executing this mission action.\n @return Execution result."]
    pub fn DjiWaypointV3_RegActionStateCallback(
        callback: WaypointV3ActionStateCallback,
    ) -> T_DjiReturnCode;
}
#[doc = "< button widget type"]
pub const E_DjiWidgetType_DJI_WIDGET_TYPE_BUTTON: E_DjiWidgetType = 1;
#[doc = "< switch widget type"]
pub const E_DjiWidgetType_DJI_WIDGET_TYPE_SWITCH: E_DjiWidgetType = 2;
#[doc = "< scale widget type"]
pub const E_DjiWidgetType_DJI_WIDGET_TYPE_SCALE: E_DjiWidgetType = 3;
#[doc = "< list widget type"]
pub const E_DjiWidgetType_DJI_WIDGET_TYPE_LIST: E_DjiWidgetType = 4;
#[doc = "< integer input box widget type"]
pub const E_DjiWidgetType_DJI_WIDGET_TYPE_INT_INPUT_BOX: E_DjiWidgetType = 5;
#[doc = " @brief Widget types."]
pub type E_DjiWidgetType = ::std::os::raw::c_uint;
#[doc = "< Button is pressed down"]
pub const E_DjiWidgetButtonState_DJI_WIDGET_BUTTON_STATE_PRESS_DOWN: E_DjiWidgetButtonState = 1;
#[doc = "< Button is released up"]
pub const E_DjiWidgetButtonState_DJI_WIDGET_BUTTON_STATE_RELEASE_UP: E_DjiWidgetButtonState = 0;
#[doc = " @brief Button widget state."]
pub type E_DjiWidgetButtonState = ::std::os::raw::c_uint;
#[doc = "< Switch is turned off"]
pub const E_DjiWidgetSwitchState_DJI_WIDGET_SWITCH_STATE_OFF: E_DjiWidgetSwitchState = 0;
#[doc = "< Switch is turned on"]
pub const E_DjiWidgetSwitchState_DJI_WIDGET_SWITCH_STATE_ON: E_DjiWidgetSwitchState = 1;
#[doc = " @brief Switch widget state."]
pub type E_DjiWidgetSwitchState = ::std::os::raw::c_uint;
pub const E_DjiWidgetSpeakerWorkMode_DJI_WIDGET_SPEAKER_WORK_MODE_TTS: E_DjiWidgetSpeakerWorkMode =
    0;
pub const E_DjiWidgetSpeakerWorkMode_DJI_WIDGET_SPEAKER_WORK_MODE_VOICE:
    E_DjiWidgetSpeakerWorkMode = 1;
#[doc = " @brief Switch widget speaker work mode."]
pub type E_DjiWidgetSpeakerWorkMode = ::std::os::raw::c_uint;
pub const E_DjiWidgetSpeakerPlayMode_DJI_WIDGET_SPEAKER_PLAY_MODE_SINGLE_PLAY:
    E_DjiWidgetSpeakerPlayMode = 0;
pub const E_DjiWidgetSpeakerPlayMode_DJI_WIDGET_SPEAKER_PLAY_MODE_LOOP_PLAYBACK:
    E_DjiWidgetSpeakerPlayMode = 1;
#[doc = " @brief Switch widget speaker play mode."]
pub type E_DjiWidgetSpeakerPlayMode = ::std::os::raw::c_uint;
pub const E_DjiWidgetSpeakerState_DJI_WIDGET_SPEAKER_STATE_IDEL: E_DjiWidgetSpeakerState = 0;
pub const E_DjiWidgetSpeakerState_DJI_WIDGET_SPEAKER_STATE_TRANSMITTING: E_DjiWidgetSpeakerState =
    1;
pub const E_DjiWidgetSpeakerState_DJI_WIDGET_SPEAKER_STATE_PLAYING: E_DjiWidgetSpeakerState = 2;
pub const E_DjiWidgetSpeakerState_DJI_WIDGET_SPEAKER_STATE_ERROR: E_DjiWidgetSpeakerState = 3;
pub const E_DjiWidgetSpeakerState_DJI_WIDGET_SPEAKER_STATE_IN_TTS_CONVERSION:
    E_DjiWidgetSpeakerState = 4;
#[doc = " @brief Switch widget speaker state."]
pub type E_DjiWidgetSpeakerState = ::std::os::raw::c_uint;
pub const E_DjiWidgetTransmitDataEvent_DJI_WIDGET_TRANSMIT_DATA_EVENT_START:
    E_DjiWidgetTransmitDataEvent = 0;
pub const E_DjiWidgetTransmitDataEvent_DJI_WIDGET_TRANSMIT_DATA_EVENT_TRANSMIT:
    E_DjiWidgetTransmitDataEvent = 1;
pub const E_DjiWidgetTransmitDataEvent_DJI_WIDGET_TRANSMIT_DATA_EVENT_FINISH:
    E_DjiWidgetTransmitDataEvent = 2;
pub const E_DjiWidgetTransmitDataEvent_DJI_WIDGET_TRANSMIT_DATA_EVENT_ABORT:
    E_DjiWidgetTransmitDataEvent = 3;
#[doc = " @brief Switch widget transmit data event."]
pub type E_DjiWidgetTransmitDataEvent = ::std::os::raw::c_uint;
#[doc = " @brief Widget file binary array."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetFileBinaryArray {
    #[doc = "< The file name of the widget file"]
    pub fileName: *mut ::std::os::raw::c_char,
    #[doc = "< The file size of the widget file, uint : byte"]
    pub fileSize: u32,
    #[doc = "< The binary C array of the widget file"]
    pub fileBinaryArray: *const u8,
}
impl Default for T_DjiWidgetFileBinaryArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Widget binary array config."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetBinaryArrayConfig {
    #[doc = "< Binary array count."]
    pub binaryArrayCount: u16,
    #[doc = "< Pointer to binary array list"]
    pub fileBinaryArrayList: *mut T_DjiWidgetFileBinaryArray,
}
impl Default for T_DjiWidgetBinaryArrayConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Widget handler item."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetHandlerListItem {
    #[doc = " The index of widget, the index can be numbered starting from 0 and cannot be repeated"]
    pub widgetIndex: u32,
    #[doc = " The type of widget, refer to ::E_DjiWidgetType"]
    pub widgetType: E_DjiWidgetType,
    #[doc = " @brief Prototype of callback function used to set widget value, the function will be call when the user triggers\n        the widget.\n @param widgetType: the type of widget, refer to ::E_DjiWidgetType.\n @param index: the index of widget.\n @param value: the value of widget, need be set.\n if the widget type is DJI_WIDGET_TYPE_BUTTON, the value is refer to ::E_DjiWidgetButtonState;\n if the widget type is DJI_WIDGET_TYPE_SWITCH, the value is refer to ::E_DjiWidgetSwitchState;\n if the widget type is DJI_WIDGET_TYPE_SCALE, the value is range from 0 to 100, which represents the percentage\n of the scale slider;\n if the Widget type is DJI_WIDGET_TYPE_LIST, the value is range from 0 to N-1 (N is the value of list item\n count), which represents which item is chosen;\n if the widget type is DJI_WIDGET_TYPE_INT_INPUT_BOX, the value is the input value of int input box widget.\n @param userData: the user data need used in callback.\n @return Execution result."]
    pub SetWidgetValue: ::std::option::Option<
        unsafe extern "C" fn(
            widgetType: E_DjiWidgetType,
            index: u32,
            value: i32,
            userData: *mut ::std::os::raw::c_void,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " @brief Prototype of callback function used to get widget value.\n @param widgetType: the type of widget, refer to ::E_DjiWidgetType.\n @param index\n @param value: the value of widget, need be set.\n if the widget type is DJI_WIDGET_TYPE_BUTTON, the value is refer to ::E_DjiWidgetButtonState;\n if the widget type is DJI_WIDGET_TYPE_SWITCH, the value is refer to ::E_DjiWidgetSwitchState;\n if the widget type is DJI_WIDGET_TYPE_SCALE, the value is range from 0 to 100, which represents the percentage\n of the scale slider;\n if the Widget type is DJI_WIDGET_TYPE_LIST, the value is range from 0 to N-1 (N is the value of list item\n count), which represents which item is chosen;\n if the widget type is DJI_WIDGET_TYPE_INT_INPUT_BOX, the value is the input value of int input box widget.\n @param userData: the user data need used in callback function.\n @return Execution result."]
    pub GetWidgetValue: ::std::option::Option<
        unsafe extern "C" fn(
            widgetType: E_DjiWidgetType,
            index: u32,
            value: *mut i32,
            userData: *mut ::std::os::raw::c_void,
        ) -> T_DjiReturnCode,
    >,
    #[doc = " the user data need used in SetWidgetValue and GetWidgetValue callback function."]
    pub userData: *mut ::std::os::raw::c_void,
}
impl Default for T_DjiWidgetHandlerListItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct T_DjiWidgetTransDataContent {
    pub __bindgen_anon_1: T_DjiWidgetTransDataContent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union T_DjiWidgetTransDataContent__bindgen_ty_1 {
    pub transDataStartContent: T_DjiWidgetTransDataContent__bindgen_ty_1__bindgen_ty_1,
    pub transDataEndContent: T_DjiWidgetTransDataContent__bindgen_ty_1__bindgen_ty_2,
}
#[doc = " When event is 'DJI_WIDGET_TRANSMIT_DATA_EVENT_START', the buf contains file name, uuid and decoder bitrate."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetTransDataContent__bindgen_ty_1__bindgen_ty_1 {
    pub fileName: [u8; 32usize],
    pub fileUuid: [u8; 32usize],
    pub fileDecodeBitrate: u32,
}
#[doc = " When event is 'DJI_WIDGET_TRANSMIT_DATA_EVENT_START', the buf contains file md5 sum."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetTransDataContent__bindgen_ty_1__bindgen_ty_2 {
    pub md5Sum: [u8; 16usize],
}
impl Default for T_DjiWidgetTransDataContent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for T_DjiWidgetTransDataContent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetSpeakerState {
    pub state: E_DjiWidgetSpeakerState,
    pub workMode: E_DjiWidgetSpeakerWorkMode,
    pub playMode: E_DjiWidgetSpeakerPlayMode,
    pub volume: u8,
}
impl Default for T_DjiWidgetSpeakerState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiWidgetSpeakerHandler {
    pub GetSpeakerState: ::std::option::Option<
        unsafe extern "C" fn(speakerState: *mut T_DjiWidgetSpeakerState) -> T_DjiReturnCode,
    >,
    pub SetWorkMode: ::std::option::Option<
        unsafe extern "C" fn(workMode: E_DjiWidgetSpeakerWorkMode) -> T_DjiReturnCode,
    >,
    pub SetPlayMode: ::std::option::Option<
        unsafe extern "C" fn(playMode: E_DjiWidgetSpeakerPlayMode) -> T_DjiReturnCode,
    >,
    pub SetVolume: ::std::option::Option<unsafe extern "C" fn(volume: u8) -> T_DjiReturnCode>,
    pub StartPlay: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    pub StopPlay: ::std::option::Option<unsafe extern "C" fn() -> T_DjiReturnCode>,
    pub ReceiveTtsData: ::std::option::Option<
        unsafe extern "C" fn(
            event: E_DjiWidgetTransmitDataEvent,
            offset: u32,
            buf: *mut u8,
            size: u16,
        ) -> T_DjiReturnCode,
    >,
    pub ReceiveVoiceData: ::std::option::Option<
        unsafe extern "C" fn(
            event: E_DjiWidgetTransmitDataEvent,
            offset: u32,
            buf: *mut u8,
            size: u16,
        ) -> T_DjiReturnCode,
    >,
}
extern "C" {
    #[doc = " @brief Initialise widget module, and user should call this function before using widget features.\n @return Execution result."]
    pub fn DjiWidget_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief  Register default widget UI configuration file directory path.\n @note Under Linux system, there are two functions to set the custom widget configuration directory path, function\n       DjiWidget_RegDefaultConfigByDirPath and DjiWidget_RegUiConfigByDirPath. When you don't need multi-language\n       and multi-screen size support, you can just use DjiWidget_RegDefaultUiConfigByDirPath function set widget UI\n       Config directory path. If you need support multi-language and multi-screen size support, you can use function\n       DjiWidget_RegUiConfigByDirPath to specify widget configuration. When the language and screen size is not\n       cover in your setting by DjiWidget_RegUiConfigByDirPath, the widget UI configuration uses setting by\n       DjiWiget_RegDefaultUiConfigByDirPath function.\n @param widgetConfigDirPath: the widget UI configuration directory path.\n @return Execution result."]
    pub fn DjiWidget_RegDefaultUiConfigByDirPath(
        widgetConfigDirPath: *const ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register widget UI configuration file directory path.\n @note Different widget UI configurations for several language and screen size require the same widget type, index and\n count.\n @param appLanguage: mobile app language type.\n @param appScreenType: mobile app screen type.\n @param widgetConfigDirPath: the widget UI configuration directory path.\n @return Execution result."]
    pub fn DjiWidget_RegUiConfigByDirPath(
        appLanguage: E_DjiMobileAppLanguage,
        appScreenType: E_DjiMobileAppScreenType,
        widgetConfigDirPath: *const ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register default widget UI config by binary array configuration.\n @note In RTOS, most likely there is no file system. The widget config file content can use C array express. Use this\n function and DjiWidget_RegDefaultUiConfigBinaryArray set widget UI configuration. When the language and screen size\n is not cover in your setting by DjiWidget_RegUiConfigByBinaryArray, the widget UI configuration uses setting by this\n function.\n @param binaryArrayConfig: the binary array config for widget UI configuration.\n @return Execution result."]
    pub fn DjiWidget_RegDefaultUiConfigByBinaryArray(
        binaryArrayConfig: *const T_DjiWidgetBinaryArrayConfig,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register widget UI config by binary array configuration.\n @note Different widget UI configurations for several language and screen size require the same widget type, index and\n count.\n @param appLanguage: mobile app language type.\n @param screenType: mobile app screen type.\n @param binaryArrayConfig: the binary array config for widget UI configuration.\n @return Execution result."]
    pub fn DjiWidget_RegUiConfigByBinaryArray(
        appLanguage: E_DjiMobileAppLanguage,
        screenType: E_DjiMobileAppScreenType,
        binaryArrayConfig: *const T_DjiWidgetBinaryArrayConfig,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register handler list for widgets.\n @param widgetHandlerList: widget handler list for widgets.\n @param itemCount: the item count of widget handler list.\n @return Execution result."]
    pub fn DjiWidget_RegHandlerList(
        widgetHandlerList: *const T_DjiWidgetHandlerListItem,
        itemCount: u32,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Send message to mobile app floating window.\n @note the message length can't more than DJI_WIDGET_FLOATING_WINDOW_MSG_MAX_LEN. The max data bandwidth of floating\n windows message is 2KB/s.\n @param str: pointer to message string.\n @return Execution result."]
    pub fn DjiWidgetFloatingWindow_ShowMessage(
        str_: *const ::std::os::raw::c_char,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get data transmission state of floating window channel. User can use the state as base for controlling\n floating windows message send.\n @param state: pointer to floating window channel state.\n @return Execution result."]
    pub fn DjiWidgetFloatingWindow_GetChannelState(
        state: *mut T_DjiDataChannelState,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register the handler for widget speaker function interfaces.\n @note This interface registers the widget speaker function interface, including speaker settings, play operation,\n speaker status interface.\n @param widgetSpeakerHandler: pointer to the handler for widget speaker functions.\n @return Execution result."]
    pub fn DjiWidget_RegSpeakerHandler(
        widgetSpeakerHandler: *const T_DjiWidgetSpeakerHandler,
    ) -> T_DjiReturnCode;
}
#[doc = "< Joint angle limit of roll axis."]
pub const E_DjiXPortLimitAngleCategory_DJI_XPORT_LIMIT_ANGLE_CATEGORY_ROLL_JOINT_ANGLE:
    E_DjiXPortLimitAngleCategory = 0;
#[doc = "< Joint angle limit of pitch axis."]
pub const E_DjiXPortLimitAngleCategory_DJI_XPORT_LIMIT_ANGLE_CATEGORY_PITCH_JOINT_ANGLE:
    E_DjiXPortLimitAngleCategory = 1;
#[doc = "< Euler angle limit of pitch axis, just is limitation of angle in ground coordinate."]
pub const E_DjiXPortLimitAngleCategory_DJI_XPORT_LIMIT_ANGLE_CATEGORY_PITCH_EULER_ANGLE:
    E_DjiXPortLimitAngleCategory = 2;
#[doc = "< Extended euler angle limit of pitch axis, just is limitation of angle in ground coordinate. Extended euler\nangle limit is activated when enable extended pitch axis angle limit."]
pub const E_DjiXPortLimitAngleCategory_DJI_XPORT_LIMIT_ANGLE_CATEGORY_PITCH_EULER_ANGLE_EXTENSION : E_DjiXPortLimitAngleCategory = 3 ;
#[doc = "< Joint angle limit of yaw axis."]
pub const E_DjiXPortLimitAngleCategory_DJI_XPORT_LIMIT_ANGLE_CATEGORY_YAW_JOINT_ANGLE:
    E_DjiXPortLimitAngleCategory = 4;
#[doc = " @brief XPort limit angle category."]
pub type E_DjiXPortLimitAngleCategory = ::std::os::raw::c_uint;
#[doc = " @brief Limit angle data structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct T_DjiXPortLimitAngle {
    #[doc = "< Upper limit of limit angle, unit: 0.1degree."]
    pub upperLimit: i16,
    #[doc = "< Lower limit of limit angle, unit: 0.1degree."]
    pub lowerLimit: i16,
}
#[doc = " @brief Prototype of callback function used to receive system state of XPort.\n @warning User can not execute blocking style operations or functions in callback function, because that will block DJI\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param systemState: system state of XPort.\n @return Execution result."]
pub type DjiReceiveXPortSystemStateCallback = ::std::option::Option<
    unsafe extern "C" fn(systemState: T_DjiGimbalSystemState) -> T_DjiReturnCode,
>;
#[doc = " @brief Prototype of callback function used to receive attitude information of XPort.\n @warning User can not execute blocking style operations or functions in callback function, because that will block DJI\n root thread, causing problems such as slow system response, payload disconnection or infinite loop.\n @param attitudeInformation: attitude information of XPort.\n @return Execution result."]
pub type DjiReceiveXPortAttitudeInformationCallback = ::std::option::Option<
    unsafe extern "C" fn(attitudeInformation: T_DjiGimbalAttitudeInformation) -> T_DjiReturnCode,
>;
extern "C" {
    #[doc = " @brief Initialise XPort module.\n @note The function have to be called before other functions related to XPort.\n @return Execution result."]
    pub fn DjiXPort_Init() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Deinitialize XPort module.\n @return Execution result."]
    pub fn DjiXPort_DeInit() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to receive system state of XPort.\n @note The callback function will be called after registering. The call frequency is 1Hz.\n @param callback: pointer to the callback function.\n @return Execution result."]
    pub fn DjiXPort_RegReceiveSystemStateCallback(
        callback: DjiReceiveXPortSystemStateCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Register callback function used to receive attitude information of XPort.\n @note The callback function will be called after registering. The call frequency is 10Hz.\n @param callback: pointer to the callback function.\n @return Execution result."]
    pub fn DjiXPort_RegReceiveAttitudeInformationCallback(
        callback: DjiReceiveXPortAttitudeInformationCallback,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set gimbal mode of XPort in blocking mode.\n @note Max execution time of this function is slightly larger than 600ms.\n @param mode: gimbal mode.\n @return Execution result."]
    pub fn DjiXPort_SetGimbalModeSync(mode: E_DjiGimbalMode) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Rotate gimbal of XPort in blocking mode.\n @note Max execution time of this function is slightly larger than 600ms.\n @note If rotation mode is ::DJI_GIMBAL_ROTATION_MODE_RELATIVE_ANGLE or ::DJI_GIMBAL_ROTATION_MODE_ABSOLUTE_ANGLE,\n range of yaw value in rotation value argument is [-1800, 1800]. Gimbal can rotate to any angle of yaw axis by the\n range. Symbol of yaw value does not determine the rotation direction of the gimbal.\n @note Attitude that gimbal can reach is also determined by angle limitation and angle limitation buffer of the gimbal.\n When the gimbal is upward, angle limitation differs from limitation users set. For angle limitation and angle limitation\n buffer, please refer to DJI documentation for details. If gimbal attitude is within range limitation buffer and\n control gimbal move towards limit direction still, or gimbal attitude is outside the angle limitation buffer but\n control gimbal to the range limitation buffer, the gimbal will return an error. For the former case, the gimbal will not\n move. In the latter case, the gimbal will try to move towards the direction of angle limit but it will stop at\n somewhere in angle limitation buffer.\n @note Rotation speed and rotation duration are also limited by the maximum speed of gimbal and maximum acceleration. The\n maximum acceleration is determined by the smooth factor of the gimbal controller set by APP. The maximum speed is determined\n by default maximum speed and maximum speed percentage set by APP, and the default maximum speed of XPort is\n 90degree/s. For the detailed relationship, please refer to SetControllerSmoothFactor() and\n SetControllerMaxSpeedPercentage() callback function prototype in dji_gimbal.h file.\n @note Only pitch and yaw axis of XPort is controllable.\n @note XPort do not response rotation command in process of control parameters auto-tuning, coaxiality detection,\n balance detection and resetting. And these operations will interrupt rotation of XPort.\n @note Effective time of a speed control command is 500ms, that is, if XPort do not receive other control commands\n within 500ms after speed control, XPort will stop rotation.\n @param rotationMode: mode of rotation command.\n @param rotationProperty: property of rotation command.\n @param rotationValue: value of rotation command, unit: 0.1 degree (if rotation mode is\n ::DJI_GIMBAL_ROTATION_MODE_RELATIVE_ANGLE or ::DJI_GIMBAL_ROTATION_MODE_ABSOLUTE_ANGLE), 0.1 degree/s\n (if rotation mode is ::DJI_GIMBAL_ROTATION_MODE_SPEED).\n @return Execution result."]
    pub fn DjiXPort_RotateSync(
        rotationMode: E_DjiGimbalRotationMode,
        rotationProperty: T_DjiGimbalRotationProperty,
        rotationValue: T_DjiAttitude3d,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Release gimbal control permission out in blocking mode.\n @details When DJI application control XPort gimbal, DJI application will capture and gain control permission of\n gimbal if allowable. After DJI application sending a sequence of the gimbal control command, DJI application should\n call this interface to release control permission of gimbal, to allow other modules (like APP, flight\n controller) can control gimbal right now. For example, DJI application can release control permission after tap\n zooming. Of course, if DJI application does not release control permission after controlling gimbal, the gimbal will also\n release control permission automatically at some time point later than the completion of control commands. Undoubtedly,\n this is inefficient.\n @note Max execution time of this function is slightly larger than 600ms.\n @note XPort do not response release control permission command in process of control parameters auto-tuning,\n coaxiality detection and balance detection.\n @return Execution result."]
    pub fn DjiXPort_ReleaseControlPermissionSync() -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Reset gimbal of XPort in blocking mode.\n @details The interface reset angle of pitch axis to corresponding fine tune value in ground coordinate, and yaw axis\n to superimposed value of yaw axis angle of aircraft and corresponding fine tune value in ground coordinate.\n @note Max execution time of this function is slightly larger than 600ms.\n @note XPort do not response reset command in process of control parameters auto-tuning, coaxiality detection and\n balance detection.\n @param mode: Reset mode.\n @return Execution result."]
    pub fn DjiXPort_ResetSync(mode: E_DjiGimbalResetMode) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set limit angle for XPort in blocking mode.\n @details Please refer to XPort part of <a href=\"https://developer.dji.com/payload-sdk\">developer website</a> for\n details about default limit angle of XPort.\n @note Max execution time of this function is slightly larger than 1200ms.\n @note XPort do not response set limit angle command in process of control parameters auto-tuning, coaxiality\n detection and balance detection.\n @param limitAngleCategory: limit angle category.\n @param limitAngle: limit angle.\n @return Execution result."]
    pub fn DjiXPort_SetLimitAngleSync(
        limitAngleCategory: E_DjiXPortLimitAngleCategory,
        limitAngle: T_DjiXPortLimitAngle,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Get limit angle of XPort in blocking mode.\n @note Max execution time of this function is slightly larger than 1200ms.\n @param limitAngleCategory: limit angle category.\n @param limitAngle: pointer to memory space used to store limit angle.\n @return Execution result."]
    pub fn DjiXPort_GetLimitAngleSync(
        limitAngleCategory: E_DjiXPortLimitAngleCategory,
        limitAngle: *mut T_DjiXPortLimitAngle,
    ) -> T_DjiReturnCode;
}
extern "C" {
    #[doc = " @brief Set speed conversion factor for speed control from joystick and APP.\n @details XPort convert speed control command from joystick and APP to rotation speed based on the speed conversion\n factor. The formula is \"speed = maximum rotation speed * conversion factor\", and maximum rotation speed is a product of\n default maximum speed and maximum speed percentage. The default maximum rotation speed is 90degree/s. The maximum\n speed percentage is set by APP. The default speed conversion factor is 1.0.\n @note The value will be effective after a while, and the max value is 100ms.\n @param factor: Speed conversion factor and it has to be smaller than or equal to 1.0.\n @return Execution result."]
    pub fn DjiXPort_SetSpeedConversionFactor(factor: f32) -> T_DjiReturnCode;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
