
# 智能指针

## 概念

行为和指针相似,并且有额外的元数据,和额外的功能.
一句话，可以像指针一样操作这个结构。

`String` 就是一个智能指针. 因为实现了`Drop Reref Trait`,
他们内部拥有数据,并且可以像用指针那样来操作他,可以直接通过`*`来获取数据.


## Drop 和 Deref
`Drop trait` 是所有类型都有的,当对象所有权离开作用域就会被调用.
只有引用才有生命周期,然后通过生命周期去回收数据,回收的都是堆上的数据, 
回收的时候其实就是调用的`drop`,所以智能指针,也需要实现`drop trait`
这样才能回收, 并且任意类型都可是实现`drop`,不仅可以回收对象了,还可以一些收尾操作,
比如断开连接.但是不建议,除非是非常底层的代码为了更高的效率,否则还是以代码可读性和逻辑清晰为主.

`Deref trait` 是选择实现,如果想像操作指针那样操作这个对象,那么实现这个`trait`,主要是实现
`deref()`方法。
因为智能指针本身就拥有数据，理论上可以直接获取数据。
实现原理就是，我们解引用的时候调用`deref()`，如果里面的数据还是一个智能指针就调用`deref()`。
# 所有权、借用、生命周期
一个数据对象只能用let绑定一个变量，赋值和作为参数传递的时候会转移所有权。

如何才能不让所有权转移呢？有两个办法，一个是用Rc指针来共享所有权，一个是用&来借用，就是引用。 
当使用借用的时候，原对象可能以后被释放掉了，因此有可能出现悬垂指针的问题，所以要用生命周期解决这个问题。

无论是使用借用还是Rc指针都会遇到想改变变量值的需求。
- 是借用的话，有可变借用可以选择，使用可变借用要注意：`可变借用创建出来到最后一次使用这段作用范围内，
是不允许有该变量原对象出现的，也不允许和不可变借用的生命周期重合`。
- Rc的话，Rc要使用Rc::get_mut 获取到Some后才能改变值，
需要注意的是只有当前Rc的strong计数为1，才能获取到Some，否则只能获取到None。也就是说Rc不可变借用只能有一个。

通过上面可以看出是，借用是不能共享所有权的，Rc是可以共享所有权的，他们唯一的共同点就是，
他们都可以防止所有权转移，另外都可以改变原变量的值，但是改变的时候只能有一个可变借用或一个Rc。
上面这些限制，如果这个实例只在一个对象中，是没有问题的。
但是我们一般一个实例是在多个对象中共用的，此时多个对象，有的只读，有的要修改。那么这个实例就要
在运行时的同时支持可变和不可变。借用和Rc都是在编译时可变不可变就已经确定了。
这就要用到RefCell了，这个本身不可变，但是可以改变内部的值。
可通过`borrow()`,`borrow_mut()`来获取到可变和不可变的借用。要注意的是，它的可变借用，也只有一个。








